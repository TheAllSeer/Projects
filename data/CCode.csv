,C
0,//setup
1,    RCC->AHBENR |= 0x20000; //bit 17
2,    GPIOA->MODER |= 0x100000; // MODER10 (PA10)
3,    GPIOA->OTYPER |= (1<<10); // bit 10
4,// main
5,      GPIOA->BSRR = 0x400; LED HIGH
6,      HAL_Delay(1000);
7,      GPIOA->BRR = 0x400; LED LOW
8,      HAL_Delay(1000);
9,OTYPER
10,MODER
11,RCC->AHBENR |= 0x20000;
12,RCC->AHBENR |= RCC_AHBENR_IOPAEN;
13,RCC->AHBENR |= RCC_AHBENR_IOPAEN;
14,vga.h
15,vga.c
16,"putstring(size_t posx, size_t posy, const char *str)"
17,├── boot
18,│   ├── boot.s
19,│   └── grub.cfg
20,├── kmain.c
21,├── libc
22,│   ├── include
23,│   │   └── string.h
24,│   └── string.c
25,├── libk
26,│   ├── font.c
27,│   ├── include
28,│   │   ├── font.h
29,│   │   └── vga.h
30,│   └── vga.c
31,├── linker.ld
32,└── makefile
33,AS = i686-elf-as
34,CC = i686-elf-gcc
35,
36,CFLAGS = -std=gnu99 -ffreestanding -O2 -Wall -Wextra
37,LFLAGS = -ffreestanding -O2 -nostdlib
38,
39,BUILD_DIR = ../build
40,LIBC_OBJ_DIR = $(BUILD_DIR)/libc
41,LIBK_OBJ_DIR = $(BUILD_DIR)/libk
42,BOOT_OBJ_DIR = $(BUILD_DIR)/boot
43,ISO_DIR = $(BUILD_DIR)/iso
44,KERNEL_DIR = $(BUILD_DIR)
45,
46,ISO = release.iso
47,KERNEL = $(KERNEL_DIR)/kernel.bin
48,
49,# Object files
50,
51,LIBC_OBJ = \
52,    $(LIBC_OBJ_DIR)/string.o
53,
54,LIBK_OBJ = \
55,    $(LIBK_OBJ_DIR)/vga.o
56,
57,BOOT_OBJ = \
58,    $(BOOT_OBJ_DIR)/boot.o
59,
60,KERNEL_OBJ = $(LIBK_OBJ_DIR)/kmain.o
61,
62,.PHONY: iso
63,iso: kernel | $(ISO_DIR)
64,    grub-mkrescue -o $(BUILD_DIR)/$(ISO) $(ISO_DIR)
65,
66,$(ISO_DIR):
67,    mkdir -p $(ISO_DIR)/boot/grub
68,    cp boot/grub.cfg $(ISO_DIR)/boot/grub/grub.cfg
69,    cp $(KERNEL) $(ISO_DIR)/boot/kernel.bin
70,
71,.PHONY: kernel
72,kernel: libc libk kmain.c boot | $(KERNEL_DIR)
73,    $(CC) -c kmain.c -o $(KERNEL_OBJ) $(CFLAGS)
74,    $(CC) -T linker.ld -o $(KERNEL) $(LFLAGS) \
75,        $(wildcard $(LIBC_OBJ_DIR)/*) \
76,        $(wildcard $(LIBK_OBJ_DIR)/*) \
77,        $(KERNEL_OBJ) \
78,        $(wildcard $(BOOT_OBJ_DIR)/*) \
79,        -lgcc
80,
81,
82,$(KERNEL_DIR):
83,    mkdir -p $(KERNEL_DIR)
84,
85,.PHONY: clean
86,clean:
87,    rm -r $(BUILD_DIR)/*
88,
89,# Rules for libc
90,
91,.PHONY: libc
92,libc: $(LIBC_OBJ)
93,
94,$(LIBC_OBJ_DIR)/%.o: $(wildcard libc/*.c) | $(LIBC_OBJ_DIR)
95,    $(CC) -c $< -o $@ $(CFLAGS)
96,
97,$(LIBC_OBJ_DIR):
98,    mkdir -p $(LIBC_OBJ_DIR)
99,
100,
101,# Rules for libk
102,
103,.PHONY: libk
104,libk: $(LIBK_OBJ)
105,
106,$(LIBK_OBJ_DIR)/%.o: $(wildcard libk/*.c) | $(LIBK_OBJ_DIR)
107,    $(CC) -c $< -o $@ $(CFLAGS)
108,
109,$(LIBK_OBJ_DIR):
110,    mkdir -p $(LIBK_OBJ_DIR)
111,
112,
113,# Rules for boot
114,
115,.PHONY: boot
116,boot: $(BOOT_OBJ_DIR)/boot.o
117,
118,$(BOOT_OBJ_DIR)/%.o: $(wildcard boot/*.s) | $(BOOT_OBJ_DIR)
119,    $(AS) $< -o $@
120,
121,$(BOOT_OBJ_DIR):
122,    mkdir -p $(BOOT_OBJ_DIR)
123,mkdir -p ../build/libc
124,i686-elf-gcc -c libc/string.c -o ../build/libc/string.o -std=gnu99 -ffreestanding -O2 -Wall -Wextra
125,mkdir -p ../build/libk
126,i686-elf-gcc -c libk/font.c -o ../build/libk/vga.o -std=gnu99 -ffreestanding -O2 -Wall -Wextra
127,mkdir -p ../build/boot
128,i686-elf-as boot/boot.s -o ../build/boot/boot.o
129,i686-elf-gcc -c kmain.c -o ../build/libk/kmain.o -std=gnu99 -ffreestanding -O2 -Wall -Wextra
130,i686-elf-gcc -T linker.ld -o ../build/kernel.bin -ffreestanding -O2 -nostdlib \
131,    ../build/libc/string.o \
132,    ../build/libk/vga.o \
133,    ../build/libk/kmain.o \
134,    ../build/boot/boot.o \
135,    -lgcc
136,/home/neon/tools/crc/lib/gcc/i686-elf/12.2.0/../../../../i686-elf/bin/ld: ../build/libk/kmain.o: in function `kmain':
137,kmain.c:(.text+0x20): undefined reference to `putstring'
138,collect2: error: ld returned 1 exit status
139,make: *** [makefile:58: kernel] Fehler 1
140,string.h
141,#if defined(__linux__)
142,"#  error ""This program needs to be build with a cross compiler"""
143,#endif
144,
145,#if !defined(__i386__)
146,"#  error ""You have to use a ix86-elf compiler!"""
147,#endif
148,
149,#include <stddef.h>
150,#include <stdint.h>
151,
152,"#include ""libc/include/string.h"""
153,"#include ""libk/include/vga.h"""
154,
155,void kmain(void) {
156,"  // i just wanted to know, if these imports work"
157,  uint16_t abc;
158,"  memset16(&abc, 1, 1);"
159,
160,  // This does not work
161,"  putstring(5, 2, ""Hello, world!\0"");"
162,}
163,vga.h
164,#ifndef __VGA_H__
165,#  define __VGA_H__
166,
167,#include <stddef.h>
168,#include <stdint.h>
169,
170,"#include ""../../libc/include/string.h"""
171,
172,#define TBUFF 0xb8000
173,#define CHARS 80
174,#define LINES 25
175,
176,"#define vgacolor(fg, bg) ((fg) | ((bg) << 4))"
177,"#define vgachar(ch, color) ((ch) | ((color) << 8))"
178,"#define cursor(start, posx, posy) ((uint16_t*)((start) + ((posx) * CHARS * 2) + ((posx) * 2)))"
179,
180,"extern void putchar(size_t posx, size_t posy, char ch);"
181,extern void refresh(void);
182,"extern void putstring(size_t posx, size_t posy, const char *str);"
183,extern void clear(void);
184,
185,#endif
186,ENTRY(_start)
187,
188,SECTIONS {
189,  . = 1M;
190,
191,  .text BLOCK(4K) : ALIGN(4K) {
192,    *(.multiboot)
193,    *(.text)
194,  }
195,
196,  .rodata BLOCK(4K) : ALIGN(4K) {
197,    *(.rodata)
198,  }
199,
200,  .data BLOCK(4K) : ALIGN(4K) {
201,    *(.data)
202,  }
203,
204,  .bss BLOCK(4K) : ALIGN(4K) {
205,    *(COMMON)
206,    *(.bss)
207,  }
208,}
209,__VGA_H__
210,kmain.c
211,vga.c
212,vga.o
213,font.c
214,i686-elf-gcc -c libk/font.c -o ../build/libk/vga.o ...
215,vga.c
216,$(LIBK_OBJ_DIR)/%.o: $(wildcard libk/*.c) | $(LIBK_OBJ_DIR)
217,        $(CC) -c $< -o $@ $(CFLAGS)
218,../build/libk/%.o: libk/font.c libk/vga.c | $(LIBK_OBJ_DIR)
219,        $(CC) -c $< -o $@ $(CFLAGS)
220,../build/libk/%.o
221,$<
222,libk/font.c
223,$(LIBK_OBJ_DIR)/%.o: libk/%.c | $(LIBK_OBJ_DIR)
224,        $(CC) -c $< -o $@ $(CFLAGS)
225,.o
226,.c
227,#include <windows.h>
228,#include <stdio.h>
229,int main()
230,{
231,"    FILE *file =fopen(""Eva.wav"",""r"");"
232,    if (file==NULL)
233,"        printf(""heresy read!"");"
234,    
235,    for(int i=0;i<200;i++)
236,    {
237,        char a = fgetc(file);
238,"        printf(""%hhX "",a);"
239,    }
240,    fclose(file);
241,    return 0;
242,}
243,C:\Users\phoenix\Documents\gccex\serial>a.exe
244,52 49 46 46 46 FF8C FFA3 0 57 41 56 45 66 6D 74 20 10 0 0 0 1 0 1 0 44 FFAC 0 0 44 FFAC 0 0 1 0 8 0 4C 49 53 54 FF86 FFAA 6A FFFB FFFE 7F 0 0 FF88 2C 40 0 0 0 0 0 0 0 0 0 0 0 0 0 10 15 40 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 11 0 1 10 0 0 0 0 60 7 FF96 0 0 0 0 0 FF86 FFAA 6A FFFB FFFE 7F 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 FFB0 16 40 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 50 13 FF96 0 0 0 0 0 FF83 16 40 0 0 0 0 0 1 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 70 13 FF96 0 0 0 0 0 FFB0 16 40 0 0 0 0 0 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FF99 17 40 0 0 0 0 0 10 0 0 0 0 0 0 0 FF99 16 40 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0
245,-1
246,EOF
247,fread
248,fgets
249,.wav
250,char a = fgetc(file);
251,int
252,char
253,int
254,'A'
255,char
256,int
257,"""rb"""
258,"""r"""
259,fgetc
260,EOF
261,-1
262,EOF
263,    for(int i=0;i<200;i++)
264,    {
265,"        int a = fgetc(file); //the type must be int, not char"
266,
267,        if ( a == EOF )
268,        {
269,"            printf( ""EOF\n"" );"
270,            break;
271,        }
272,
273,"        printf(""%hhX "",a);"
274,    }
275,fgetc
276,EOF
277,0x1A
278,0x1A
279,0x28
280,0x27
281,39
282,#include <cs50.h>
283,#include <stdio.h>
284,#include <ctype.h>
285,#include <string.h>
286,
287,"int main(int argc, string key[])"
288,{
289,    //check if user typed key arguement
290,    if (argc == 2)
291,    {
292,"        //if they did, how many characters are there?"
293,        while (strlen(key[1]) != 26)
294,        {
295,"            printf(""Key must contain 26 characters\n"");"
296,            return 1;
297,        }
298,        return 0;
299,
300,        ***//Make sure the characters are letters
301,"        int n = strlen(key[1]), i;"
302,        string k = key[1];
303,        for (i = 0; i < n; i++)
304,        {
305,            if (!isalpha(k[i]))
306,            {
307,"                printf(""Key must contain only alphabetical characters\n"");"
308,                return 1;
309,            }
310,        }***
311,    }
312,    //if they did not type or type more than one argument reply the following:
313,    else if (argc != 2)
314,    {
315,"        printf(""Usage: ./substitution key\n"");"
316,        return 1;
317,    }
318,    return 0;
319,}
320,    while (strlen(key[1]) != 26)
321,    {
322,"        printf(""Key must contain 26 characters\n"");"
323,        return 1;
324,    }
325,    return 0;
326,    ^^^^^^^^^
327,    if ( strlen(key[1]) != 26 )
328,    {
329,"        printf(""Key must contain 26 characters\n"");"
330,        return 1;
331,    }
332,else if (argc != 2)
333,{
334,//...
335,else 
336,{
337,//...
338,return 0;
339,"int main(int argc, string key[])"
340,{
341,    if (argc != 2) {
342,"        printf(""Usage: ./substitution key\n"");"
343,        return 1;
344,    }
345,
346,    if (strlen(key[1] != 26) {
347,"        printf(""Key must contain 26 characters\n"");"
348,        return 1;
349,    }
350, 
351,    //Make sure the characters are letters
352,"    int n = strlen(key[1]), i;"
353,    string k = key[1];
354,    for (i = 0; i < n; i++)
355,    {
356,        if (!isalpha(k[i]))
357,        {
358,"            printf(""Key must contain only alphabetical characters\n"");"
359,            return 1;
360,        }
361,    }
362,
363,    return 0;
364,}
365,if
366,while (A) {
367,    return B;
368,}
369,if (A) {
370,    return B;
371,}
372,100us
373,long microseconds = 100L;
374,"printf(""%lus"", microseconds);"
375,100s
376,u
377,%l
378,unsigned long
379,long
380,%l
381,%ld
382,printf
383,long microseconds = 100L;
384,"printf(""%ldus"", microseconds);"
385,%lius
386,"printf(""%luus"", microseconds); // note exta 'u' here"
387,microseconds
388,long
389,%lius
390,long int
391,"char* a=""dsa"" ""qwe"";"
392,"printf(""%s"", a);"
393,dsaqwe
394,"""dsa""""qwe"""
395,:)
396,6.4.5 String literals
397,C11
398,"5.1.1.2 Translation phases, point 6"
399,"""abc"" ""def"""
400,"""abcdef"""
401,"const char *myString = ""This is a really long """
402,"                       ""string and I don't want """
403,"                       ""to make my lines in the """
404,"                       ""editor too long, because """
405,"                       ""I'm basically anal retentive :-)"";"
406,const char *
407,:)
408,"#define FIRST ""John"""
409,"#define LAST ""Doe"""
410,
411,"const char* name = FIRST "" "" LAST;"
412,"const char* salutation = ""Dear "" FIRST "","";"
413,printf
414,scanf
415,<inttypes.h>
416,PRId32
417,§5.1.1.2
418,#include <stdio.h>
419,"#include ""cs50.h"""
420,#include <string.h>
421,
422,
423,string get_items();
424,
425,
426,
427,bool check_items_add = true;
428,
429,int main()
430,{
431,    string units = get_items();
432,"    printf(""%s\n"", units[1]);"
433,}
434,
435,string get_items()
436,{
437,"    string items[] = get_string(""Write market item: "");"
438,    while (check_items_add)
439,    {
440,        
441,"        items += get_string(""Write market item: "");"
442,    }
443,    return items;
444,}
445,+=
446,"string items[] = get_string(""Write market item: "");"
447,get_string
448,get_string
449,#include <stdio.h>
450,"#include ""cs50.h"""
451,#include <string.h>
452,
453,#define MAX_STRINGS 100
454,
455,int main( void )
456,{
457,    string strings[MAX_STRINGS];
458,    int num_strings = 0;
459,
460,"    printf( ""In order to stop, please enter an empty string.\n"" );"
461,
462,    //read strings into array
463,    for ( int i = 0; i < MAX_STRINGS; i++ )
464,    {
465,"        strings[i] = get_string( ""Please enter string #%d: "", i + 1 );"
466,
467,        //determine whether string is empty
468,        if ( strings[i][0] == '\0' )
469,            break;
470,
471,        num_strings++;
472,    }
473,
474,"    printf( ""You have entered the following %d strings:\n"", num_strings );"
475,
476,    //print all strings
477,    for ( int i = 0; i < num_strings; i++ )
478,    {
479,"        printf( ""%d: %s\n"", i + 1, strings[i] );"
480,    }
481,}
482,"In order to stop, please enter an empty string."
483,Please enter string #1: test1
484,Please enter string #2: test2
485,Please enter string #3: test3
486,Please enter string #4: 
487,You have entered the following 3 strings:
488,1: test1
489,2: test2
490,3: test3
491,void display(){
492,    temp = tail; //tail points to the last node
493,    do{
494,        temp = temp -> next;  //next points the the next node
495,"        printf(""%d\t"",temp -> data);"
496,    }while(temp != tail);
497,"    printf(""\n"");"
498,}
499,temp->next
500,#include <stdio.h>
501,int main()
502,{
503,    short  int a = 40000;
504,"    printf(""%d"", a);"
505,    return 0;
506,}
507,short unsigned int a = 70000
508,65536-70000
509,short int
510,short int
511,"printf(""%hd"", a);"
512,gcc
513,int
514,40000
515,40 9C 00 00
516,short
517,40 9C
518,#include <process.h>
519,
520,int main(void)
521,{
522,"    if (execlp(""c:\\windows\\system32\\whoami.exe"", ""c:\\windows\\system32\\whoami.exe"") < 0)"
523,"        perror(""error"");"
524,
525,    return 1;
526,}
527,Problem signature:
528,Problem Event Name: APPCRASH
529,Application Name:   a.exe
530,Application Version:    0.0.0.0
531,Application Timestamp:  00000000
532,Fault Module Name:  msvcrt.dll
533,Fault Module Version:   7.0.7601.17744
534,Fault Module Timestamp: 4eeaf722
535,Exception Code: c0000005
536,Exception Offset:   0005b4fe
537,OS Version: 6.1.7601.2.1.0.256.1
538,Locale ID:  1033
539,Additional Information 1:   0a9e
540,Additional Information 2:   0a9e372d3b4ad19135b953a78882e789
541,Additional Information 3:   0a9e
542,Additional Information 4:   0a9e372d3b4ad19135b953a78882e789
543,execlp()
544,"#include ""stdio.h"""
545,"// a program that takes the price of two items, applies a discount on the cheaper item and then calculates the outcome that needs to be paid."
546,int main()
547,{
548,    float item_one;
549,    float item_two;
550,    float discount_percentage= 50;
551,    float discount_amount;
552,    float total;
553,    float cheaper_item;
554,
555,"    printf(""\n Insert the price of the first item : "");"
556,"    scanf(""%f"", &item_one);"
557,
558,"    printf(""\n Insert the price of the first item : "");"
559,"    scanf(""%f"", &item_two);"
560,
561,    if ( item_one < item_two)
562,        cheaper_item = item_one;
563,    else
564,        cheaper_item = item_two;
565,
566,    discount_amount = (discount_percentage*cheaper_item)/100;
567,
568,"    printf (""\n Discount amount : %f \n"", discount_amount);"
569,
570,    total = (discount_amount + cheaper_item);
571,
572,"    printf (""Total to pay : %f \n"", total);"
573,}
574,float* cheaperItem
575,float* otherItem
576,if
577,total = (item_one + item_two - discount_amount);
578,"char write_value[] = ""...4096 bytes of data..."";"
579,int  write_block   = 12345;
580,
581,int block_size = 4096;
582,
583,FILE *fp;
584,"fp = fopen(""file.txt"",""w+"");"
585,
586,"fseek(fp, write_block * block_size, SEEK_SET);"
587,"fputs(write_value, fp);"
588,fsync(fp);
589,fclose(fp);
590,open
591,fopen
592,mmap
593,fseek
594,fwrite
595,flockfile
596,fseek
597,fwrite_unlocked
598,funlock
599,pread
600,pwrite
601,<aio.h>
602,pwrite
603,fsync
604,fflush
605,setvbuf
606,fsync
607,pread
608,pwrite
609,pwrite()
610,O_APPEND
611,SolutionDir:
612,┝ Builds/
613,| ┝ Inter/ #For intermediate files
614,| | ┝ Debug/
615,| | | ┕ lib.o
616,| | ┕ Release/
617,| |   ┕ lib.o
618,| ┝ Debug/ #For the debug build files
619,| | ┕ ProjectName/ ... .exe
620,| ┕ Release/ #For the release build files
621,|   ┕ ProjectName/ ... .exe
622,┕ ProjectName/
623,  ┕ Source/
624,    | lib.h
625,    ┕ lib.c
626,SolutionDir/CMakeLists.txt
627,cd SolutionDir
628,mkdir Builds
629,cd Builds
630,cmake ..
631,make -j8
632,Builds
633,SolutionDir
634,CMakeLists.txt
635,cmake
636,malloc()
637,free()
638,free()
639,free()
640,#include <stdlib.h>
641,
642,struct node {int value; struct node* next;};
643,
644,typedef struct {struct node* first; struct node* last;} linkedList;
645,
646,void initializeLinkedList(linkedList* list)
647,{
648,    list->first = list->last = NULL;
649,}
650,
651,// O(1)
652,"void addLastLinkedList(linkedList* list, int element)"
653,{
654,    // create a new node
655,    struct node* insertionNode = malloc(sizeof(struct node));
656,    insertionNode->value = element;
657,
658,    // check if the linked list is empty
659,    if (list->first==NULL) list->first = list->last = insertionNode;
660,    else
661,    {
662,        // make last node point to this node
663,        list->last->next = insertionNode;
664,"        // make the last node, this node"
665,        list->last       = insertionNode;
666,    }
667,}
668,
669,// O(1)
670,"void addFirstLinkedList(linkedList* list, int element)"
671,{
672,    // create a new node
673,    struct node* insertionNode = malloc(sizeof(struct node));
674,    insertionNode->value = element;
675,
676,    // check if the linked list is empty
677,    if (list->first==NULL) list->first = list->last = insertionNode;
678,    else
679,    {
680,        // make node point to the first node
681,        insertionNode->next = list->first;
682,        // make it the first node
683,        list->first = insertionNode;
684,    }
685,}
686,
687,// O(n)
688,int removeLastLinkedList(linkedList* list)
689,{
690,    // check if the linked list is empty
691,    if (list->first==NULL) return -1;
692,    // check if the linked list only has a single item
693,    if (list->first==list->last) list->first = list->last = NULL;
694,    // get the last to second node
695,    struct node* currentNode = list->first;
696,    while (currentNode != NULL)
697,    {
698,        if (currentNode->next == list->last) break;
699,        currentNode = currentNode->next;
700,    }
701,    // set the last node to the second to last node
702,    list->last       = currentNode;
703,    list->last->next = NULL;
704,}
705,
706,// O(1)
707,int removeFirstLinkedList(linkedList* list)
708,{
709,    // check if the linked list is empty
710,    if (list->first==NULL) return -1;
711,    // check if the linked list only has a single item
712,    if (list->first==list->last) list->first = list->last = NULL;
713,    // get the second node
714,    struct node* secondNode = list->first->next;
715,    // remove the pointer of first node
716,    list->first->next = NULL;
717,"    // make the second node, the first node"
718,    list->first = secondNode;
719,    return 0;
720,}
721,addLastLinkedList
722,insertionNode->next = NULL;
723,next
724,addLastLinkedList
725,addFirstLinkedList
726,next
727,insertionNode->next = NULL;
728,removeLastLinkedList
729,if (list->first==list->last) list->first = list->last = NULL;
730,struct node* currentNode = list->first;
731,//...
732,// set the last node to the second to last node
733,list->last       = currentNode;
734,list->last->next = NULL;
735,list->last
736,next
737,int removeLastLinkedList(linkedList* list)
738,{
739,    // check if the linked list is empty
740,    if (list->first==NULL) return -1;
741,
742,    // check if the linked list only has a single item
743,    if ( list->first == list->last ) 
744,    {
745,        free( list->first );
746,        list->first = list->last = NULL;
747,    }
748,    else
749,    {
750,        // get the last to second node
751,        struct node *currentNode = list->first;
752,        while ( currentNode->next != list->last )
753,        {
754,            currentNode = currentNode->next;
755,        }
756,
757,        free( currentNode->next );
758,        // set the last node to the second to last node
759,        list->last       = currentNode;
760,        list->last->next = NULL;
761,    }
762,
763,    return 0;
764,}
765,removeFirstLinkedList
766,int removeFirstLinkedList(linkedList* list)
767,{
768,    // check if the linked list is empty
769,    if (list->first==NULL) return -1;
770,
771,    // check if the linked list only has a single item
772,    if ( list->first == list->last ) 
773,    {
774,        free( list->first );
775,        list->first = list->last = NULL;
776,    }
777,    else
778,    {
779,        // get the second node
780,        struct node *secondNode = list->first->next;
781,        free( list->first );
782,"        // make the second node, the first node"
783,        list->first = secondNode;
784,    }
785,
786,    return 0;
787,}
788,"""tcp[tcpflags] & (tcp-syn) != 0 and not net 127.0.0.1"""
789, tcp[tcpflags] & (tcp-syn|tcp-ack) == tcp-syn
790,"void grayscale(int height, int width, RGBTRIPLE image[height][width])"
791,{
792,    for (int i = 0; i < height; i++)
793,    {
794,        for (int j = 0; j < width; j++)
795,        {
796,            image[i][j].rgbtBlue = (image[i][j].rgbtBlue + image[i][j].rgbtRed + image[i][j].rgbtGreen) / 3;
797,
798,            image[i][j].rgbtRed = image[i][j].rgbtBlue;
799,            image[i][j].rgbtGreen = image[i][j].rgbtBlue;
800,        }
801,    }
802,    return;
803,}
804,// Convert image to grayscale
805,"void grayscale(int height, int width, RGBTRIPLE image[height][width])"
806,{
807,    for (int i = 0; i < height; i++)
808,    {
809,        for (int j = 0; j < width; j++)
810,        {
811,            image[i][j].rgbtBlue = (image[i][j].rgbtBlue + image[i][j].rgbtRed + image[i][j].rgbtGreen);
812,
813,            // Notice this line
814,            image[i][j].rgbtBlue /= 3;
815,
816,            image[i][j].rgbtRed = image[i][j].rgbtBlue;
817,            image[i][j].rgbtGreen = image[i][j].rgbtBlue;
818,        }
819,    }
820,    return;
821,}
822,height
823,width
824,image
825,typedef uint8_t  BYTE;
826,typedef struct
827,{
828,    BYTE  rgbtBlue;
829,    BYTE  rgbtGreen;
830,    BYTE  rgbtRed;
831,} __attribute__((__packed__))
832,RGBTRIPLE;
833,RGBTRIPLE
834,rgbtBlue
835,int
836,char
837,RGBTRIPLE
838,RGBTRIPLE
839,RGBTRIPLE
840,rgbtBlue
841,rgbtRed
842,rgbtGreen
843,typedef uint8_t  BYTE;
844,image[i][j].rgbtBlue + image[i][j].rgbtRed + image[i][j].rgbtGreen
845,uint8_t
846,image[i][j].rgbtBlue = (image[i][j].rgbtBlue + image[i][j].rgbtRed + image[i][j].rgbtGreen) / 3;
847,417/3
848,139
849,int
850,image[i][j].rgbtBlue = (image[i][j].rgbtBlue + image[i][j].rgbtRed + image[i][j].rgbtGreen);
851,image[i][j].rgbtBlue /= 3;
852,417 % 256
853,161
854,3
855,#include <stdio.h>
856,
857,int main(void)
858,{
859,   int i = 0;
860,   i = i++ + ++i;
861,"   printf(""%d\n"", i); // 3"
862,
863,   i = 1;
864,   i = (i++);
865,"   printf(""%d\n"", i); // 2 Should be 1, no ?"
866,
867,   volatile int u = 0;
868,   u = u++ + ++u;
869,"   printf(""%d\n"", u); // 1"
870,
871,   u = 1;
872,   u = (u++);
873,"   printf(""%d\n"", u); // 2 Should also be one, no ?"
874,
875,   register int v = 0;
876,   v = v++ + ++v;
877,"   printf(""%d\n"", v); // 3 (Should be the same as u ?)"
878,
879,   int w = 0;
880,"   printf(""%d %d\n"", ++w, w); // shouldn't this print 1 1"
881,
882,"   int x[2] = { 5, 8 }, y = 0;"
883,   x[y] = y ++;
884,"   printf(""%d %d\n"", x[0], x[1]); // shouldn't this print 0 8? or 5 0?"
885,}
886,(i++)
887,i = (i++);
888,i = (i++);
889,i++;
890,volatile
891,u = (u++);
892,i = ++i + 1;
893,A
894,B
895,A
896,B
897,A
898,B
899,A
900,B
901,A
902,B
903,A
904,B
905,A
906,B
907,int i = 1;
908,i = i++;
909,i
910,i
911,++
912,i
913,il
914,i++
915,ir
916,il = ir++     // Note that suffix l and r are used for the sake of clarity.
917,              // Both il and ir represents the same object.  
918,++
919,++
920,il = ir++
921,temp = ir;      // i = 1
922,ir = ir + 1;    // i = 2   side effect by ++ before assignment
923,il = temp;      // i = 1   result is 1  
924,temp = ir;      // i = 1
925,il = temp;      // i = 1   side effect by assignment before ++
926,ir = ir + 1;    // i = 2   result is 2  
927,1
928,2
929,++
930,i=i=5
931,A=B=5;
932,C=A+B;
933,A=B=5;
934,C=A+B;
935,I=I=5;
936,$ cat evil.c
937,void evil(){
938,  int i = 0;
939,  i+= i++ + ++i;
940,}
941,$ gcc evil.c -c -o evil.bin
942,$ gdb evil.bin
943,(gdb) disassemble evil
944,Dump of assembler code for function evil:
945,   0x00000000 <+0>:   push   %ebp
946,"   0x00000001 <+1>:   mov    %esp,%ebp"
947,"   0x00000003 <+3>:   sub    $0x10,%esp"
948,"   0x00000006 <+6>:   movl   $0x0,-0x4(%ebp)  // i = 0   i = 0"
949,"   0x0000000d <+13>:  addl   $0x1,-0x4(%ebp)  // i++     i = 1"
950,"   0x00000011 <+17>:  mov    -0x4(%ebp),%eax  // j = i   i = 1  j = 1"
951,"   0x00000014 <+20>:  add    %eax,%eax        // j += j  i = 1  j = 2"
952,"   0x00000016 <+22>:  add    %eax,-0x4(%ebp)  // i += j  i = 3"
953,"   0x00000019 <+25>:  addl   $0x1,-0x4(%ebp)  // i++     i = 4"
954,   0x0000001d <+29>:  leave  
955,   0x0000001e <+30>:  ret
956,End of assembler dump.
957,gcc evil.c -c -o evil.bin
958,gdb evil.bin
959,disassemble evil
960,Why are these constructs undefined behavior?
961,gcc -S evil.c
962,6.5
963,i = i++ + ++i;
964,i++
965,++i
966,i
967,u
968,6.5
969,i = ++i + 1;
970,a[i++] = i; 
971,;
972,i = i++ + ++i;
973,^   ^       ^
974,
975,i = (i++);
976,^    ^
977,
978,u = u++ + ++u;
979,^   ^       ^
980,
981,u = (u++);
982,^    ^
983,
984,v = v++ + ++v;
985,^   ^       ^
986,3.4.4
987,3.4.3
988,i = i++ + ++i
989,i = i++
990,i = i + 1
991,i++
992,i = i++
993,*p=(*q)++;
994,if (p!=q) *p=(*q)++; else *p= __ARBITRARY_VALUE;
995,*p
996,else
997,if
998,assert
999,assert(p != q)
1000,<assert.h>
1001,__builtin_assert_disabled()
1002,i
1003,i
1004,i
1005,"printf(""%d %d\n"", i, i++);"
1006,"printf(""%d %d\n"", ++i, i++);"
1007,printf()
1008,x = i++ + i++;
1009,"printf(""%d %d\n"", ++i, i++);"
1010,printf()
1011,i++
1012,++i
1013,"printf(""%d %d\n"", ++x, y++);"
1014,++x
1015,y++
1016,++x
1017,y++
1018,"printf(""%d %d\n"", ++i, i++);"
1019,i
1020,int i = 5;
1021,int j;
1022,
1023,"j = (++i, i++);  // No undefined behaviour here because the comma operator "
1024,                 // introduces a sequence point between '++i' and 'i++'
1025,
1026,"printf(""i=%d j=%d\n"",i, j); // prints: i=7 j=6"
1027,"j = (++i, i++);"
1028,++i
1029,i
1030,6
1031,i++
1032,i
1033,6
1034,j
1035,i
1036,7
1037,"printf(""%d %d\n"", ++i, i++);"
1038,"int a = 10, b = 20, c = 30; printf(""a=%d b=%d c=%d\n"", (a = a + b + c), (b = b + b), (c = c + c));"
1039,b
1040,c
1041,-Wsequence-point
1042,"In a single operation, read `i` and lock it to prevent access until further notice"
1043,Compute (1+read_value)
1044,"In a single operation, unlock `i` and store the computed value"
1045,i
1046,i++
1047,i
1048,i
1049,p
1050,q
1051,(*p)
1052,(*q)
1053,i
1054,p
1055,q
1056,a = a++
1057,a++ + a++
1058,i = ++i + 1;
1059,a[i++] = i;
1060,i = i + 1;
1061,a[i] = i;
1062,-Wall
1063,-Werror
1064,% gcc plusplus.c -Wall -Werror -pedantic
1065,plusplus.c: In function ‘main’:
1066,plusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]
1067,    i = i++ + ++i;
1068,    ~~^~~~~~~~~~~
1069,plusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]
1070,plusplus.c:10:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]
1071,    i = (i++);
1072,    ~~^~~~~~~
1073,plusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]
1074,    u = u++ + ++u;
1075,    ~~^~~~~~~~~~~
1076,plusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]
1077,plusplus.c:18:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]
1078,    u = (u++);
1079,    ~~^~~~~~~
1080,plusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point]
1081,    v = v++ + ++v;
1082,    ~~^~~~~~~~~~~
1083,plusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point]
1084,cc1: all warnings being treated as errors
1085,"j = (i ++, ++ i);"
1086,i
1087,i
1088,j = (i += 2)
1089,i += 2;
1090,j = i;
1091,","
1092,int i = 0;
1093,"printf(""%d %d\n"", i++, ++i, i);"
1094,i++
1095,++i
1096,i
1097,i++
1098,++i
1099,i = i++;
1100,i = i++ + ++i;
1101,while(*src++ = *dst++);
1102,"int k[] = {0,1,2,3,4,5,6,7,8,9,10};"
1103,int i = 0;
1104,int num;
1105,num = k[++i+k[++i]] + k[++i];
1106,"printf(""%d"", num);"
1107,++i
1108,++i
1109,k[]
1110,++i
1111,k[]
1112,num = k[i+1]+k[i+2] + k[i+3];
1113,i += 3
1114,++
1115,++
1116,--
1117,++x
1118,x++
1119,int x = 5;
1120,"printf(""%d %d %d\n"", x, ++x, x++);"
1121,++
1122,int x = 5;
1123,x = x++ + ++x;
1124,"printf(""%d\n"", x);"
1125,++
1126,--
1127,"printf(""%d %d %d\n"", x, ++x, x++);"
1128,printf
1129,x
1130,x++
1131,++x
1132,x
1133,++x
1134,x++
1135,x++
1136,++x
1137,x
1138,x = x++ + ++x;
1139,x
1140,x++
1141,x
1142,x
1143,++x
1144,x
1145,x
1146,x =
1147,x
1148,x
1149,x
1150,y = x++;
1151,z = x++ + y++;
1152,x = x + 1;
1153,x = a[i++];
1154,x = a[i++] + b[j++];
1155,x[i++] = a[j++] + b[k++];
1156,x = *p++;
1157,x = *p++ + *q++;
1158,x = x++;
1159,x = x++ + ++x;
1160,y = x + x++;
1161,a[i] = i++;
1162,a[i++] = i;
1163,"printf(""%d %d %d\n"", x, ++x, x++);"
1164,x = x++ + ++x;
1165,x
1166,y = x + x++;
1167,x
1168,"printf(""%d %d %d\n"", x, ++x, x++);"
1169,printf
1170,"printf(""%d "", x);"
1171,"printf(""%d "", ++x);"
1172,"printf(""%d\n"", x++);"
1173,x = x++ + ++x
1174,x = x++ + ++x
1175,i=i++
1176,i=
1177,i++
1178,i=i++
1179,expression-statement
1180,i=i++
1181,tmp = i
1182,i=i+1
1183,i = tmp
1184,tmp = i
1185,i = tmp
1186,i=i+1
1187,i=i++
1188,i=i++
1189, #include<stdio.h>
1190," int main(int argc, char ** argv)"
1191, {
1192,    int i = 0;
1193,    i = i++ + ++i;
1194,"    printf(""%d\n"", i); // 2"
1195,
1196,    i = 1;
1197,    i = (i++);
1198,"    printf(""%d\n"", i); //1"
1199,
1200,    volatile int u = 0;
1201,    u = u++ + ++u;
1202,"    printf(""%d\n"", u); // 2"
1203,
1204,    u = 1;
1205,    u = (u++);
1206,"    printf(""%d\n"", u); //1"
1207,
1208,    register int v = 0;
1209,    v = v++ + ++v;
1210,"    printf(""%d\n"", v); //2"
1211, }
1212,#include<stdio.h>
1213,"int main(int argc, char ** argv)"
1214,{
1215,    int i = 0;
1216,    //i = i++ + ++i;
1217,    int r;
1218,    r=i;
1219,    i++;
1220,    ++i;
1221,    r+=i;
1222,    i=r;
1223,"    printf(""%d\n"", i); // 2"
1224,
1225,    i = 1;
1226,    //i = (i++);
1227,    r=i;
1228,    i++;
1229,    i=r;
1230,"    printf(""%d\n"", i); // 1"
1231,
1232,    volatile int u = 0;
1233,    //u = u++ + ++u;
1234,    r=u;
1235,    u++;
1236,    ++u;
1237,    r+=u;
1238,    u=r;
1239,"    printf(""%d\n"", u); // 2"
1240,
1241,    u = 1;
1242,    //u = (u++);
1243,    r=u;
1244,    u++;
1245,    u=r;
1246,"    printf(""%d\n"", u); // 1"
1247,
1248,    register int v = 0;
1249,    //v = v++ + ++v;
1250,    r=v;
1251,    v++;
1252,    ++v;
1253,    r+=v;
1254,    v=r;
1255,"    printf(""%d\n"", v); //2"
1256,}
1257,#include<stdio.h>
1258,"int main(int argc, char ** argv)"
1259,{
1260,    int i = 0;
1261,    i = i++ + ++i;
1262,"    printf(""%d\n"", i); // 3"
1263,
1264,    i = 1;
1265,    i = (i++);
1266,"    printf(""%d\n"", i); // 2 "
1267,
1268,    volatile int u = 0;
1269,    u = u++ + ++u;
1270,"    printf(""%d\n"", u); // 3"
1271,
1272,    u = 1;
1273,    u = (u++);
1274,"    printf(""%d\n"", u); // 2 "
1275,
1276,    register int v = 0;
1277,    v = v++ + ++v;
1278,"    printf(""%d\n"", v); // 3 "
1279,}
1280,#include<stdio.h>
1281,"int main(int argc, char ** argv)"
1282,{
1283,    int r;
1284,    int i = 0;
1285,    //i = i++ + ++i;
1286,    ++i;
1287,    r = i + i;
1288,    i = r;
1289,    i++;
1290,"    printf(""%d\n"", i); // 3"
1291,
1292,    i = 1;
1293,    //i = (i++);
1294,    r = i;
1295,    i = r;
1296,    i++;
1297,"    printf(""%d\n"", i); // 2 "
1298,
1299,    volatile int u = 0;
1300,    //u = u++ + ++u;
1301,    ++u;
1302,    r = u + u;
1303,    u = r;
1304,    u++;
1305,"    printf(""%d\n"", u); // 3"
1306,
1307,    u = 1;
1308,    //u = (u++);
1309,    r = u;
1310,    u = r;
1311,    u++;
1312,"    printf(""%d\n"", u); // 2 "
1313,
1314,    register int v = 0;
1315,    //v = v++ + ++v;
1316,    ++v;
1317,    r = v + v;
1318,    v = r;
1319,    v++;
1320,"    printf(""%d\n"", v); // 3 "
1321,}
1322,char buf[20];
1323,{
1324,//we are in the child
1325,    close(fp[1]);
1326,    int fd;
1327,"    read(fp[0],buf,20);"
1328,"    if((fd=(open(buf, O_RDONLY)))==-1) exit(1);"
1329,    else exit(0);
1330,    close(fp[0]);
1331,}
1332,#include <stdlib.h>
1333,#include <unistd.h>
1334,#include <stdio.h>
1335,#include <sys/syscall.h>
1336,#include <sys/types.h>
1337,#include <sys/wait.h>
1338,#include <fcntl.h>
1339, 
1340, 
1341,int main(){
1342,    int fp[2];
1343, 
1344,    if (pipe(fp) < 0){
1345,"        printf(""error creating pipe\n"");"
1346,        exit(-1);
1347,    }
1348, 
1349,    int id;
1350,    char buf[20];
1351, 
1352,    id=fork();
1353, 
1354,    //father process here --------------------------------
1355, 
1356,    if (id!=0){
1357,        close(fp[0]);   //closing read
1358, 
1359,"        printf(""program name: "");"
1360,        fflush(stdout);
1361,"        read(STDIN_FILENO,buf,20);"
1362,"        write(fp[1],buf,20);"
1363, 
1364,"        int waitstatus, exitcode;"
1365, 
1366,        wait(&waitstatus);
1367, 
1368,        //check if exited correctly
1369,        if (WIFEXITED(waitstatus))
1370,            exitcode = WEXITSTATUS(waitstatus);
1371,        else
1372,        {
1373,"            printf(""Bad exit\n"");"
1374,            return 0;
1375,        }
1376,"        if (exitcode==1) printf(""error, file doesn't exist\n"");"
1377,"        else printf(""file does exist\n"");"
1378, 
1379,        close(fp[1]);
1380,    }
1381, 
1382, 
1383, 
1384, 
1385,    //child process here --------------------
1386,    else{
1387,        close(fp[1]); //closing write
1388,        int fd;
1389,"        read(fp[0],buf,20);"
1390,"        //write(STDOUT_FILENO, buf, 20);"
1391,"        if((fd=(open(buf, O_RDONLY)))==-1) exit(1);"
1392,        exit(0);
1393,        close(fp[0]);
1394,    }
1395,}
1396,20
1397,buf
1398,"printf(""program name: "");"
1399,fflush(stdout);
1400,"if(fgets(buf, sizeof buf, stdin)==NULL) return 1;"
1401,size_t len = strlen(buf);
1402,buf[len - 1] = '\0';      // remove the newline
1403,"write(fp[1], buf, len);   // only send what you actually need"
1404,uint16_t
1405,uint16_t
1406,f
1407,x*x
1408,x=45000
1409,INT32_MAX
1410,x
1411,int
1412,int32_t
1413,#include <stdio.h>
1414,#include <stdint.h>
1415,
1416,uint16_t f(uint16_t x) {
1417,"    printf(""%zu\n"", sizeof(x));     // <-- 2"
1418,"    printf(""%zu\n"", sizeof(x * x)); // <-- 4"
1419,    return x * x * x;
1420,}
1421,
1422,int main()
1423,{
1424,    uint16_t x = 45000;
1425,    uint16_t y = f(x);
1426,}
1427,x*x
1428,x=45000
1429,INT32_MAX
1430,x
1431,sizeof
1432,size_t
1433,printf
1434,size_t
1435,%zu
1436,sizeof( x * x )
1437,sizeof
1438,sizeof
1439,x * x
1440,int
1441,int
1442,int
1443,uint16_t
1444,int
1445,int
1446,uint16_t
1447,unsigned int
1448,int
1449,int
1450,   __asm__(
1451,"    ""mov %%rsp, 0(%%rcx);""      // save stack"
1452,"    ""mov %%rcx, %%rsp;""         // switch stack"
1453,"    ""callq %%rax;""              // run coroutine"
1454,"    ""pop %%rsp;""                // recovery rsp"
1455,"    ""callq %%rbx;""              // coroutine_exit()"
1456,"    """"::""a""(ready_coroutine->fun), ""c""(ready_coroutine->esp3 - 8), ""d""(current_coroutine), ""b""(coroutine_exit):""memory"""
1457,);
1458,#include <stdio.h>
1459,#include <dirent.h>
1460, 
1461,
1462,void listFiles(const char* dirname)
1463,{
1464,    DIR* dir = opendir(dirname);
1465,    if(dir == NULL)
1466,    {
1467,        return ;  
1468,    }
1469,    struct dirent* entity ;
1470,    entity = readdir(dir);
1471,     
1472,     while(entity != NULL)
1473,    {   
1474,"        printf(""%s\n"", entity->d_name);"
1475,        entity = readdir(dir);
1476,
1477,    }
1478,    
1479,    closedir(dir);
1480,    
1481,    return;
1482,}   
1483,
1484,int main()
1485,{
1486,"    listFiles(""."");"
1487,
1488,return 0;
1489,}
1490,void
1491,"struct dirent *listFiles(const char* dirname, size_t *size)"
1492,{
1493,"    struct dirent *entity, *result = NULL;"
1494,    DIR* dir = NULL;
1495,
1496,    if(size) 
1497,    {
1498,        dir = opendir(dirname);
1499,        *size = 0;
1500,    }
1501,    if(dir)
1502,    { 
1503,        while((entity = readdir(dir)))
1504,        {   
1505,            struct dirent *tmp;
1506,"            tmp = realloc(result, sizeof(*result) * (*size + 1));"
1507,            if(!tmp) {/* error handling */ }
1508,            else
1509,            {
1510,                result = tmp;
1511,"                memcpy(result + *size, entity, sizeof(*result));"
1512,                *size += 1;
1513,            }
1514,        }
1515,        closedir(dir);
1516,    }
1517,    return result;
1518,}   
1519,
1520,int main(void)
1521,{
1522,    size_t size;
1523,"    struct dirent *dir = listFiles(""."", &size);"
1524,    if(size && dir)
1525,    {
1526,        for(size_t x = 0; x < size; x++)
1527,        {
1528,"             printf(""%s\n"", dir[x].d_name);"
1529,        }
1530,    }
1531,    free(dir);
1532,}
1533,memcpy
1534,result[*size] = *entity;
1535,int main(void)
1536,{
1537,"    int totalHeight=0, floorWidth=0, amountOfStories, amountWindowForTop, amountWindowForMiddle, amountWindowForBottom, windowHeight, middleWindowWidth, topWindowWidth, bottomWindowWidth, minimumHeight, minimumWidth;"
1538,
1539,"    char topFloorWindowContent, middleFloorWindowContent, bottomFloorWindowContent, windowBorder, floorBorder;"
1540,
1541,    int tempMax;
1542,
1543,"    printf(""please enter how many stories your building would like to have: "");"
1544,"    scanf(""%d"",&amountOfStories);"
1545,    minimumHeight=amountOfStories*6+1;
1546,    while((totalHeight<minimumHeight)||((totalHeight%amountOfStories)!=1))
1547,    {
1548,"        printf(""please enter the totalHeight (minimum %d): "",minimumHeight);"
1549,"        scanf(""%d"",&totalHeight);"
1550,    }
1551,"    printf(""please enter how many window building would have for top floor: "");"
1552,"    scanf(""%d"",amountWindowForTop);"
1553,"    printf(""please enter how many window building would have for middle floors: "");"
1554,please enter how many stories your building would like to have: 5
1555,please enter the totalHeight (minimum 31): 31
1556,please enter how many window building would have for top floor: 2
1557,Segmentation fault
1558,"scanf(""%d"",amountWindowForTop);"
1559,"scanf(""%d"",&amountWindowForTop);"
1560,&
1561,"scanf(""%d"",amountWindowForTop);"
1562,"scanf(""%d"", &amountWindowForTop);"
1563,//---------^
1564,&
1565," scanf(""%d"", amountWindowForTop);  "
1566,            ^Place & operator 
1567,&
1568,"scanf(""%d"",&amountWindowForTop);"
1569,           ^
1570,-------------- Build: Debug in teste (compiler: GNU GCC Compiler)---------------
1571,
1572,gcc.exe -LC:\Users\tiago\Documents\raylib -o bin\Debug\teste.exe obj\Debug\main.o   C:\Users\tiago\Documents\raylib\libraylib.a
1573,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rcore.o):rcore.c:(.text+0x16ba2): undefined reference to `timeEndPeriod@4'
1574,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rcore.o):rcore.c:(.text+0x1c8cb): undefined reference to `timeBeginPeriod@4'
1575,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x18e3): undefined reference to `_imp__CreateRectRgn@16'
1576,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x1927): undefined reference to `_imp__DeleteObject@4'
1577,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x198c): undefined reference to `_imp__SwapBuffers@4'
1578,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x245d): undefined reference to `_imp__GetDeviceCaps@8'
1579,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x2b3a): undefined reference to `_imp__CreateDCW@16'
1580,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x2b50): undefined reference to `_imp__GetDeviceGammaRamp@8'
1581,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x2b5c): undefined reference to `_imp__DeleteDC@4'
1582,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x65b6): undefined reference to `_imp__CreateDCW@16'
1583,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x65ef): undefined reference to `_imp__GetDeviceCaps@8'
1584,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x661d): undefined reference to `_imp__DeleteDC@4'
1585,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x67ba): undefined reference to `_imp__GetDeviceCaps@8'
1586,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x6a5f): undefined reference to `_imp__CreateDIBSection@24'
1587,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x6aaa): undefined reference to `_imp__CreateBitmap@20'
1588,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x6b44): undefined reference to `_imp__DeleteObject@4'
1589,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x6b97): undefined reference to `_imp__DeleteObject@4'
1590,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x8574): undefined reference to `_imp__CreateDCW@16'
1591,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x8586): undefined reference to `_imp__SetDeviceGammaRamp@8'
1592,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0x8592): undefined reference to `_imp__DeleteDC@4'
1593,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xe947): undefined reference to `_imp__ChoosePixelFormat@8'
1594,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xe95b): undefined reference to `_imp__SetPixelFormat@12'
1595,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xedf2): undefined reference to `_imp__DescribePixelFormat@16'
1596,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xeee5): undefined reference to `_imp__DescribePixelFormat@16'
1597,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xf2ff): undefined reference to `_imp__DescribePixelFormat@16'
1598,C:\MinGW\bin/ld.exe: C:\Users\tiago\Documents\raylib\libraylib.a(rglfw.o):rglfw.c:(.text+0xf32a): undefined reference to `_imp__SetPixelFormat@12'
1599,collect2.exe: error: ld returned 1 exit status
1600,"Process terminated with status 1 (0 minute(s), 0 second(s))"
1601,"27 error(s), 0 warning(s) (0 minute(s), 0 second(s))"
1602,static spinlock rngLock;
1603,static volatile uint32_t entropy;
1604,
1605,#define reseed()                      \
1606,    {                                 \
1607,        entropy ^= OSGetSystemTick(); \
1608,        entropy ^= OSGetTick();       \
1609,    }
1610,
1611,"// Based on George Marsaglias paper ""Xorshift RNGs"" from https://www.jstatsoft.org/article/view/v008i14"
1612,#define rngRun()                      \
1613,    {                                 \
1614,        if(entropy)                   \
1615,        {                             \
1616,            entropy ^= entropy << 13; \
1617,            entropy ^= entropy >> 17; \
1618,            entropy ^= entropy << 5;  \
1619,        }                             \
1620,        else                          \
1621,            reseed();                 \
1622,    }
1623,
1624,"int osslBytes(unsigned char *buf, int num)"
1625,{
1626,    --buf;
1627,    ++num;
1628,
1629,    spinLock(rngLock);
1630,
1631,    while(--num)
1632,    {
1633,        rngRun();
1634,        *++buf = entropy;
1635,    }
1636,
1637,    spinReleaseLock(rngLock);
1638,
1639,    return 1;
1640,}
1641,
1642,static void osslCleanup()
1643,{
1644,    // STUB
1645,}
1646,
1647,static int osslStatus()
1648,{
1649,    return 1;
1650,}
1651,
1652,static const RAND_METHOD srm = {
1653,"    .seed = NULL,"
1654,"    .bytes = osslBytes,"
1655,"    .cleanup = osslCleanup,"
1656,"    .add = NULL,"
1657,"    .pseudorand = osslBytes,"
1658,"    .status = osslStatus,"
1659,};
1660,
1661,"void addEntropy(void *e, size_t l)"
1662,{
1663,    uint8_t *buf8 = (uint8_t *)e;
1664,    uint32_t *buf32;
1665,    size_t l32 = l >> 2;
1666,    if(l32)
1667,    {
1668,        buf32 = (uint32_t *)e;
1669,        --buf32;
1670,        buf8 += l32 << 2;
1671,        l %= 4;
1672,    }
1673,
1674,    ++l;
1675,    ++l32;
1676,    --buf8;
1677,
1678,    spinLock(rngLock);
1679,
1680,    while(--l32)
1681,    {
1682,        rngRun();
1683,        entropy ^= *++buf32;
1684,    }
1685,
1686,    while(--l)
1687,    {
1688,        rngRun();
1689,        entropy ^= *++buf8;
1690,    }
1691,
1692,    spinReleaseLock(rngLock);
1693,}
1694,
1695,bool initCrypto()
1696,{
1697,    reseed();
1698,"    spinCreateLock(rngLock, SPINLOCK_FREE);"
1699,"    return OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS, NULL) == 1 && RAND_set_rand_method(&srm) == 1;"
1700,}
1701,void *thread_routine(void *arg)
1702,{
1703,    // this thread should wait here till rest of all threads are also ready to run
1704,
1705,    // do some job here
1706,
1707,    return NULL;
1708,}
1709,
1710,"int main(int argc, char *argv[])"
1711,{
1712,    int i = 0;
1713,    pthread_t thid[4];
1714,
1715,    for (i = 0; i < 4; i++) {
1716,"        pthread_create(&tid[i], NULL, thread_routine, NULL);"
1717,    }
1718,
1719,    for (i = 0; i < 4; i++) {
1720,"       pthread_join(tid[i], NULL);"
1721,    }
1722,    return 0;
1723,}
1724,#include <stdio.h>
1725,
1726,int main()
1727,{
1728,    int a = 0;
1729,    int b = 1;
1730,    int *p = &b;
1731,"    //printf(""%p\n"", &a);"
1732,"    printf(""%d\n"", *(p+1));"
1733,    
1734,    return 0;
1735,}
1736,*(p+1)
1737,a
1738,printf()
1739,#include<stdio.h>
1740,
1741,"    char *addStrings(char * num1, char * num2){"
1742,    int intresult= (int)(num1-'0')+(int)(num2-'0');
1743,    char *result=intresult+'0';
1744,    return result;
1745,}
1746,int main(){
1747,"    char *num1=""70"";"
1748,"    char *num2=""80"";"
1749,"    char *result=addStrings(num1,num2);"
1750,"    printf(""%c\n"",result);"
1751,"    printf(""%s\n"",result);"
1752,
1753,    return 0;
1754,}
1755,*num1-'0'+*num2-'0'
1756,"""123456789012345678901234567890 9988776655443322110099887766"""
1757,"char *addStrings(char * num1, char * num2){"
1758,int intresult= (int)(num1-'0')+(int)(num2-'0');
1759,char *result=intresult+'0';
1760,return result;
1761,(int)(num1-'0')+(int)(num2-'0')
1762,num1-'0'
1763,num2-'0'
1764,char *
1765,char *result=intresult+'0';
1766,result
1767,#include <stdio.h>
1768,#include <stdlib.h>
1769,#include <string.h>
1770,
1771,"char * addStrings( const char *s1, const char *s2 )"
1772,{
1773,    const unsigned int Base = 10;
1774,
1775,    size_t n1 = strlen( s1 );
1776,    size_t n2 = strlen( s2 );
1777,
1778,    size_t n = n2 < n1 ? n2 : n1;
1779,
1780,    unsigned int carry = 0;
1781,
1782,    for ( size_t i = 0; i < n; i++ )
1783,    {
1784,        carry = !( ( s1[n1-i-1] - '0' ) + ( s2[n2-i-1] - '0' )  < Base );
1785,    }
1786,
1787,    for ( size_t i = 0; carry && i < n1 - n; i++ )
1788,    {
1789,        carry = !( s1[n1-n-i-1] - '0' + carry < Base );
1790,    }
1791,
1792,    for ( size_t i = 0; carry && i < n2 - n; i++ )
1793,    {
1794,        carry = !( s2[n2-n-i-1] - '0' + carry < Base );
1795,    }
1796,
1797,    size_t n3 = ( n1 < n2 ? n2 : n1 ) + carry;
1798,    char *result = malloc( n3 + 1 );
1799,
1800,    if ( result != NULL )
1801,    {
1802,        result[n3] = '\0';
1803,        
1804,        carry = 0;
1805,
1806,        for ( size_t i = 0; i < n; i++ )
1807,        {
1808,            unsigned int sum = ( s1[n1-i-1] - '0' ) + ( s2[n2-i-1] - '0' ) + carry;
1809,            result[n3-i-1] = sum % Base + '0'; 
1810,            carry = !( sum  < Base );
1811,        }
1812,
1813,        for ( size_t i = 0; i < n1 - n; i++ )
1814,        {
1815,            unsigned int sum = s1[n1-n-i-1] - '0' + carry;
1816,            result[n3-n-i-1] = sum % Base + '0'; 
1817,            carry = !( sum  < Base );
1818,        }
1819,
1820,        for ( size_t i = 0; i < n2 - n; i++ )
1821,        {
1822,            unsigned int sum = s2[n2-n-i-1] - '0' + carry;
1823,            result[n3-n-i-1] = sum % Base + '0'; 
1824,            carry = !( sum  < Base );
1825,        }
1826,
1827,        if( carry ) result[0] = '1';
1828,    }
1829,
1830,    return result;
1831,}
1832,
1833,int main( void ) 
1834,{
1835,"    char *sum = addStrings( ""1"", ""99999999999999999999"" ); "
1836,    if ( sum ) puts( sum );
1837,    free( sum );
1838,
1839,"    sum = addStrings( ""99999999999999999999"", ""2"" ); "
1840,    if ( sum ) puts( sum );
1841,    free( sum );
1842,
1843,"    sum = addStrings( ""1"", ""2"" ); "
1844,    if ( sum ) puts( sum );
1845,    free( sum );
1846,}
1847,100000000000000000000
1848,100000000000000000001
1849,3
1850,           //LIBRARIES
1851,       #include <stdio.h>
1852,       #include <stdlib.h>
1853,
1854,      #define Size_MainFuncArray 5   // Constant
1855,
1856,                              // Data that needs to be inside the StudentData txt file:
1857,                                                 // Jane 55 51 78
1858,      struct Student {                        // Lungelo 69 84 75
1859,         char StudentName[10];                   // Greg 51 44 52
1860,         int StudentMarks[3];                  // Thando 23 78 61
1861,         float StudentAverage;                   // Bret 44 33 29   //  How do I calculate the 
1862,                                                                   //average of them?
1863,        };
1864,
1865,        typedef struct Student Student;
1866,
1867,    //Function Prototypes
1868,      int DisplayMenu (void);
1869,"      void Read_Data (Student Arr[], int Size);"
1870,"      void Calculate_StudentAverage (Student Arr[], int Size);"
1871,"      void Display_Data (Student Arr[], int Size);"
1872,"      void Write_Graph (Student Arr[], int Size);"
1873,
1874,
1875,   // Main Function
1876,   int main (void)
1877,    {
1878,       int choice = 0;
1879,       Student ESG206B[Size_MainFuncArray];
1880,
1881,         while( choice != 4 )
1882,
1883,         choice = DisplayMenu();
1884,"         scanf( ""%d"", &choice );"
1885,
1886,         switch( choice ) {
1887,               case 1:
1888,"                   Read_Data( ESG206B, Size_MainFuncArray );"
1889,"                   Calculate_StudentAverage( ESG206B, Size_MainFuncArray );"
1890,                   getch();
1891,"                   printf(""Data successfully loaded from StudentData.txt"");"
1892,"                   printf(""\nPress any key to continue...\n"");"
1893,                   break;
1894,
1895,               case 2:
1896,"                   Display_Data( ESG206B, Size_MainFuncArray );"
1897,                   break;
1898,
1899,               case 3:
1900,"                   Write_Graph( ESG206B, Size_MainFuncArray );"
1901,                   break;
1902,
1903,               case 4:
1904,"                   printf( ""Bye-bye\n"" );"
1905,                   break;
1906,
1907,              default:
1908,"                   printf( ""Invalid selection\n"" );"
1909,                   break;
1910,            }
1911,
1912,        return 0;
1913,    }
1914,
1915,    // Function Definitions
1916,    int DisplayMenu (void)
1917,    {
1918,       int Select;
1919,
1920,"         printf(""************************************\n"");"
1921,"         printf(""*    Welcome to Student Stats      *\n"");"
1922,"         printf(""*    Student Number: 222895812     *\n"");"
1923,"         printf(""************************************\n"");"
1924,
1925,            putchar( '\n' );
1926,"            printf(""1. Load Data and Calculate Average\n"");"
1927,"            printf(""2. Dispaly Student Data\n"");"
1928,"            printf(""3. Save Graph\n"");"
1929,"            printf(""4. Exit\n"");"
1930,"            printf(""Choice: "");"
1931,            fflush(stdin);
1932,"            scanf(""%d"", &Select);"
1933,
1934,"            printf(""\nPress any key to continue...\n"");"
1935,            getch();
1936,"            system(""cls"");"
1937,
1938,         return Select;
1939,    }
1940,"    void Read_Data (Student Arr[], int Size)"
1941,    {
1942,
1943,         FILE *cfPtr;
1944,"         if ((cfPtr = fopen(""StudentData.txt"",""r"")) == NULL)"
1945,"             printf(""Data successfully loaded from StudentData.txt"");"
1946,        else
1947,        {
1948,             while (!feof(cfPtr))
1949,            {
1950,"             fscanf(cfPtr,""%s\n"", Size);"
1951,"             printf(""Student Name: %s"", Size);"
1952,            }
1953,         }
1954,    }
1955,"    void Calculate_StudentAverage (Student Arr[], int Size)"
1956,    {
1957,
1958,    }
1959,"    void Display_Data (Student Arr[], int Size)"
1960,    {
1961,
1962,    }
1963,"    void Write_Graph (Student Arr[], int Size)"
1964,    {
1965,
1966,    }
1967,       1. Libraries
1968,       2. Constant variable (#define Size_MainFuncArray 10) 
1969,       3. Structure and Typedef
1970,       4. Function prototypes (1-5) 
1971,       5. Main function 
1972,       a. Variables (Declare all variables needed in the main function at the start 
1973,          of the main function) 
1974,
1975,       b. While and Switch
1976,       c. Return 0 (the end of the main function) 
1977,       6. Function definitions 
1978,        a. DisplayMenu
1979,
1980,        b. Read_Data: 
1981,"  By using a file pointer, read the contents of the text file, “StudentData.txt”. "
1982,"  By using an if-statement, make sure the file opened correctly. Use a whilestatement "
1983,  and 
1984,  the feof-function to read the contents of the text file and
1985,  populate the structure array. Use the Size parameter to make your code 
1986,  modular and reusable. No command prompt input or output functions may 
1987,
1988,        c. Calculate_StudentAverage
1989,  Use a counter-controlled for loop to calculate the student mark average. 
1990,  The average is calculated by determining the sum of the structure member 
1991,"  variable array called, “StudentMarks” and dividing it with 3. No command "
1992,  prompt input or output functions may be used in this function.
1993,
1994,        d. Display_Data:
1995,  Use a counter-controlled for loop to display the contents of the structure 
1996,  array parameter. Use appropriate command prompt output to display the 
1997,  needed data.
1998,
1999,        e. Write_Grap:
2000,         StudentAverage = 55.6
2001,              NumberOfStarts =                RoundDown(StudentAverage/10)
2002,              = RoundDown(55.6/10)
2003,              = RoundDown(5.56)
2004,              = 5 Stars
2005,-Wall -Wextra -pedantic
2006,"fscanf(cfPtr,""%s\n"", Size);"
2007,Size has wrong type. Also you should not add 
2008,"printf(""Data successfully loaded from StudentData.txt"");"
2009,public static byte[] GetArray(int length)
2010,    {
2011,        byte[] result = new byte[length];
2012,
2013,        for (int i = 0; i < result.Length; i++)
2014,        {
2015,            try
2016,            {
2017,                // result[i] = (byte)(Serial.ReadByte());
2018,"                Serial.Read(result, i, 1);"
2019,            }
2020,            catch (Exception)
2021,            {
2022,                OnTimeOut();
2023,                return result;
2024,            }
2025,        }
2026,        return result;
2027,    }
2028,public static byte[] GetArrayBulk(int length)
2029,    {
2030,        byte[] result = new byte[length];
2031,
2032,        try
2033,        {
2034,"            Serial.Read(result, 0, result.Length);"
2035,        }
2036,        catch (Exception)
2037,        {
2038,            OnTimeOut();
2039,            return result;
2040,        }
2041,
2042,        return result;
2043,    }
2044,"void usb_send_array(uint8_t *src, uint16_t size)"
2045,{
2046,    uint16_t i = 0;
2047,    long current_time = millis();
2048,    while (1)
2049,    {
2050,        if(udi_cdc_is_tx_ready())
2051,        {
2052,            current_time = millis();
2053,            udi_cdc_putc(*(src + i));
2054,            i++;
2055,            if (i > size - 1) break;
2056,        }
2057,        if ((millis() - current_time) > 100) return;
2058,    }
2059,}
2060,serialport
2061,gcc 11
2062,Ubuntu 22.04
2063,c
2064,gcc 8.4.0-3ubuntu2
2065,Ubuntu 22.04
2066,gcc-7
2067,gcc-8
2068,gcc
2069,gcc 11
2070,gcc-7
2071,gcc-8
2072,gcc 11
2073,gcc 7.5
2074,gcc 8.4
2075,gprof
2076,old-fast
2077,gcc-7
2078,new-slow
2079,gcc-8
2080,new-slow
2081,Flat profile
2082,Flat profile:
2083,
2084,Each sample counts as 0.01 seconds.
2085,  %   cumulative   self              self     total           
2086, time   seconds   seconds    calls   s/call   s/call  name    
2087, 39.27      9.83     9.83   173488     0.00     0.00  main_process
2088, 22.89     15.56     5.73                             rte_atomic32_cmpset
2089, ...
2090,static inline int
2091,"rte_atomic32_cmpset(volatile uint32_t *dst, uint32_t exp, uint32_t src)"
2092,{
2093,    uint8_t res;
2094,
2095,    asm volatile(
2096,            MPLOCKED
2097,"            ""cmpxchgl %[src], %[dst];"""
2098,"            ""sete %[res];"""
2099,"            : [res] ""=a"" (res),     /* output */"
2100,"              [dst] ""=m"" (*dst)"
2101,"            : [src] ""r"" (src),      /* input */"
2102,"              ""a"" (exp),"
2103,"              ""m"" (*dst)"
2104,"            : ""memory"");            /* no-clobber list */"
2105,    return res;
2106,} 
2107,gcc
2108,perf
2109,-O0
2110,perf
2111,-pg
2112,gprof
2113,-O0
2114,-O2
2115,-O3
2116,<stdbool.h>
2117,_Bool
2118,#include <stdbool.h>
2119,#include <stdio.h>
2120,
2121,bool b;
2122,int temp;
2123,
2124,"scanf(""%d"", &temp);"
2125,b = temp;
2126,bool
2127,1
2128,0
2129,bool b;
2130,int i;
2131,"printf(""1/0:\n"");"
2132,"scanf(""%d"", &i);"
2133,if (i) {
2134,  b = 1;
2135,} else {
2136,  b = 0;
2137,}
2138,2
2139,1
2140,1
2141,0
2142,#include <stdio.h>
2143,#include <stdbool.h>
2144,#include <string.h>
2145,
2146,int main() {
2147,    bool x;
2148,    int temp;
2149,    char y[5];
2150,
2151,"    printf(""Enter Boolean Input True or False: - \n"");"
2152,"    scanf(""%s"", &y);"
2153,
2154,"    if(strcmp(y, ""True"") == 0){"
2155,        temp = 1;
2156,    }
2157,
2158,"    else if(strcmp(y, ""False"") == 0){"
2159,        temp = 0;
2160,    }
2161,
2162,    x = temp;
2163,
2164,"    printf(""%d"", x);"
2165,
2166,    return 0;
2167,}
2168,if
2169,if
2170,if
2171,temp
2172,x
2173,0.0 == -0.0
2174,if(a)
2175,if(a!=0)
2176,if(-0.0)
2177,false
2178,if(-0.0)
2179,if(a!=0)
2180,if(-0.0)
2181,!=
2182,if()
2183,if
2184,if … else
2185,if (-0.)
2186,"t_camera    camera(t_canvas *canvas, t_scene *sc)"
2187,{
2188,    t_camera    cam;
2189,    double      focal_len;
2190,    double      viewport_height;
2191,
2192,    viewport_height = tan(sc->cam.fov * 13.14 / 180);
2193,    focal_len = 1.0;
2194,    cam.orig = sc->cam.cen;
2195,   cam.viewport_h = viewport_height;
2196,   cam.viewport_w = viewport_height * canvas->aspect_ratio;
2197,   cam.focal_len = focal_len;
2198,"   cam.horizontal = make_vec(cam.viewport_w, 0, 0);"
2199,"   cam.vertical = make_vec(0, cam.viewport_h, 0);"
2200,"   // left corner, origin - horizontal / 2 - vertical / 2 - vec3(0,0,focal_length)"
2201,"   cam.left_bottom = sub_vec(sub_vec(sub_vec(cam.orig, div_vect(cam.horizontal, 2)),"
2202,"                            div_vect(cam.vertical, 2)), make_vec(0, 0, focal_len));"
2203,   return (cam);
2204,}
2205,warning: assignment makes pointer from integer without a cast [-Wint-conversion]
2206,warning: return makes integer from pointer without a cast [-Wint-conversion]
2207,    #include<stdio.h>  
2208,
2209,"    long int jumlah(long int a,long int b, long int * sum){"
2210,        sum = (a+b);
2211,        return (sum);
2212,    }
2213,
2214,    int main(){
2215,"        long int a,b,sum;"
2216,"        scanf(""%d %d"",&a,&b);"
2217,"        sum = jumlah(a,b,&sum);"
2218,"        printf(""%d\n"",sum);"
2219,        return 0;
2220,    }
2221,%d
2222,int
2223,long int
2224,%ld
2225,scanf
2226,printf
2227,sum = (a+b); return (sum);
2228,*sum = a + b; return *sum;
2229,"sum = jumlah(a,b,&sum);"
2230,sum
2231,#include <stdio.h>
2232,
2233,"long int jumlah(long int a, long int b, long int *sum)"
2234,{
2235,    *sum = a+b;
2236,    return *sum;
2237,}
2238,
2239,int main(void)
2240,{
2241,"    long int a, b, sum;"
2242,"    scanf(""%ld %ld"", &a, &b);"
2243,"    sum = jumlah(a, b,&sum);"
2244,"    printf(""%ld\n"", sum);"
2245,    return 0;
2246,}
2247,"long int jumlah(long int a,long int b, long int * sum){"
2248,    sum = (a+b);
2249,    return (sum);
2250,}
2251,sum
2252,long int
2253,long int
2254,(a+b)
2255,long int
2256,sum
2257,*sum = (a+b);
2258,long int
2259,sum
2260,sum
2261,*sum
2262,long int*
2263,sum
2264,*sum
2265,sum
2266,long int
2267,"long int jumlah( long int a, long int b ) {"
2268,    return a + b;
2269,}
2270,
2271,int main(){
2272,"    long int a, b;"
2273,
2274,    // make use of return values from system (input) functions
2275,"    if( scanf( ""%d %d"", &a, &b ) == 2 )"
2276,"        printf( ""%d\n"", jumlah( a, b ) );"
2277,    else
2278,"        printf( ""Input error\n"" );"
2279,
2280,    return 0;
2281,}
2282,"long int jumlah(long int a,long int b){"
2283,long int sum;
2284,
2285,sum = a + b;
2286,return (sum);
2287,"long int jumlah(long int a,long int b, long int * sum){"
2288,*sum = a + b;
2289,return (*sum);
2290,gcc main.c test1.c
2291,main
2292,main.c
2293,test1.c
2294,main
2295,main
2296,main.c
2297,main.c
2298,main.c
2299,test1.c
2300,clang test1.c -o test1
2301,test1
2302,./test1
2303,#ifndef ASPRINTF_H
2304,#define ASPRINTF_H
2305,
2306,#if defined(__GNUC__) && ! defined(_GNU_SOURCE)
2307,"#define _GNU_SOURCE /* needed for (v)asprintf, affects '#include <stdio.h>' */"
2308,#endif
2309,#include <stdio.h>  /* needed for vsnprintf    */
2310,"#include <stdlib.h> /* needed for malloc, free */"
2311,#include <stdarg.h> /* needed for va_*         */
2312,
2313,/*
2314, * vscprintf:
2315," * MSVC implements this as _vscprintf, thus we just 'symlink' it here"
2316," * GNU-C-compatible compilers do not implement this, thus we implement it here"
2317, */
2318,#ifdef _MSC_VER
2319,#define vscprintf _vscprintf
2320,#endif
2321,
2322,#ifdef __GNUC__
2323,"int vscprintf(const char *format, va_list ap)"
2324,{
2325,    va_list ap_copy;
2326,"    va_copy(ap_copy, ap);"
2327,"    int retval = vsnprintf(NULL, 0, format, ap_copy);"
2328,    va_end(ap_copy);
2329,    return retval;
2330,}
2331,#endif
2332,
2333,/*
2334," * asprintf, vasprintf:"
2335," * MSVC does not implement these, thus we implement them here"
2336," * GNU-C-compatible compilers implement these with the same names, thus we"
2337, * don't have to do anything
2338, */
2339,#ifdef _MSC_VER
2340,"int vasprintf(char **strp, const char *format, va_list ap)"
2341,{
2342,"    int len = vscprintf(format, ap);"
2343,    if (len == -1)
2344,        return -1;
2345,    char *str = (char*)malloc((size_t) len + 1);
2346,    if (!str)
2347,        return -1;
2348,"    int retval = vsnprintf(str, len + 1, format, ap);"
2349,    if (retval == -1) {
2350,        free(str);
2351,        return -1;
2352,    }
2353,    *strp = str;
2354,    return retval;
2355,}
2356,
2357,"int asprintf(char **strp, const char *format, ...)"
2358,{
2359,    va_list ap;
2360,"    va_start(ap, format);"
2361,"    int retval = vasprintf(strp, format, ap);"
2362,    va_end(ap);
2363,    return retval;
2364,}
2365,#endif
2366,
2367,#endif // ASPRINTF_H
2368,"#include ""asprintf.h"""
2369,
2370,#include <stdio.h>
2371,#include <stdlib.h>
2372,
2373,extern char _binary_script_php_start;
2374,extern char _binary_script_php_end;
2375,
2376,"int main(int argc, char *argv[]) {"
2377,    // EXTRACT OUR RESOURCE OBJECT INTO /tmp/test.php
2378,    char *p = &_binary_script_php_start;
2379,"    FILE *fp = fopen(""/tmp/test.php"",""wb"");"
2380,    while ( p != &_binary_script_php_end ) {
2381,"        fputc(*p++,fp);"
2382,    }
2383,    fclose(fp);
2384,    // NOW READ IN OUR STANDARD ARGUMENTS AND LAUNCH OUR COMMAND
2385,    int i = 1;
2386,"    char *cmd = ""php /tmp/test.php"";"
2387,    char *s = NULL;
2388,"    asprintf(&s, ""%s"",cmd);"
2389,    for(i = 1; i < argc; i++) {
2390,"        asprintf(&s, ""%s \""%s\"""",s,argv[i]);"
2391,    }
2392,"    // concatf(""%s"",cmd);"
2393,    // for(i = 1; i < argc; i++) {
2394,"    //     concatf(""%s \""%s\"""",s,argv[i]);"
2395,    // }
2396,"    // concatf(&s, ""%s"",cmd);"
2397,    // for(i = 1; i < argc; i++) {
2398,"    //     concatf(&s, ""%s \""%s\"""",s,argv[i]);"
2399,    // }
2400,    system(s);
2401,    free(s);
2402,"    unlink(""/tmp/test.php""); // comment me out for debugging if you want"
2403,}
2404,php:
2405,    ld -r -b binary script.php data.o
2406,exe:
2407,    gcc main.c data.o -o runme
2408,asprintf.h
2409,__STDC_WANT_LIB_EXT2__
2410,stdio.h
2411,#define __STDC_WANT_LIB_EXT2__  1
2412,#include <stdio.h>
2413,....
2414,#ifndef _MSC_VER
2415,#define __STDC_WANT_LIB_EXT2__  1
2416,#endif
2417,#include <stdio.h>
2418,....
2419,#include<stdio.h>
2420,#include<unistd.h>
2421,
2422,int main()
2423,{
2424,    int fd1[2];
2425,    pipe(fd1);
2426,
2427,    if(!fork())
2428,    {
2429,"        dup2(fd1[1],1);"
2430,        close(fd1[0]);
2431,"        execlp(""ls"" , ""ls"" ,""-l"",(char*)0);"
2432,    }
2433,    else{
2434,        int fd2[2];
2435,        pipe(fd2);
2436,"        dup2(fd1[0],0);"
2437,        close(fd1[1]);
2438,
2439,        if(!fork()){
2440,"            dup2(fd2[0],0);"
2441,            close(fd2[0]);
2442,"            execlp(""wc"",""wc"",(char*)0);"
2443,        }
2444,        else{
2445,"            dup2(fd2[1],1);"
2446,            close(fd2[0]);
2447,"            execlp(""grep"",""grep"",""^d"",(char*)0);"
2448,        }
2449,    }
2450,    return 0;
2451,}
2452,int main()
2453,{
2454,    int fd1[2];
2455,    pipe(fd1);
2456,
2457,    if(!fork())
2458,    {
2459,"        dup2(fd1[1],1);"
2460,        close(fd1[0]);
2461,"        execlp(""ls"" , ""ls"" ,""-l"",(char*)0);"
2462,    }
2463,    else{
2464,        int fd2[2];
2465,        pipe(fd2);
2466,"        dup2(fd1[0],0);"
2467,        close(fd1[1]);
2468,
2469,        if(!fork()){
2470,"            dup2(fd2[1],1);"
2471,            close(fd2[0]);
2472,"            execlp(""grep"",""grep"",""^d"",(char*)0);"
2473,        }
2474,        else{
2475,"                dup2(fd2[0],0);"
2476,            close(fd2[1]);
2477,"            execlp(""wc"",""wc"",(char*)0);"
2478,        }
2479,    }
2480,    return 0;
2481,}
2482,ls -l | grep ^d
2483,ls d*
2484,wc
2485,fd2[1]
2486,close(fd2[1]);
2487,"execlp(""wc"",""wc"",(char*)0);"
2488,#include <stdio.h>
2489,#include <stdlib.h>
2490,
2491,"int values[] = { 88, 56, 100, 2, 25 };"
2492,
2493,"int cmpfunc (const void * a, const void * b) {"
2494,   return ( *(int*)a - *(int*)b );
2495,}
2496,
2497,int main () {
2498,   int n;
2499,
2500,"   printf(""Before sorting the list is: \n"");"
2501,   for( n = 0 ; n < 5; n++ ) {
2502,"      printf(""%d "", values[n]);"
2503,   }
2504,
2505,"   msort(values, 5, sizeof(int), cmpfunc);"
2506,
2507,"   printf(""\nAfter sorting the list is: \n"");"
2508,   for( n = 0 ; n < 5; n++ ) {   
2509,"      printf(""%d "", values[n]);"
2510,   }
2511,  
2512,   return(0);
2513,}
2514,*(int*)a - *(int*)b
2515,<
2516,>
2517,int A = *(int *) a; int B = *(int *) b; return (a > b) - (a < b);
2518,cmpfunc()
2519,msort()
2520,cmpfunc()
2521,msort()
2522,values[]
2523,msort()
2524,x
2525,y
2526,"cmpfunc(x, y)"
2527,"void msort(void *base, size_t nitems, size_t size, int (*compar)(const void* , const void*)) "
2528,msort
2529,msort
2530,const void*
2531,int
2532,"msort(values, 5, sizeof(int), cmpfunc);"
2533,cmpfunc
2534,cmpfunc
2535,msort
2536,cmpfunc
2537,msort
2538,"int cmpAscending (const void * a, const void * b) {"
2539,    return ( *(int*)a - *(int*)b );
2540,}
2541,"int cmpDescending (const void * a, const void * b) {"
2542,    return ( *(int*)b - *(int*)a );  // NB: subtle difference
2543,}
2544,msort()
2545,if( ascending )
2546,"    msort( values, 5, sizeof(int), cmpAscending );"
2547,else
2548,"    msort( values, 5, sizeof(int), cmpDescending );"
2549,"    msort( values, 5, sizeof(int), ascending ? cmpAscending : cmpDescending );"
2550,#include <stdio.h>
2551,
2552,void bar(int x )
2553,{
2554,"    printf(""%d\n"", x);"
2555,}
2556,
2557,void foo(void(*pbar)(int))
2558,{
2559,    pbar(10);
2560,    pbar(20);
2561,}
2562,
2563,int main(void)
2564,{
2565,   foo(bar);
2566,
2567,   return(0);
2568,}
2569,/*
2570,    How to compile ->
2571,    (1) make all
2572,        if no make was provided then gcc server.c utilityFunctionsMHZ.h -o server
2573,    (2) ./server FILENAME PORT_NUMBER SLEEP_TIMER MAX_BUFFER_SIZE
2574,        Example: ./server mainFile2.log 5500 10 4096
2575,    (3) ./client FILENAME SERVER_ADDR PORT_NUMBER 
2576,        Example: ./client mainFile.log 172.17.34.89 5500
2577,*/  
2578,
2579,"#include ""utilityFunctionsMHZ.h"""
2580,
2581,"int main (int argc, char* argv[])"
2582,{
2583,    // Initial Error Check And Call Initializer
2584,    if (argc < 4) 
2585,    {   
2586,"        fprintfSwitchable(NULL, 0, ""[+client] Please use the given format: ./client FILENAME SERVER_ADDR PORT_NUMBER\n"");"
2587,        exit(0);
2588,    }
2589,"    else if (!isFileAvailable(argv[1], ""client"", NULL))"
2590,    {
2591,        exit(0);
2592,    }
2593,    else
2594,    {
2595,"        Initializer (""client"", NULL);"
2596,"        fprintfSwitchable(NULL, 0, ""[+%s] Make Sure to Run server First.\n"", ""client"");"
2597,    }
2598,        
2599,    // Input Parameters  
2600,    const char* fileLocFull = argv[1];
2601,    char* serverIP          = argv[2];
2602,    int portNumber          = atoi(argv[3]);
2603,
2604,    // Buffer & Cache Properties and Size 
2605,    struct bufferTCP* mssg = CreateBufferTCP();
2606,"    size_t MAX_CACHE_SIZE, CACHE_SIZE;"
2607,    char* cacheBuffer;
2608,
2609,"    // File Process, Data Structure (NACK-Sender & ACK-Reciever)"
2610,    FILE* filePtr_NACK;
2611,    size_t fileMemory_NACK = 0;
2612,    size_t fileMemory_ACK = 0;
2613,    size_t fileRemainMemory = 0;
2614,
2615,    // Create Socket via TCP Protocol & Error Check
2616,"    int sockfd = socket(AF_INET, SOCK_STREAM, 0);"
2617,    if (sockfd == -1)
2618,"        fprintfSwitchable(NULL, 1, ""[-client] Error in Socket Initiation!\n"");"
2619,    else
2620,"        fprintfSwitchable(NULL, 0, ""[+client] Socket Successfully Initiated.\n"");"
2621,    // Socket main Structures
2622,    struct sockaddr_in* serverAddr = malloc(sizeof(struct sockaddr_in));
2623,    
2624,    // Socket Structures Memory Allocation Test
2625,    if (serverAddr == NULL) 
2626,"        fprintfSwitchable(NULL, 1, ""[-client] Memory Allocation for sockadd_in strctures Failed!\n"");"
2627,    else
2628,"        fprintfSwitchable(NULL, 0, ""[+client] Memory Allocation for sockadd_in strctures Successfully Completed.\n"");"
2629,    
2630,    // Set-up server parameters
2631,"    bzero(serverAddr, sizeof(struct sockaddr_in));   //memset(serverAddr, 0x00, sizeof(struct sockaddr_in));"
2632,    serverAddr->sin_family      = AF_INET;
2633,    //serverAddr->sin_addr.s_addr = inet_addr(serverIP);
2634,"    inet_pton(AF_INET, serverIP, &(serverAddr->sin_addr));"
2635,    serverAddr->sin_port        = htons(portNumber);
2636,
2637,    // Connection Request to Server
2638,"    if (connect(sockfd, (struct sockaddr*) serverAddr, sizeof(struct sockaddr_in)) == -1)"
2639,"        fprintfSwitchable(NULL, 1, ""[-client] Error in Connecting to Server!\n"");"
2640,    else
2641,"        fprintfSwitchable(NULL, 0, ""[+client] Connection Successfully Accepted.\n"");"
2642,
2643,"    if (read(sockfd, &MAX_CACHE_SIZE, sizeof(size_t)) == -1)"
2644,"        fprintfSwitchable(NULL, 1, ""[-client] Error in MAX CACHE Size Negitiation!\n""); "
2645,    else 
2646,"        fprintfSwitchable(NULL, 0, ""[+client] CACHE Size is Set Equal to Server: %lu.\n"", MAX_CACHE_SIZE);"
2647,    
2648,    // Initializing Sender Sleep Clock
2649,    size_t sleepTimer;
2650,"    if (read(sockfd, &sleepTimer, sizeof(size_t)) == -1)"
2651,"        fprintfSwitchable(NULL, 1, ""[-client] Error in Sleep Timer Negitiation!\n"", 1, 1); "
2652,    else 
2653,"        fprintfSwitchable(NULL, 0, ""[+client] Sleep Timer is Set Equal to Server: %lu\n"", sleepTimer); "
2654,    
2655,    int iack;
2656,    int ACKFLAG = 0;
2657,    size_t OveralIteration = 0;
2658,    size_t SentBytes;
2659,    size_t Not_Written = 0;
2660,    ssize_t readFLAG;
2661,    ssize_t writeFLAG;
2662,    size_t InnerIteration = 0;
2663,
2664,"    fprintfSwitchable(NULL, 0, ""**********************Client-Side::Sending Started**************************\n""); "
2665,    while (1)
2666,    {
2667,        fileMemory_NACK = FileSizeCalculator(fileLocFull);
2668,
2669,        // File Status @ Server (Reciever) 
2670,"        if (read(sockfd, &fileMemory_ACK, sizeof(size_t)) == -1)"
2671,"            fprintfSwitchable(NULL, 1, ""[-client] Error in reading File Info!\n""); "
2672,        else
2673,"            fprintfSwitchable(NULL, 0, ""[+client] File (Size) Info is Recieved Successfully.\n""); "
2674,
2675,        // Send-Recieve Validity
2676,        fileRemainMemory = fileMemory_NACK - fileMemory_ACK;
2677,            
2678,        // Send Expecting Data Size For Server
2679,"        if (write(sockfd, &fileRemainMemory, sizeof(size_t)) == -1)"
2680,"            fprintfSwitchable(NULL, 1, ""[-client] Failed To Send Remaining Memory Info!\n""); "
2681,        else
2682,"            fprintfSwitchable(NULL, 0, ""[+client] Session [%lu] Overview: \nACK Memory is %lu\nNACK Memory is %lu\nRemaining Memory is: %lu\n\n"", "
2683,"                                        OveralIteration, fileMemory_ACK, fileMemory_NACK, fileRemainMemory); "
2684,        // Assess Sending
2685,        if (fileMemory_NACK == fileMemory_ACK) 
2686,        {
2687,"            fprintfSwitchable(NULL, 0, ""[+client] Remaining Memory is Zero. Send Process Will Contine After %lu[s] Timeout.\n"", sleepTimer);;  "
2688,            continue;
2689,        }
2690,        else if (fileRemainMemory < BUFFER_MAX)
2691,        {
2692,"            fprintfSwitchable(NULL, 0, ""[+client] Remaining Buffer is Smaller Than Cache Limit %lu. Send Process Will Contine After %lu[s] Timeout.\n"","
2693,"                              BUFFER_MAX, sleepTimer);  "
2694,            Not_Written++;
2695,            if (Not_Written < 10) 
2696,                continue;
2697,            else
2698,                Not_Written = 0;
2699,        }
2700,        
2701,        // Creating Cache
2702,        CACHE_SIZE = fileRemainMemory;
2703,"        cacheBuffer = (char*) calloc (CACHE_SIZE, sizeof(char));"
2704,"        bzero(cacheBuffer, CACHE_SIZE);"
2705,        
2706,        // Copy Data From File to CACHE-Buffer
2707,"        filePtr_NACK = fopen(fileLocFull, ""r"");"
2708,"        fseek(filePtr_NACK, fileMemory_ACK, SEEK_SET);"
2709,"        fread(cacheBuffer, sizeof(char), CACHE_SIZE, filePtr_NACK);"
2710,        fclose(filePtr_NACK);
2711,        
2712,        ACKFLAG = 0;
2713,        SentBytes = 0;
2714,        fileRemainMemory = CACHE_SIZE;
2715,        InnerIteration = 0;
2716,        while (1)
2717,        {
2718,            // EXIT CONDITION
2719,            if (fileRemainMemory == 0) break;
2720,            
2721,            // Evaluate Buffer Size
2722,            if (fileRemainMemory >= BUFFER_MAX)                     
2723,                mssg->BUFFER_USED = BUFFER_MAX;
2724,            else 
2725,                mssg->BUFFER_USED = fileRemainMemory;
2726,                
2727,            // Copy From CACHE to Socket Buffer and Send
2728,"            memcpy(mssg->mssgPtr, cacheBuffer+SentBytes, mssg->BUFFER_USED);"
2729,"            writeFLAG = write(sockfd, mssg, sizeof(struct bufferTCP)); "
2730,"            fprintfSwitchable(NULL, 0, ""[+client] Iter %ld :: %ld/%ld Sent!\n"", InnerIteration++, writeFLAG, sizeof(struct bufferTCP)); "
2731,            // Cases:
2732,            if (writeFLAG == -1)
2733,            {
2734,                // Display Problem
2735,"                fprintfSwitchable(NULL, 0, ""[-client] Error While Sending Buffer!\n"");"
2736,"                fprintfSwitchable(NULL, 0, ""[-client] %s\n"", strerror(errno));"
2737,            } 
2738,            else if (writeFLAG < sizeof(struct bufferTCP))
2739,            {
2740,                // Display Problem
2741,"                fprintfSwitchable(NULL, 0, ""[-client] Only %ld/%ld Sent!\n"", writeFLAG, sizeof(struct bufferTCP)); "
2742,            }   
2743,            else
2744,            {
2745,                // In Session Statistics    
2746,                fileRemainMemory -= mssg->BUFFER_USED;
2747,                SentBytes        += mssg->BUFFER_USED;
2748,"                fprintfSwitchable(NULL, 0, ""[+client] (%lu) Current-Iteration | (%lu) Total-Sent | (%lu) Remaining.\n"", writeFLAG, SentBytes, fileRemainMemory);"
2749,            }   
2750,"            bzero(mssg->mssgPtr, BUFFER_MAX); "
2751,        }
2752,        if (writeFLAG != -1 && fileRemainMemory == 0)
2753,        {
2754,            fileMemory_ACK = SentBytes;
2755,            OveralIteration++;
2756,        }
2757,            
2758,        // Session Summary
2759,"        fprintfSwitchable(NULL, 0, ""[+client] Session %lu Summary:\nACK Memory is %lu :: Remaining Memory is: %lu\n\n"", "
2760,"                                          OveralIteration, fileMemory_ACK, fileRemainMemory);   "
2761,        free(cacheBuffer);
2762,        // Exit Condition
2763,"        if (isEnd (sleepTimer, ""client""))  break;"
2764,
2765,    }
2766,"    fprintfSwitchable(NULL, 0, ""\n***********************Client-Side::Sending Ended***************************\n""); "
2767,
2768,    close(sockfd);
2769,    free(serverAddr);
2770,    free(mssg);
2771,
2772,    return 0;
2773,}
2774,/*
2775,    How to compile ->
2776,    (1) make all
2777,        if no make was provided then gcc server.c utilityFunctionsMHZ.h -o server
2778,    (2) ./server FILENAME PORT_NUMBER SLEEP_TIMER CHACHE_SIZE_MAX
2779,        Example: ./server mainFile2.log 5500 10 4096
2780,    (3) ./client FILENAME SERVER_ADDR PORT_NUMBER
2781,        Example: ./client mainFile.log 172.17.34.89 5500
2782,*/  
2783,
2784,"#include ""utilityFunctionsMHZ.h"""
2785,
2786,"int main (int argc, char* argv[])"
2787,{
2788,    // Initial Error Check And Call Initializer
2789,    if (argc < 5) 
2790,    {
2791,"        fprintfSwitchable(NULL, 0, ""[+server] Please use the following format to initiate the ./server FILENAME PORT_NUMBER SLEEP_TIMER MAX_CACHE_SIZER\n"");"
2792,        exit(0);
2793,    }   
2794,    else
2795,    {
2796,"        Initializer (""server"", NULL);"
2797,    }
2798,        
2799,    // Input Parameters  
2800,    const char* fileLocFull = argv[1];
2801,    int portNumber          = atoi(argv[2]);         
2802,    size_t sleepTimer       = atoi(argv[3]); 
2803,    size_t MAX_CACHE_SIZE   = atoi(argv[4]);
2804,    size_t WaitQueue        = 5;
2805,    
2806,    // server :: Socket Accept Client Request
2807,    socklen_t socklen = sizeof(struct sockaddr_in);
2808,
2809,"    // File Process, Data Structure (NACK is the Sender/Client Side)"
2810,"    if (!isFileAvailable(argv[1], ""server"", NULL))"
2811,    {
2812,"        FILE* filePtr_ACK = fopen(fileLocFull, ""w"");"
2813,        fclose(filePtr_ACK);
2814,    }
2815,    
2816,    //size_t checker = FileCorrector (fileLocFull);
2817,    size_t checker = FileModifier (fileLocFull);
2818,
2819,"    // File Process, Data Structure (NACK-Sender & ACK-Reciever)"
2820,    FILE* filePtr_ACK;
2821,    size_t fileMemory_ACK = 0;
2822,    size_t fileRemainMemory = 0;
2823,    
2824,    // Buffer Properties and Size (Set Sender/Client Buffer-Size Equal to Server)
2825,    struct bufferTCP* mssg = CreateBufferTCP();
2826,    // Cache properties
2827,    size_t CACHE_SIZE;
2828,    char* cacheBuffer;
2829,
2830,    // socket End-Point
2831,"    int sockfd, sockfd_new;"
2832,    // client :: Initiation Socket via TCP Protocol & Error Check
2833,"    sockfd = socket(AF_INET, SOCK_STREAM, 0);"
2834,    if (sockfd == -1)
2835,"        fprintfSwitchable(NULL, 1, ""[-server] Error in Socket Initiation!\n"");"
2836,    else
2837,"        fprintfSwitchable(NULL, 0, ""[+server] Socket Successfully Initiated.\n"");"
2838,
2839,    // Socket main Structures
2840,    struct sockaddr_in* serverAddr;
2841,    struct sockaddr_in* clientAddr;
2842,    serverAddr =  malloc(sizeof(struct sockaddr_in));       
2843,    clientAddr =  malloc(sizeof(struct sockaddr_in));
2844,    
2845,    // Socket Structures Memory Allocation Test
2846,    if (clientAddr == NULL || serverAddr == NULL)
2847,"        fprintfSwitchable(NULL, 1, ""[-server] Memory Allocation for sockadd_in strctures Failed!\n"");"
2848,    else
2849,"        fprintfSwitchable(NULL, 0, ""[+server] Memory Allocation Successfully Completed.\n"");"
2850,    
2851,"    bzero(serverAddr, sizeof(struct sockaddr_in)); //memset(serverAddr, 0x00, sizeof(struct sockaddr_in));"
2852,"    bzero(clientAddr, sizeof(struct sockaddr_in)); //memset(clientAddr, 0x00, sizeof(struct sockaddr_in));"
2853,    
2854,    // set-up Server parameters
2855,    serverAddr->sin_family      = AF_INET;
2856,    serverAddr->sin_addr.s_addr = INADDR_ANY;   // inet_addr(clientIP);
2857,    serverAddr->sin_port        = htons(portNumber);
2858,
2859,    // server :: Socket Binding
2860,"    if (bind(sockfd, (struct sockaddr*) serverAddr, sizeof(struct sockaddr_in)) == -1)"
2861,"        fprintfSwitchable(NULL, 1, ""[-server] Error in Socket Binding!\n"");"
2862,    else
2863,"        fprintfSwitchable(NULL, 0, ""[+server] Socket Successfully Binded.\n"");"
2864,    
2865,    // server :: Socket Listening
2866,"    if (listen(sockfd, WaitQueue) == -1)"
2867,"        fprintfSwitchable(NULL, 1, ""[-server] Error while Listening!\n"");"
2868,    else
2869,"        fprintfSwitchable(NULL, 0, ""[+server] Listening...\n"");"
2870,    
2871,    // server :: Socket Listening
2872,"    sockfd_new = accept(sockfd, (struct sockaddr*) clientAddr, &socklen);"
2873,    if (sockfd_new == -1)
2874,"        fprintfSwitchable(NULL, 1, ""[-server] Error in Accepting Client Connection!\n"");"
2875,    else
2876,"        fprintfSwitchable(NULL, 0, ""[+server] Connection Successfully Accepted.\n"");"
2877,
2878,    // Establishing BUFFER_MAX_SIZE (Set Sender/Client Buffer-Size Equal to Server)
2879,"    if (write(sockfd_new, &MAX_CACHE_SIZE, sizeof(size_t)) == -1)"
2880,"        fprintfSwitchable(NULL, 1, ""[-server] Error in Buffer Size Negitiation!\n"");"
2881,    else 
2882,"        fprintfSwitchable(NULL, 0, ""[+server] MAX Buffer-Size is Sent to client: %lu.\n"", MAX_CACHE_SIZE);"
2883,    
2884,    // Initializing Sender Sleep Clock (Set Sender/Client Buffer-Size Equal to Server)
2885,"    if (write(sockfd_new, &sleepTimer, sizeof(size_t)) == -1)"
2886,"        fprintfSwitchable(NULL, 1, ""[-server] Error in Sleep Timer Negitiation!\n"");"
2887,    else 
2888,"        fprintfSwitchable(NULL, 0, ""[+server] Sleep-Timer is Sent to client: %lu\n"", sleepTimer);"
2889,
2890,"    int ACKFLAG = 0, CONFLAG = 0;"
2891,    size_t OveralIteration = 0;
2892,    size_t SentBytes;
2893,    size_t Not_Written;
2894,    int iack = 0;
2895,    ssize_t readFLAG;
2896,    ssize_t writeFLAG;
2897,    size_t InnerIteration = 0;
2898,
2899,"    fprintfSwitchable(NULL, 0, ""**********************Server-Side::Recieving Started**************************\n"");"
2900,    while (1)
2901,    {
2902,        // File Status @ Server (Reciever) 
2903,        fileMemory_ACK = FileSizeCalculator(fileLocFull);
2904,        
2905,        // Send ACK Status
2906,"        if (write(sockfd_new, &fileMemory_ACK, sizeof(size_t)) == -1)"
2907,"            fprintfSwitchable(NULL, 1, ""[-server] Error in Sending File Info!\n"");"
2908,        else
2909,"            fprintfSwitchable(NULL, 0, ""[+server] File (Size) Info Sent Successfully.\n""); "
2910,
2911,        // Recieve Expecting Data Size From Client
2912,"        if (read(sockfd_new, &fileRemainMemory, sizeof(size_t)) == -1)"
2913,"            fprintfSwitchable(NULL, 1, ""[-server] Failed to Recieve Remaining Memory Info!\n""); "
2914,        else
2915,"            fprintfSwitchable(NULL, 0, ""[+server] Session [%lu] Overview:\nACK Memory is: %lu\nRemaining Memory is: %lu\n\n"", "
2916,"                                    OveralIteration, fileMemory_ACK, fileRemainMemory); "
2917,        if (fileRemainMemory == 0) 
2918,        {
2919,"            fprintfSwitchable(NULL, 0, ""[+server] Remaining Memory is Zero. Process Will Contine After %lu[s] Timeout.\n"", sleepTimer); "
2920,            continue;
2921,        }
2922,        else if (fileRemainMemory < BUFFER_MAX)
2923,        {
2924,"            fprintfSwitchable(NULL, 0, ""[+server] Remaining Buffer is Smaller Than Cache Limit %lu. Recieve Process Will Contine After %lu[s] Timeout.\n"","
2925,"                              BUFFER_MAX, sleepTimer);  "
2926,            Not_Written++;
2927,            if (Not_Written < 10) 
2928,                continue;
2929,            else
2930,                Not_Written = 0;
2931,        }
2932,
2933,        // Creating Cache
2934,        CACHE_SIZE = fileRemainMemory;
2935,"        cacheBuffer = calloc (CACHE_SIZE, sizeof(char));"
2936,"        bzero(cacheBuffer, CACHE_SIZE);"
2937,
2938,        ACKFLAG = 0;
2939,        SentBytes = 0;
2940,        fileRemainMemory = CACHE_SIZE;
2941,        InnerIteration = 0;
2942,        while (1)
2943,        {
2944,            // EXIT CONDITION
2945,            if (fileRemainMemory == 0) break;
2946,
2947,            // Recieve Buffer
2948,"            readFLAG = read(sockfd_new, mssg, sizeof(struct bufferTCP));    "
2949,"            fprintfSwitchable(NULL, 0, ""[+server] Iter %ld :: %ld/%ld Sent!\n"", InnerIteration++, readFLAG, sizeof(struct bufferTCP)); "
2950,            // Cases:
2951,            if (readFLAG == -1) 
2952,            {
2953,                // Display Problem
2954,"                fprintfSwitchable(NULL, 0, ""[-server] Error While Reading Buffer Size!\n""); "
2955,            }
2956,            else if (readFLAG < sizeof(struct bufferTCP))
2957,            {
2958,                // Copy From CACHE to Socket Buffer
2959,"                fprintfSwitchable(NULL, 0, ""[-server] Only %ld/%ld Recieved!\n"",readFLAG, sizeof(struct bufferTCP)); "
2960,"                fprintfSwitchable(NULL, 0, ""[-server] %s\n"", strerror(errno));"
2961,            }
2962,            else
2963,            {
2964,                // Copy From CACHE to Socket Buffer
2965,"                memcpy(cacheBuffer+SentBytes, mssg->mssgPtr, mssg->BUFFER_USED);"
2966,                // In Session Statistics    
2967,                fileRemainMemory -= mssg->BUFFER_USED;
2968,                SentBytes        += mssg->BUFFER_USED;
2969,"                fprintfSwitchable(NULL, 0, ""[+server] (%lu) Current-Iteration | (%lu) Total-Sent | (%lu) Remaining.\n"", readFLAG, SentBytes, fileRemainMemory);"
2970,            }   
2971,"            bzero(mssg->mssgPtr, BUFFER_MAX); "
2972,        }       
2973,        if (readFLAG != -1 && fileRemainMemory == 0)
2974,        {
2975,            fileMemory_ACK = SentBytes;
2976,            // Copy Data From File to CACHE-Buffer
2977,"            filePtr_ACK = fopen(fileLocFull, ""a"");"
2978,"            fwrite(cacheBuffer, sizeof(char), CACHE_SIZE, filePtr_ACK);"
2979,            fclose(filePtr_ACK);
2980,            OveralIteration++;
2981,        }
2982,        
2983,"        // Session Summary-alIteration, fileMemory_ACK, fileRemainMemory);  "
2984,        free(cacheBuffer);
2985,        // Exit Condition
2986,"        if (isEnd (sleepTimer, ""server""))  break;"
2987,    }
2988,"    fprintfSwitchable(NULL, 0, ""\n***********************Server-Side::Recieving Ended***************************\n"");"
2989,    
2990,    close(sockfd);
2991,    close(sockfd_new);
2992,    free(serverAddr);
2993,    free(clientAddr);
2994,    free(mssg);
2995,
2996,    return 0;
2997,}
2998,#ifndef utilityFunctionsMHZ_H
2999,#define utilityFunctionsMHZ_H
3000,
3001,#include <stdio.h>      //:: standard IO c-functions
3002,#include <string.h>     //:: standard c-string functions
3003,#include <unistd.h>     //:: standard POSIX operating system API (read/write/send/recv)
3004,"#include <stdlib.h>     //:: standard ALLOC c-functions (malloc, atoi)"
3005,#include <sys/types.h>  //:: definitions of data types used in sys/socket & netinet/in
3006,#include <sys/socket.h> //:: definitions of structures needed for internet domain such as (struct sockaddr)
3007,#include <netinet/in.h> //:: definitions of (struct sockaddr_in)
3008,#include <netdb.h>      //:: definitions of (struct hostnet) to store info of a given host & IPV-4
3009,#include <arpa/inet.h>  //:: inet()
3010,#include <sys/stat.h>
3011,#include <stdarg.h>     //:: Variable Input function
3012,#include <errno.h>
3013,#define BUFFER_MAX 1024
3014,
3015,struct bufferTCP
3016,{
3017,    char mssgPtr[BUFFER_MAX];
3018,    size_t BUFFER_USED;
3019,};
3020,
3021,// Usefull functions
3022,struct bufferTCP* CreateBufferTCP();
3023,"void WriteLog(const char* logFileName, const char* mssg);"
3024,size_t FileCorrector (const char* fileName);;
3025,"FILE* FileOpenSafe (const char* fileName, const char* rwaMode);"
3026,size_t FileSizeCalculator (const char* fileName);
3027,"void fprintfSwitchable(FILE* stream, int errFlag, const char* mssg, ...);"
3028,"FILE* FileOpenSafe (const char* fileName, const char* rwaMode);"
3029,size_t FileSizeCalculator (const char* fileName);
3030,size_t FileCorrector (const char* fileName);
3031,size_t FileModifier(const char* fileName);
3032,"void Initializer (const char* caller, FILE* stream);"
3033,"int isEnd (size_t sleepTimer, const char* caller);"
3034,"int isFileAvailable (const char* fileLocFull, const char* caller, FILE* stream);"
3035,
3036,"void WriteLog(const char* logFileName, const char* mssg)"
3037,{
3038,"    FILE* logFilePtr = fopen(logFileName, ""a"");"
3039,"    //fputs(mssg, logFilePtr);"
3040,    fclose(logFilePtr);
3041,}
3042,
3043,
3044,"void fprintfSwitchable(FILE* stream, int errFlag, const char* mssg, ...)"
3045,{
3046,    va_list args;
3047,
3048,"    va_start(args, mssg);"
3049,
3050,    if (stream == NULL)
3051,    {
3052,"        vfprintf(stdout, mssg, args);"
3053,        fflush(stdout);
3054,    }
3055,    else
3056,    {
3057,"        vfprintf(stream, mssg, args);"
3058,        fflush(stream);
3059,    }    
3060,
3061,    if (errFlag)  exit(1);
3062,        
3063,    va_end(args);
3064,}
3065,
3066,
3067,"FILE* FileOpenSafe (const char* fileName, const char* rwaMode)"
3068,{
3069,    if (fileName == NULL)
3070,"        fprintfSwitchable(NULL, -1, ""FileName or Location is Incorrect!\n"");"
3071,
3072,"    FILE* filePtr = fopen(fileName, rwaMode);"
3073,
3074,    if (filePtr == NULL)
3075,"        fprintfSwitchable(NULL, -1, ""File Location is Invalid Or File Does Not Exists!\n"");"
3076,
3077,    return filePtr;
3078,}
3079,
3080,
3081,size_t FileSizeCalculator (const char* fileName)
3082,{
3083,"    FILE* filePtr = FileOpenSafe(fileName, ""r"");"
3084,    int fileDescriptor = fileno(filePtr);
3085,    struct stat fileInfo;
3086,"    bzero(&fileInfo, sizeof(struct stat));"
3087,"    fstat(fileDescriptor, &fileInfo);"
3088,    size_t fileSize =  fileInfo.st_size;
3089,    fclose(filePtr);
3090,
3091,    return fileSize;
3092,}
3093,
3094,size_t FileCorrector (const char* fileName)
3095,{
3096,    size_t fileSize = FileSizeCalculator (fileName);
3097,    size_t fileSizeTrue;
3098,    if (fileSize == 0)
3099,    {
3100,"        fprintfSwitchable(NULL, 0, ""File is Empty, thus requires no correction!\n"");"
3101,        return 0;
3102,    }
3103,        
3104,    // Main & Temp File
3105,"    FILE* mainFile = FileOpenSafe (fileName, ""r"");"
3106,"    FILE* tempFile = FileOpenSafe(""temp"", ""w"");"
3107,    
3108,    // Fault Detection (\00 0\0 00) and correct
3109,    char checkBuff[3];
3110,    char curserrChar;
3111,    
3112,    size_t ii;
3113,    for (ii = 0; ii < fileSize; ii++)
3114,    {
3115,        curserrChar = fgetc(mainFile);
3116,"        //printf(""%c"", curserrChar);"
3117,        if (curserrChar == '\00')
3118,        {    
3119,            fileSizeTrue = ftell(mainFile)-2;
3120,            break;
3121,        }
3122,"        fputc(curserrChar, tempFile);"
3123,    }
3124,    fclose(mainFile);
3125,    fclose(tempFile);
3126,
3127,    // Remove The Old File
3128,    if (remove(fileName) == 0) 
3129,"        fprintfSwitchable(NULL, 0, ""Faulty File (%s) Removed Successfully.\n"", fileName);"
3130,    else
3131,"        fprintfSwitchable(NULL, 1, ""Error while Removing the Faulty File: %s!\n"", fileName);"
3132,
3133,
3134,    // Remove The Old File
3135,"    if (rename(""temp"", fileName) == 0) "
3136,"        fprintfSwitchable(NULL, 0, ""Corrected File Renamed Successfully.\n"");"
3137,    else
3138,"        fprintfSwitchable(NULL, 1, ""Error while Removing the Faulty File: %s!\n"");"
3139,
3140,"    fprintfSwitchable(NULL, 0, ""Correction Implemented Successfully.\n"");"
3141,
3142,    return fileSizeTrue;
3143,}
3144,
3145,
3146,size_t FileModifier(const char* fileName)
3147,{
3148,    size_t fileSize = FileSizeCalculator (fileName);
3149,    size_t fileSizeTrue;
3150,    if (fileSize == 0)
3151,    {
3152,"        fprintfSwitchable(NULL, 0, ""[+server] File is Empty, thus requires no correction.\n"");"
3153,        return 0;
3154,    }
3155,        
3156,    // Main & Temp File
3157,"    FILE* mainFile = FileOpenSafe (fileName, ""r"");"
3158,"    FILE* tempFile = FileOpenSafe(""temp"", ""w"");"
3159,    
3160,    // Fault Detection (\00 0\0 00) and correct
3161,    char checkBuff[3];
3162,    char curserrChar;
3163,    size_t ii;
3164,    for (ii = 0; ii < fileSize; ii++)
3165,    {
3166,        curserrChar = fgetc(mainFile);
3167,        if (curserrChar == '\00') break;
3168,"        fputc(curserrChar, tempFile);"
3169,    }
3170,    fclose(mainFile);
3171,    fclose(tempFile);
3172,
3173,
3174,"    mainFile = FileOpenSafe (fileName, ""w"");"
3175,"    tempFile = FileOpenSafe(""temp"", ""r"");"
3176,"    fileSizeTrue = FileSizeCalculator (""temp"");"
3177,
3178,    ii=0;
3179,    for (ii = 0; ii < fileSizeTrue; ii++)
3180,    {
3181,        curserrChar = fgetc(tempFile);
3182,"        fputc(curserrChar, mainFile);"
3183,    }
3184,    
3185,    fclose(mainFile);
3186,    fclose(tempFile);
3187,
3188,    // Remove The Old File
3189,"    if (remove(""temp"") == 0) "
3190,"        fprintfSwitchable(NULL, 0, ""[+server] Temp File Removed Successfully.\n"");"
3191,    else
3192,"        fprintfSwitchable(NULL, 1, ""[-server] Error while Removing the Faulty File!\n"");"
3193,
3194,"    fprintfSwitchable(NULL, 0, ""[+server] File Modifier Executed Successfully.\n"");"
3195,
3196,    return fileSizeTrue;
3197,}
3198,
3199,
3200,"void Initializer (const char* caller, FILE* stream)"
3201,{
3202,    // Initial confirmation client side
3203,    char checkSend;
3204,"    fprintfSwitchable(stream, 0, ""[+%s] Start Process [Y/N]: "", caller);"
3205,"    scanf("" %c"", &checkSend);"
3206,    if (checkSend == 'N' || checkSend == 'n')
3207,    {
3208,"        fprintfSwitchable(stream, 0, ""[-%s] Abort Process As Requested!\n"", caller);"
3209,        exit(0);
3210,    } 
3211,    else
3212,        return;
3213,}
3214,    
3215,"int isEnd (size_t sleepTimer, const char* caller)"
3216,{
3217,    // Exit Material
3218,    fd_set          s;
3219,    struct timeval  timeout;
3220,    char exitFlag[12];
3221,"    memset(&exitFlag, 'F', 12);"
3222,    int sFlag;
3223,
3224,    fflush(stdout);
3225,    FD_ZERO(&s);
3226,"    FD_SET(0, &s);"
3227,    timeout.tv_sec = sleepTimer; timeout.tv_usec = 0;
3228,"    sFlag = select(1, &s, NULL, NULL, &timeout);"
3229,    
3230,    if      (sFlag < 0) 
3231,        return 0;
3232,    else if (sFlag == 0) 
3233,    {
3234,        fflush(stdout);
3235,"        fprintfSwitchable(NULL, 0, ""-\n"");"
3236,        return 0;
3237,    }
3238,    else
3239,    {
3240,"        fgets(exitFlag, 12, stdin);"
3241,"        fprintfSwitchable(NULL, 0, ""[+%s] To Quit, please enter \""exit\"": "", caller); "
3242,        fflush(stdout);
3243,"        if ( memcmp(&exitFlag, ""exit"", 4) == 0 ) "
3244,            return 1;
3245,        else
3246,            return 0;
3247,    }
3248,
3249,}
3250,
3251,"int isFileAvailable (const char* fileLocFull, const char* caller, FILE* stream)"
3252,{
3253,    // Checks if The Target Send File Exists!
3254,"    FILE* filePtr_NACK = fopen(fileLocFull, ""r"");"
3255,    if (filePtr_NACK == NULL)
3256,    {
3257,"        fprintfSwitchable(stream, 0, ""[-%s] Not Such File Name Exists!\n"", caller);"
3258,        return 0;
3259,    }
3260,    else
3261,    {
3262,"        fprintfSwitchable(stream, 0, ""[+%s] File Found Successfully.\n"", caller);"
3263,        fclose(filePtr_NACK);
3264,        return 1;
3265,    }
3266,    
3267,}
3268,
3269,
3270,"void copyWithOffsetDest(char* dest, const char* src, size_t start, size_t length)"
3271,{
3272,    size_t i = 0;
3273,    for (i = 0; i < length; i++)
3274,        dest[start+i] = src[i];
3275,}
3276,
3277,"void copyWithOffsetSource(char* dest, const char* src, size_t start, size_t length)"
3278,{
3279,    size_t i = 0;
3280,    for (i = 0; i < length; i++)
3281,        dest[i] = src[i+start];
3282,}
3283,
3284,
3285,struct bufferTCP* CreateBufferTCP()
3286,{
3287,    struct bufferTCP* mssg = (struct bufferTCP*) 
3288,                malloc(sizeof(struct bufferTCP));
3289,    return mssg;
3290,}
3291,
3292,#endif
3293,all:    client server
3294,
3295,ftpclient: client.c
3296,    gcc -std=gnu99 -Wall $< -o $@
3297,
3298,ftpserver: server.c
3299,    gcc -std=gnu99 -Wall $< -o $@
3300,
3301,clean:
3302,    rm -f client server *.o *~ core
3303,    rm server client
3304,columns = naviModelNewsColumns();
3305,"zend_update_property(Z_OBJCE_P(ZEND_THIS), Z_OBJ_P(ZEND_THIS), ZEND_STRL(""columns""), &columns);"
3306,zval_ptr_dtor(&columns);
3307,zval naviModelNewsColumns() {
3308,"    zval _1, _2, _3, idLabel, titleLabel, result;"
3309,
3310,    array_init(&_1);
3311,
3312,    array_init(&_2);
3313,"    ZVAL_STRING(&idLabel, ""ID"");"
3314,"    add_next_index_string(&_2, ""id"");"
3315,"    add_assoc_zval(&_2, ""label"", &idLabel);"
3316,"    add_assoc_zval(&_1, ""id"", &_2);"
3317,
3318,    array_init(&_3);
3319,"    ZVAL_STRING(&titleLabel, ""Title"");"
3320,"    add_next_index_string(&_3, ""title"");"
3321,"    add_assoc_zval(&_3, ""label"", &titleLabel);"
3322,"    add_assoc_zval(&_1, ""title"", &_3);"
3323,
3324,"    ZVAL_ZVAL(&result, &_1, 1, 1);"
3325,
3326,    return result;
3327,}
3328,$model = new Navi\Model\News();
3329,$model = new Navi\Model\News();
3330,
3331,$model->load([
3332,    'title' => 'Hello'
3333,]);
3334,"add_assoc_zval(&_1, ""id"", &_2);"
3335,"PHP_METHOD(NaviModel, load) {"
3336,"    zval *dataParam, input, *data, *columns, rv, function;"
3337,
3338,    bool encode = false;
3339,
3340,"    ZEND_PARSE_PARAMETERS_START(1, 2)"
3341,        Z_PARAM_ZVAL(dataParam)
3342,        Z_PARAM_OPTIONAL
3343,        Z_PARAM_BOOL(encode)
3344,    ZEND_PARSE_PARAMETERS_END();
3345,
3346,    if (Z_TYPE_P(dataParam) == IS_NULL) {
3347,        RETURN_TRUE;
3348,    } else if (Z_TYPE_P(dataParam) == IS_OBJECT) {
3349,        zval args[1];
3350,
3351,"        ZVAL_STRING(&function, ""get_object_vars"");"
3352,
3353,"        ZVAL_COPY_VALUE(&args[0], dataParam);"
3354,
3355,"        call_user_function(NULL, NULL, &function, &input, 1, args);"
3356,
3357,        zval_dtor(args);
3358,    } else if (Z_TYPE_P(dataParam) == IS_ARRAY) {
3359,        zval index;
3360,
3361,        zend_string *paramKey;
3362,
3363,        array_init(&input);
3364,
3365,"        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARR_P(dataParam), paramKey, data) {"
3366,"            ZVAL_STR_COPY(&index, paramKey);"
3367,
3368,"            add_assoc_zval(&input, Z_STRVAL(index), data);"
3369,        } ZEND_HASH_FOREACH_END();
3370,    }
3371,
3372,"    zend_string *key, *empty = zend_string_init(ZEND_STRL(""""), 0); // Need initial for release"
3373,
3374,"    columns = zend_read_property(naviModelCe, Z_OBJ_P(ZEND_THIS), ZEND_STRL(""columns""), ZEND_FETCH_CLASS_SILENT, &rv);"
3375,
3376,    if (Z_TYPE_P(columns) == IS_ARRAY) {
3377,"        ZEND_HASH_FOREACH_STR_KEY(Z_ARR_P(columns), key) {"
3378,            zval index;
3379,
3380,"            ZVAL_STR_COPY(&index, key);"
3381,            zval_copy_ctor(&index);
3382,
3383,"            if (zend_hash_str_exists(Z_ARR(input), Z_STRVAL(index), strlen(Z_STRVAL(index)))) {"
3384,                zval value;
3385,"                ZVAL_COPY_VALUE(&value, zend_hash_str_find(Z_ARR(input), Z_STRVAL(index), strlen(Z_STRVAL(index))));"
3386,                zval_copy_ctor(&value);
3387,
3388,                if (Z_TYPE(value) == IS_STRING) {
3389,                    zend_string *trimmed;
3390,
3391,"                    trimmed = php_trim(Z_STR(value), NULL, 0, 3);"
3392,
3393,                    if (encode) {
3394,                        zval _3args[3];
3395,
3396,"                        ZVAL_STRING(&function, ""htmlspecialchars"");"
3397,
3398,"                        ZVAL_STRING(&_3args[0], ZSTR_VAL(trimmed));"
3399,"                        ZVAL_LONG(&_3args[1], 3);"
3400,"                        ZVAL_STRING(&_3args[2], ""UTF-8"");"
3401,
3402,"                        call_user_function(NULL, NULL, &function, &value, 3, _3args);"
3403,
3404,                        zval_dtor(_3args);
3405,                    } else {
3406,"                        ZVAL_STRING(&value, ZSTR_VAL(trimmed));"
3407,                    }
3408,                }
3409,
3410,"                Z_OBJ_HT_P(ZEND_THIS)->write_property(Z_OBJ_P(ZEND_THIS), Z_STR(index), &value, 0);"
3411,
3412,                zval_ptr_dtor(&value);
3413,            }
3414,
3415,            zval_ptr_dtor(&index);
3416,        } ZEND_HASH_FOREACH_END();
3417,    }
3418,
3419,    zend_string_release(key);
3420,    zend_string_release(empty);
3421,    zval_ptr_dtor(&input);
3422,
3423,    RETURN_TRUE;
3424,}
3425,"==68589== Memcheck, a memory error detector"
3426,"==68589== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."
3427,==68589== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
3428,==68589== Command: /root/php-bin/DEBUG/bin/php ./test/test.php
3429,==68589== Parent PID: 9
3430,==68589== 
3431,==68589== 
3432,==68589== HEAP SUMMARY:
3433,"==68589==     in use at exit: 3,541 bytes in 11 blocks"
3434,"==68589==   total heap usage: 14,052 allocs, 14,041 frees, 2,964,771 bytes allocated"
3435,==68589== 
3436,==68589== 32 bytes in 1 blocks are definitely lost in loss record 1 of 8
3437,==68589==    at 0x484EFC8: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
3438,==68589==    by 0x6E79C7: __zend_malloc (zend_alloc.c:3056)
3439,==68589==    by 0x6E649B: _malloc_custom (zend_alloc.c:2418)
3440,==68589==    by 0x6E660F: _emalloc (zend_alloc.c:2537)
3441,==68589==    by 0x739393: zend_string_alloc (zend_string.h:144)
3442,==68589==    by 0x739403: zend_string_init (zend_string.h:166)
3443,==68589==    by 0x73CA2B: _zend_hash_str_add_or_update_i (zend_hash.c:869)
3444,==68589==    by 0x73CD9F: zend_hash_str_update (zend_hash.c:932)
3445,==68589==    by 0x72668F: zend_symtable_str_update (zend_hash.h:542)
3446,==68589==    by 0x72D853: add_assoc_zval_ex (zend_API.c:1552)
3447,==68589==    by 0x72B050F: naviModelNewsColumns (news.c:38)
3448,==68589==    by 0x72B0B0B: zim_NaviModelNews___construct (news.c:98)
3449,==68589== 
3450,==68589== LEAK SUMMARY:
3451,==68589==    definitely lost: 32 bytes in 1 blocks
3452,==68589==    indirectly lost: 0 bytes in 0 blocks
3453,==68589==      possibly lost: 0 bytes in 0 blocks
3454,"==68589==    still reachable: 3,509 bytes in 10 blocks"
3455,==68589==         suppressed: 0 bytes in 0 blocks
3456,==68589== Reachable blocks (those to which a pointer was found) are not shown.
3457,"==68589== To see them, rerun with: --leak-check=full --show-leak-kinds=all"
3458,==68589== 
3459,"==68589== For lists of detected and suppressed errors, rerun with: -s"
3460,==68589== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
3461,#include <stdio.h>
3462,#include <math.h>
3463,
3464,int main() {
3465,    int a;
3466,    int b;
3467,"    printf(""enter a"");"
3468,"    scanf(""%d"",& a);"
3469,"    printf(""enter b"");"
3470,"    scanf(""%d"",b);"
3471,    int sum = a+b;
3472,"    printf(""sum is: %d"");"
3473,    returno;
3474, }
3475,&
3476,&a
3477,b
3478,<math.h>
3479,printf()
3480,sum
3481,int a;
3482,int b;
3483,...
3484,"scanf(""%d"", &a);  //"
3485,"scanf(""%d"", &b);  // the second parameter should be the address of b"
3486,...
3487,return 0;
3488,{
3489,// Use IntelliSense to learn about possible attributes.
3490,// Hover to view descriptions of existing attributes.
3491,"// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387"
3492,"""version"": ""0.2.0"","
3493,"""configurations"": ["
3494,    {
3495,"        ""name"": ""(gdb) Launch"","
3496,"        ""type"": ""cppdbg"","
3497,"        ""request"": ""launch"","
3498,"        ""program"": ""C:\\Users\\Šimon\\Desktop\\Cfiles\\HelloWorld.c"","
3499,"        ""args"": [],"
3500,"        ""stopAtEntry"": false,"
3501,"        ""cwd"": ""${fileDirname}"","
3502,"        ""environment"": [],"
3503,"        ""externalConsole"": false,"
3504,"        ""MIMode"": ""gdb"","
3505,"        ""miDebuggerPath"": ""C:\\Users\\Šimon\\Desktop\\migw64\\mingw64\\bin\\gdb.exe"","
3506,"        ""setupCommands"": ["
3507,            {
3508,"                ""description"": ""Enable pretty-printing for gdb"","
3509,"                ""text"": ""-enable-pretty-printing"","
3510,"                ""ignoreFailures"": true"
3511,"            },"
3512,            {
3513,"                ""description"":  ""Set Disassembly Flavor to Intel"","
3514,"                ""text"": ""-gdb-set disassembly-flavor intel"","
3515,"                ""ignoreFailures"": true"
3516,            }
3517,        ]
3518,    }
3519,
3520,]
3521,this
3522,a
3523,a.cpp
3524,b.cpp
3525,b.cpp
3526,.lib
3527,.lib
3528,error LNK2001
3529,error LNK1120
3530,error LNK2019
3531,undefined reference to
3532,struct X
3533,{
3534,   virtual void foo();
3535,};
3536,struct Y : X
3537,{
3538,   void foo() {}
3539,};
3540,struct A
3541,{
3542,   virtual ~A() = 0;
3543,};
3544,struct B: A
3545,{
3546,   virtual ~B(){}
3547,};
3548,extern int x;
3549,void foo();
3550,int main()
3551,{
3552,   x = 0;
3553,   foo();
3554,   Y y;
3555,   B b;
3556,}
3557,/home/AbiSfw/ccvvuHoX.o: In function `main':
3558,prog.cpp:(.text+0x10): undefined reference to `x'
3559,prog.cpp:(.text+0x19): undefined reference to `foo()'
3560,prog.cpp:(.text+0x2d): undefined reference to `A::~A()'
3561,/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':
3562,prog.cpp:(.text._ZN1BD1Ev[B::~B()]+0xb): undefined reference to `A::~A()'
3563,/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':
3564,prog.cpp:(.text._ZN1BD0Ev[B::~B()]+0x12): undefined reference to `A::~A()'
3565,/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo for Y]+0x8): undefined reference to `typeinfo for X'
3566,/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo for B]+0x8): undefined reference to `typeinfo for A'
3567,collect2: ld returned 1 exit status
3568,"1>test2.obj : error LNK2001: unresolved external symbol ""void __cdecl foo(void)"" (?foo@@YAXXZ)"
3569,"1>test2.obj : error LNK2001: unresolved external symbol ""int x"" (?x@@3HA)"
3570,"1>test2.obj : error LNK2001: unresolved external symbol ""public: virtual __thiscall A::~A(void)"" (??1A@@UAE@XZ)"
3571,"1>test2.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall X::foo(void)"" (?foo@X@@UAEXXZ)"
3572,1>...\test2.exe : fatal error LNK1120: 4 unresolved externals
3573,#pragma
3574,UNICODE
3575,unresolved symbol
3576,inline
3577,unresolved symbol
3578,inline
3579,virtual
3580,struct X
3581,{
3582,    virtual ~X() = 0;
3583,};
3584,struct Y : X
3585,{
3586,    ~Y() {}
3587,};
3588,int main()
3589,{
3590,    Y y;
3591,}
3592,//X::~X(){} //uncomment this line for successful definition
3593,virtual
3594,virtual
3595,struct X
3596,{
3597,    virtual void foo();
3598,};
3599,struct Y : X
3600,{
3601,   void foo() {}
3602,};
3603,int main()
3604,{
3605,   Y y; //linker error although there was no call to X::foo
3606,}
3607,X::foo()
3608,struct X
3609,{
3610,    virtual void foo() = 0;
3611,};
3612,virtual
3613,struct A
3614,{ 
3615,    ~A();
3616,};
3617,A a;      //destructor undefined
3618,struct A
3619,{ 
3620,    ~A() {}
3621,};
3622,A::~A() {}
3623,inline
3624,struct A
3625,{
3626,   void foo();
3627,};
3628,
3629,void foo() {}
3630,
3631,int main()
3632,{
3633,   A a;
3634,   a.foo();
3635,}
3636,void A::foo() {}
3637,static
3638,struct X
3639,{
3640,    static int x;
3641,};
3642,int main()
3643,{
3644,    int x = X::x;
3645,}
3646,//int X::x; //uncomment this line to define X::x
3647,static
3648,const
3649,static const
3650,g++ -o test objectFile1.o objectFile2.o -lLibraryName
3651,-l...
3652,.o
3653,.c
3654,.cpp
3655,libraryName
3656,libfoo.so
3657,-lfoo
3658,foo.lib
3659,-L‹directory›
3660,-l
3661,-L
3662,lib
3663,lib
3664,Input -> Additional Dependencies
3665,lib
3666,Linker -> General -> Additional Library Directories
3667,lib
3668,__imp_
3669,gcc main.c
3670,gcc main.c other.c
3671,extern int x;
3672,int x;
3673,extern int x;
3674,int main()
3675,{
3676,    x = 0;
3677,}
3678,//int x; // uncomment this line for successful definition
3679,void foo(); // declaration only
3680,int main()
3681,{
3682,   foo();
3683,}
3684,//void foo() {} //uncomment this line for successful definition
3685,void foo(int& x);
3686,int main()
3687,{
3688,   int x;
3689,   foo(x);
3690,}
3691,"void foo(const int& x) {} //different function, doesn't provide a definition"
3692,                          //for void foo(int& x)
3693,                          
3694,#includes
3695,A
3696,B
3697,libA
3698,libB
3699,// B.h
3700,#ifndef B_H
3701,#define B_H
3702,
3703,struct B {
3704,    B(int);
3705,    int x;
3706,};
3707,
3708,#endif
3709,
3710,// B.cpp
3711,"#include ""B.h"""
3712,B::B(int xx) : x(xx) {}
3713,
3714,// A.h
3715,"#include ""B.h"""
3716,
3717,struct A {
3718,    A(int x);
3719,    B b;
3720,};
3721,
3722,// A.cpp
3723,"#include ""A.h"""
3724,
3725,A::A(int x) : b(x) {}
3726,
3727,// main.cpp
3728,"#include ""A.h"""
3729,
3730,int main() {
3731,    A a(5);
3732,    return 0;
3733,};
3734,$ g++ -c A.cpp
3735,$ g++ -c B.cpp
3736,$ ar rvs libA.a A.o 
3737,ar: creating libA.a
3738,a - A.o
3739,$ ar rvs libB.a B.o 
3740,ar: creating libB.a
3741,a - B.o
3742,$ g++ main.cpp -L. -lB -lA
3743,./libA.a(A.o): In function `A::A(int)':
3744,A.cpp:(.text+0x1c): undefined reference to `B::B(int)'
3745,collect2: error: ld returned 1 exit status
3746,$ g++ main.cpp -L. -lA -lB
3747,$ ./a.out
3748,// src1.cpp
3749,void print();
3750,
3751,static int local_var_name; // 'static' makes variable not visible for other modules
3752,int global_var_name = 123;
3753,
3754,int main()
3755,{
3756,    print();
3757,    return 0;
3758,}
3759,// src2.cpp
3760,"extern ""C"" int printf (const char*, ...);"
3761,
3762,extern int global_var_name;
3763,//extern int local_var_name;
3764,
3765,void print ()
3766,{
3767,"    // printf(""%d%d\n"", global_var_name, local_var_name);"
3768,"    printf(""%d\n"", global_var_name);"
3769,}
3770,$ g++ -c src1.cpp -o src1.o
3771,$ g++ -c src2.cpp -o src2.o
3772,$ readelf --symbols src1.o
3773,  Num:    Value          Size Type    Bind   Vis      Ndx Name
3774,     5: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 _ZL14local_var_name # [1]
3775,     9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_var_name     # [2]
3776,"[1] - this is our static (local) variable (important - Bind has a type ""LOCAL"")"
3777,[2] - this is our global variable
3778,$ g++ src1.o src2.o -o prog
3779,$ ./prog
3780,123
3781,// src2.cpp
3782,"extern ""C"" int printf (const char*, ...);"
3783,
3784,extern int global_var_name;
3785,extern int local_var_name;
3786,
3787,void print ()
3788,{
3789,"    printf(""%d%d\n"", global_var_name, local_var_name);"
3790,}
3791,$ g++ -c src2.cpp -o src2.o
3792,$ g++ src1.o src2.o -o prog
3793,src2.o: In function `print()':
3794,src2.cpp:(.text+0x6): undefined reference to `local_var_name'
3795,collect2: error: ld returned 1 exit status
3796,$ g++ -S src1.cpp -o src1.s
3797,
3798,// src1.s
3799,look src1.s
3800,
3801,"    .file   ""src1.cpp"""
3802,    .local  _ZL14local_var_name
3803,"    .comm   _ZL14local_var_name,4,4"
3804,    .globl  global_var_name
3805,    .data
3806,    .align 4
3807,"    .type   global_var_name, @object"
3808,"    .size   global_var_name, 4"
3809,global_var_name:
3810,    .long   123
3811,    .text
3812,    .globl  main
3813,"    .type   main, @function"
3814,main:
3815,"; assembler code, not interesting for us"
3816,.LFE0:
3817,"    .size   main, .-main"
3818,"    .ident  ""GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2"""
3819,"    .section    .note.GNU-stack,"""",@progbits"
3820,.local  _ZL14local_var_name
3821,".comm   _ZL14local_var_name,4,4"
3822,    .globl  local_var_name
3823,    .data
3824,    .align 4
3825,"    .type   local_var_name, @object"
3826,"    .size   local_var_name, 4"
3827,local_var_name:
3828,    .long   456789
3829,"    .file   ""src1.cpp"""
3830,    .globl  local_var_name
3831,    .data
3832,    .align 4
3833,"    .type   local_var_name, @object"
3834,"    .size   local_var_name, 4"
3835,local_var_name:
3836,    .long   456789
3837,    .globl  global_var_name
3838,    .align 4
3839,"    .type   global_var_name, @object"
3840,"    .size   global_var_name, 4"
3841,global_var_name:
3842,    .long   123
3843,    .text
3844,    .globl  main
3845,"    .type   main, @function"
3846,main:
3847,; ...
3848,$ g++ -c src1.s -o src2.o
3849,$ readelf --symbols src1.o
3850,8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 local_var_name
3851,$ g++ src1.o src2.o -o prog
3852,$ ./prog 
3853,123456789
3854,void foo()
3855,void foo();
3856,int main()
3857,{
3858,    foo();
3859,}
3860,"extern ""C"" void foo();"
3861,int main()
3862,{
3863,    foo();
3864,}
3865,void foo()
3866,"extern ""C"" void foo();"
3867,"extern ""C"" {"
3868,"    #include ""cheader.h"""
3869,}
3870,"#ifdef __cplusplus [\n] extern""C"" { [\n] #endif"
3871,#ifdef __cplusplus [\n] } [\n] #endif
3872,[\n]
3873,"extern ""C"" { #include <myCppHeader.h> }"
3874,impl
3875,template<class T>
3876,struct X
3877,{
3878,    void foo();
3879,};
3880,
3881,int main()
3882,{
3883,    X<int> x;
3884,    x.foo();
3885,}
3886,
3887,//differentImplementationFile.cpp
3888,template<class T>
3889,void X<T>::foo()
3890,{
3891,}
3892,X::foo
3893,extern
3894,__declspec (dllimport)
3895,int foo()
3896,{
3897,    return 0;
3898,}
3899,void foo();
3900,bar()
3901,void bar()
3902,{
3903,    foo();
3904,}
3905,Project | Properties | Configuration Properties | Linker | Input | Additional Dependency
3906,__declspec(dllexport)
3907,__declspec(dllimport)
3908,#ifdef THIS_MODULE
3909,#define DLLIMPEXP __declspec(dllexport)
3910,#else
3911,#define DLLIMPEXP __declspec(dllimport)
3912,#endif
3913,THIS_MODULE
3914,DLLIMPEXP void foo();
3915,__declspec(dllexport) void foo();
3916,__declspec(dllimport) void foo();
3917,class DLLIMPEXP X
3918,{
3919,};
3920,visibility
3921,.def
3922,.def
3923,WinMain@16
3924,main()
3925,"int main(int argc, char** argv);"
3926,WinMain
3927,main
3928,#pragma
3929,"#pragma comment(lib, ""libname.lib"")"
3930,packages
3931,packagename\build\native\packagename.targets
3932,v110
3933,v110
3934,v120
3935,v110
3936,"error LNK2001: unresolved external symbol ""void __cdecl foo(void)"" (?foo@@YAXXZ)"
3937,#pragma once
3938,"-v -Wl,--verbose"
3939,"-v -Wl,-v"
3940,/VERBOSE
3941,/VERBOSE:LIB
3942,/VERBOSE
3943,libfoo
3944,libbar
3945,libfoo
3946,libbar
3947,undefined reference to
3948,#include
3949,"#include ""my_lib.h"""
3950,#include <stdio.h>
3951,
3952,void hw(void)
3953,{
3954,"    puts(""Hello World"");"
3955,}
3956,#ifndef MY_LIB_H
3957,#define MT_LIB_H
3958,
3959,extern void hw(void);
3960,
3961,#endif
3962,#include <my_lib.h>
3963,
3964,int main()
3965,{
3966,    hw();
3967,    return 0;
3968,}
3969,$ gcc -c -o my_lib.o my_lib.c
3970,$ ar rcs libmy_lib.a my_lib.o
3971,$ gcc -I. -c -o eg1.o eg1.c
3972,libmy_lib.a
3973,$ gcc -o eg1 -L. -lmy_lib eg1.o 
3974,eg1.o: In function `main':
3975,eg1.c:(.text+0x5): undefined reference to `hw'
3976,collect2: error: ld returned 1 exit status
3977,$ gcc -o eg1 -I. -L. -lmy_lib eg1.c
3978,/tmp/ccQk1tvs.o: In function `main':
3979,eg1.c:(.text+0x5): undefined reference to `hw'
3980,collect2: error: ld returned 1 exit status
3981,libz
3982,#include <zlib.h>
3983,#include <stdio.h>
3984,
3985,int main()
3986,{
3987,"    printf(""%s\n"",zlibVersion());"
3988,    return 0;
3989,}
3990,$ gcc -c -o eg2.o eg2.c
3991,libz
3992,$ gcc -o eg2 -lz eg2.o 
3993,eg2.o: In function `main':
3994,eg2.c:(.text+0x5): undefined reference to `zlibVersion'
3995,collect2: error: ld returned 1 exit status
3996,$ gcc -o eg2 -I. -lz eg2.c
3997,/tmp/ccxCiGn7.o: In function `main':
3998,eg2.c:(.text+0x5): undefined reference to `zlibVersion'
3999,collect2: error: ld returned 1 exit status
4000,pkg-config
4001,$ gcc -o eg2 $(pkg-config --libs zlib) eg2.o 
4002,eg2.o: In function `main':
4003,eg2.c:(.text+0x5): undefined reference to `zlibVersion'
4004,$ gcc -o eg1 eg1.o -L. -lmy_lib
4005,$ ./eg1 
4006,Hello World
4007,$ gcc -o eg2 eg2.o -lz
4008,$ ./eg2 
4009,1.2.8
4010,pkg-config
4011,$ gcc -o eg2 eg2.o $(pkg-config --libs zlib) 
4012,$ ./eg2
4013,1.2.8
4014,my_lib.a
4015,-lmy_lib
4016,./libmy_lib.a
4017,libmy_lib.a
4018,libmy_lib.a
4019,my_lib.o
4020,my_lib.o
4021,hw
4022,my_lib.o
4023,hw
4024,hw
4025,my_lib.o
4026,hw
4027,hw
4028,$ gcc -o eg1 -L. -lmy_lib eg1.o
4029,eg1.o
4030,-lmy_lib
4031,eg1.o
4032,hw
4033,eg1.o
4034,my_lib.o
4035,libmy_lib.a
4036,eg1.o
4037,hw
4038,hw
4039,hw
4040,libz
4041,main
4042,gcc
4043,g++
4044,gfortran
4045,ld
4046,-lz
4047,/usr/lib/x86_64-linux-gnu/libz.so
4048,libz
4049,libz
4050,libz
4051,libz
4052,libz
4053,libz
4054,zlibVersion
4055,eg2.c
4056,libz
4057,gcc -o eg2 -lz eg2.o
4058,-lz
4059,eg2.o
4060,libz
4061,eg2.o
4062,zlibVersion
4063,pkg-config
4064,gcc -o eg2 $(pkg-config --libs zlib) eg2.o
4065,gcc -o eg2 -lz eg2.o
4066,gcc -o eg2 -lz eg2.o
4067,-lfoo
4068,/some/where/libfoo.a
4069,/some/where/libfoo.so
4070,$ gcc -o eg1 -I. -L. -lmy_lib eg1.c
4071,eg1.c
4072,libmy_lib.a
4073,gcc
4074,$ gcc -I. -c -o eg1.o eg1.c
4075,$ gcc -o eg1 -L. -lmy_lib eg1.o
4076,eg1.o
4077,/tmp/ccQk1tvs.o: In function `main'
4078,eg1.o: In function `main':
4079,INPUT (libtbb.so.2)
4080,cp libtbb.so.2 libtbb.so
4081,-ltbb
4082,/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2
4083,template <typename T>
4084,class Foo {
4085,"    friend std::ostream& operator<< (std::ostream& os, const Foo<T>& a);"
4086,};
4087,operator<<
4088,T
4089,Foo
4090,operator<<
4091,Foo<int>
4092,"std::ostream& operator<< (std::ostream& os, const Foo<int>& a) {/*...*/}"
4093,Foo
4094,// forward declare the Foo
4095,template <typename>
4096,class Foo;
4097,
4098,// forward declare the operator <<
4099,template <typename T>
4100,"std::ostream& operator<<(std::ostream&, const Foo<T>&);"
4101,
4102,template <typename T>
4103,class Foo {
4104,"    friend std::ostream& operator<< <>(std::ostream& os, const Foo<T>& a);"
4105,    // note the required <>        ^^^^
4106,    // ...
4107,};
4108,
4109,template <typename T>
4110,"std::ostream& operator<<(std::ostream&, const Foo<T>&)"
4111,{
4112,  // ... implement the operator
4113,}
4114,Foo
4115,operator<< <int>
4116,Foo<int>
4117,template <typename T>
4118,class Foo {
4119,    template <typename T1>
4120,"    friend std::ostream& operator<<(std::ostream& os, const Foo<T1>& a);"
4121,    // ...
4122,};
4123,operator<<
4124,template <typename T>
4125,class Foo {
4126,"    friend std::ostream& operator<<(std::ostream& os, const Foo& a)"
4127,    { /*...*/ }
4128,    // ...
4129,};
4130,warning: friend declaration 'std::ostream& operator<<(...)' declares a non-template function [-Wnon-template-friend]
4131,"note: (if this is not what you intended, make sure the function template has already been declared and add <> after the function name here)"
4132,// header1.h
4133,typedef int Number;
4134,void foo(Number);
4135,
4136,// header2.h
4137,typedef float Number;
4138,void foo(Number); // this only looks the same lexically
4139,header1.h
4140,header2.h
4141,graphics.lib
4142,main.exe
4143,common_math.h
4144,// graphics.lib    
4145,"#include ""common_math.h"" "
4146,   
4147,void draw(vec3 p) { ... } // vec3 comes from common_math.h
4148,// main.exe
4149,"#include ""other/common_math.h"""
4150,"#include ""graphics.h"""
4151,
4152,int main() {
4153,    draw(...);
4154,}
4155,common_math.h
4156,draw()
4157,vec3
4158,UNICODE
4159,TCHAR
4160,wchar_t
4161,UNICODE
4162,TCHAR
4163,char
4164,UNICODE
4165,_UNICODE
4166,T
4167,LPTSTR
4168,LPCTSTR
4169,UNICODE
4170,UNICODE
4171,TCHAR
4172,char
4173,wchar_t
4174,char
4175,wchar_t
4176,std::basic_string<>
4177,TCHAR
4178,std::basic_string<TCHAR>
4179,UNICODE
4180,_UNICODE
4181,#define UNICODE
4182,#define _UNICODE
4183,/DUNICODE /D_UNICODE
4184,const
4185,const
4186,extern
4187,static
4188,// file1.cpp
4189,"const int test = 5;    // in C++ same as ""static const int test = 5"""
4190,int test2 = 5;
4191,
4192,// file2.cpp
4193,extern const int test;
4194,extern int test2;
4195,
4196,void foo()
4197,{
4198," int x = test;   // linker error in C++ , no error in C"
4199, int y = test2;  // no problem
4200,}
4201,extern const int test;
4202,extern int test2;
4203,const
4204,extern
4205,std::filesystem::path
4206,#if (defined _GLIBCXX_EXPERIMENTAL_FILESYSTEM) //is the included filesystem library experimental? (C++14 and newer: <experimental/filesystem>)
4207,using path_t = std::experimental::filesystem::path;
4208,#elif (defined _GLIBCXX_FILESYSTEM) //not experimental (C++17 and newer: <filesystem>)
4209,using path_t = std::filesystem::path;
4210,#endif
4211,g++ -g -std=c++17 -c main.cpp
4212,g++ -g -std=c++17 -c file.cpp
4213,g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs
4214,path_t
4215,std::filesystem::path
4216,std::experimental::filesystem::path
4217,-fvisibility=hidden
4218,"__attribute__ ((visibility (""default"")))"
4219,# -D shows (global) dynamic symbols that can be used from the outside of XXX.so
4220,nm -D XXX.so | grep MY_SYMBOL 
4221,nm
4222,t
4223,nm XXX.so
4224,00000000000005a7 t HIDDEN_SYMBOL
4225,00000000000005f8 T VISIBLE_SYMBOL
4226,nm
4227,-C
4228,DLL_PUBLIC
4229,"#define DLL_PUBLIC __attribute__ ((visibility (""default"")))"
4230,
4231,DLL_PUBLIC int my_public_function(){
4232,  ...
4233,}
4234,#ifdef BUILDING_DLL
4235,    #define DLL_PUBLIC __declspec(dllexport) 
4236,#else
4237,    #define DLL_PUBLIC __declspec(dllimport) 
4238,#endif
4239,-fvisibility=hidden
4240,nm
4241,>>> objdump -t XXXX.o | grep hidden
4242,0000000000000000 g     F .text  000000000000000b .hidden HIDDEN_SYMBOL1
4243,000000000000000b g     F .text  000000000000000b .hidden HIDDEN_SYMBOL2
4244,inline
4245,"#include ""gum.h"""
4246,"#include ""foo.h"""
4247,
4248,int main()
4249,{
4250,    gum();
4251,    foo f;
4252,    f.bar();
4253,    return 0;
4254,}
4255,#pragma once
4256,
4257,struct foo {
4258,    void bar() const;
4259,};
4260,#pragma once
4261,
4262,extern void gum();
4263,"#include ""foo.h"""
4264,#include <iostream>
4265,
4266,inline /* <- wrong! */ void foo::bar() const {
4267,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4268,}
4269,"#include ""gum.h"""
4270,#include <iostream>
4271,
4272,inline /* <- wrong! */ void gum()
4273,{
4274,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4275,}
4276,gum
4277,foo::bar
4278,inline
4279,gum
4280,gum
4281,gum
4282,gum
4283,gum
4284,gum
4285,gum.cpp
4286,gum.o
4287,gum
4288,gum
4289,gum.o
4290,main.o
4291,gum
4292,g++ -c  main.cpp foo.cpp gum.cpp
4293,$ g++ -o prog main.o foo.o gum.o
4294,main.o: In function `main':
4295,main.cpp:(.text+0x18): undefined reference to `gum()'
4296,main.cpp:(.text+0x24): undefined reference to `foo::bar() const'
4297,collect2: error: ld returned 1 exit status
4298,gum
4299,inline
4300,gum
4301,gum
4302,inline
4303,"#include ""foo.h"""
4304,#include <iostream>
4305,
4306,void foo::bar() const {
4307,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4308,}
4309,"#include ""gum.h"""
4310,#include <iostream>
4311,
4312,void gum()
4313,{
4314,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4315,}
4316,$ g++ -c  main.cpp foo.cpp gum.cpp
4317,imk@imk-Inspiron-7559:~/develop/so/scrap1$ g++ -o prog main.o foo.o gum.o
4318,imk@imk-Inspiron-7559:~/develop/so/scrap1$ ./prog
4319,void gum()
4320,void foo::bar() const
4321,#pragma once
4322,#include <iostream>
4323,
4324,struct foo {
4325,    void bar() const  { // In-class definition is implicitly inline
4326,        std::cout << __PRETTY_FUNCTION__ << std::endl;
4327,    }
4328,};
4329,// Alternatively...
4330,#if 0
4331,struct foo {
4332,    void bar() const;
4333,};
4334,inline void foo::bar() const  {
4335,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4336,}
4337,#endif
4338,#pragma once
4339,#include <iostream>
4340,
4341,inline void gum() {
4342,    std::cout << __PRETTY_FUNCTION__ << std::endl;
4343,}
4344,foo.cpp
4345,gum.cpp
4346,$ g++ -c main.cpp
4347,$ g++ -o prog main.o
4348,$ ./prog
4349,void gum()
4350,void foo::bar() const
4351,inline
4352,inline
4353,                 ~~~
4354,bin
4355,bin/
4356,gcc
4357,bin/
4358,C:\mingw64\bin
4359,Environment Variables
4360,Path
4361,gcc --version
4362,gcc
4363,bin/
4364,free(STRUCTPOINTER->thing1->thing2)
4365,free((*STRUCTPOINTER).(*thing1).thing2)
4366,free((*STRUCTPOINTER).thing1.thing2)
4367,free((*(*ptr).thing1).thing2
4368,free((*(*ptr).thing1).thing2);
4369,STRUCTPOINTER
4370,ptr
4371,*ptr
4372,ptr
4373,(*ptr).thing1
4374,*(*ptr).thing1
4375,(*(*ptr).thing1).thing2
4376,#include <stdio.h> 
4377,int main(){
4378,"    int n,i,m;"
4379,"    scanf(""%d"",&n);"
4380,    int array[n];
4381,"    for (i = 0; i < n; i++) scanf(""%d"", &array[i]);"
4382,"    for (m=0;m<n;m++) printf(""%d"",array[m]);"
4383,    fflush(stdout);
4384,}
4385, 5
4386, 3 4 5 6 7
4387,gcc {file name}
4388,./a.out
4389,for
4390,n
4391,printf
4392,fflush(stdout):
4393,scanf
4394,scanf
4395,2
4396,1
4397,2
4398,12
4399,2
4400,1
4401,2
4402,fgets
4403,sscanf
4404,scanf
4405,int main(void)
4406,{
4407,"    int n,i,m;"
4408,    char buff[64];
4409,"    if(!fgets(buff, sizeof(buff), stdin)) { /* error handling */}"
4410,"    if(sscanf(buff, ""%d"", &n) != 1) { /* error handling */}"
4411,    int array[n];
4412,    for (i = 0; i < n; i++) 
4413,    {
4414,"        if(!fgets(buff, sizeof(buff), stdin)) { /* error handling */}"
4415,"        if(sscanf(buff, ""%d"", &array[i]) != 1) { /* error handling */}"
4416,    }
4417,    
4418,"    for (m=0;m<n;m++) printf(""%d "", array[m]);"
4419,}
4420,#include <stdio.h>
4421,#include <string.h>
4422,#include <stdarg.h>
4423,
4424,#define ERR_BUFFER_SIZE 4096
4425,
4426,"void errPrint(const char *format, ...)"
4427,{
4428,    va_list argptr;
4429,"    va_start(argptr, format);"
4430,
4431,    char buf[ERR_BUFFER_SIZE];
4432,"    vsnprintf(buf, sizeof(buf), format, argptr);"
4433,"    fprintf(stderr, ""%s"", buf);"
4434,    
4435,    va_end(argptr);
4436,}
4437,"void errExit(const char *format, ...)"
4438,{
4439,    errPrint(format);
4440,    exit(EXIT_FAILURE);
4441,}
4442,"errExit(""hello,%s,%s,%s"", ""arg1"",""arg2"", ""arg3"");"
4443,"hello,arg1,arg2,arg3"
4444,Segmentation fault
4445,"void errExit(const char *format, ...)"
4446,{
4447,    char buf[4096];//added
4448,"    strcpy(buf, format);//added"
4449,    
4450,    errPrint(format);
4451,    exit(EXIT_FAILURE);
4452,}
4453,format
4454,errPrint()
4455,va_start()
4456,errExit()
4457,errPrint()
4458,"verrPrint(const char *format, va_list ap)"
4459,errExit()
4460,"errPrint(const char *format, ...)"
4461,verrPrint()
4462,", ...)"
4463,va_list args)
4464,errExit()
4465,va_list
4466,vsnprintf
4467,#include <stdarg.h>
4468,#include <stdio.h>
4469,#include <stdlib.h>
4470,#include <string.h>
4471,
4472,#define ERR_BUFFER_SIZE 4096
4473,
4474,"void verrPrint(const char *format, va_list ap) {"
4475,    char buf[ERR_BUFFER_SIZE];
4476,"    vsnprintf(buf, sizeof(buf), format, ap);"
4477,"    fprintf(stderr, ""%s"", buf);"
4478,}
4479,
4480,"void errPrint(const char *format, ...) {"
4481,    va_list ap;
4482,"    va_start(ap, format);"
4483,"    verrPrint(format, ap);"
4484,    va_end(ap);
4485,}
4486,
4487,"void errExit(const char *format, ...) {"
4488,    va_list ap;
4489,"    va_start(ap, format);"
4490,"    verrPrint(format, ap);"
4491,    va_end(ap);
4492,    exit(EXIT_FAILURE);
4493,}
4494,
4495,int main(void) {
4496,"    errPrint(""What is the meaning of %s\n"", ""life?"");"
4497,"    errExit(""%d\n"", 42);"
4498,    return 0;
4499,}
4500,va_arg()
4501,va_list()
4502,va_list
4503,va_list
4504,va_arg
4505,#include <stdarg.h>
4506,#include <stdio.h>
4507,#include <stdlib.h>
4508,#include <string.h>
4509,
4510,#define ERR_BUFFER_SIZE 4096
4511,
4512,"void errPrint(const char *format, va_list arg_list)"
4513,{
4514,    char buf[ERR_BUFFER_SIZE];
4515,"    vsnprintf(buf, sizeof(buf), format, arg_list);"
4516,"    fprintf(stderr, ""%s"", buf);"
4517,}
4518,
4519,"void errExit(const char *format, va_list arg_list)"
4520,{
4521,"    errPrint(format, arg_list);"
4522,    exit(EXIT_FAILURE);
4523,}
4524,
4525,"void v_exec(void (*func)(const char *, va_list), const char *format, ...)"
4526,{
4527,    va_list arg_list;
4528,"    va_start(arg_list, format);"
4529,
4530,"    func(format, arg_list);"
4531,
4532,    va_end(arg_list);
4533,}
4534,
4535,int main(void) 
4536,{ 
4537,"    v_exec(errExit,""%s%d"", ""hello"",520);"
4538,    return 0;
4539,}
4540,errExit
4541,errPrint(format);
4542,format
4543,char*
4544,errPrint
4545,va_list argptr
4546,vsnprintf
4547,"void foo(char *a, char *b, char *c, char *d, char *f);"
4548,"int  bar(char *a, char *b, char *c, char *d, char *f)"
4549,{
4550,"    foo(a, b, c, d, f);"
4551,"    return 1;   // some code after the call, so it can't compile to a tailcall"
4552,}
4553,# GCC12 -O3
4554,bar:
4555,"    # incoming args are in RDI, RSI, RDX, RCX, R8, R9  in that order"
4556,"    # same place a callee will look for them, so passing them on is trivial"
4557,"        sub     rsp, 8        # re-align the stack so RSP%16 == 0"
4558,        call    foo
4559,"        mov     eax, 1        # return-value register = 1"
4560,"        add     rsp, 8        # restore the stack pointer"
4561,        ret                   # pop return address into RIP
4562,errExit
4563,errExit:
4564,"        sub     rsp, 8"
4565,"        xor     eax, eax       # Variadic functions get AL = # of args passed in XMM regs"
4566,        call    errPrint
4567,"        mov     edi, 1"
4568,        call    exit           # GCC knows exit() is noreturn
4569,call errPrint
4570,strcpy
4571,call errPrint
4572,call strcpy
4573,gcc -m32
4574,vsnprintf
4575,%s
4576,errExit
4577,errExit
4578,%p
4579,...
4580,va_list
4581,call errPrint
4582,int subtractProductAndSum(int n){
4583,
4584,"    int k , j=n , count=0 , add=0 , multiply=1;"
4585,  
4586,    while(j>0){
4587,    
4588,        j=j/10;
4589,        count++;
4590,    
4591,    }
4592,
4593,    int p=count;
4594,    int arr[p];
4595,        
4596,    while(n>0){
4597,        k=n%10;
4598,        n=n/10;
4599,        
4600,        if(p>0){        
4601,            arr[p-1]=k;
4602,            p--;
4603,        }
4604,    }
4605,    for(int i = 0; i <count ;i++){
4606,      add=add+arr[i];
4607,      multiply=multiply*arr[i];
4608,    }
4609,    
4610,    int t=multiply-add;
4611,"    printf(""%d"", t);"
4612,    
4613,}
4614,int
4615,void
4616,return
4617,"void printData(int total_trees,int burned){"
4618,"  printf(""Before printing data\n"");"
4619,  float percentBurned = (float)burned / (total_trees+burned)*100;
4620,  
4621,"  printf(""total burned: %d (%.1f\%)\n"",burned,percentBurned);"
4622,"  printf(""trees left: %d\n"", total_trees);"
4623,"  // printf(""trees left: %d\n"", total_trees);"
4624,"  printf(""After printing data"");"
4625,}
4626,*** stack smashing detected ***: terminated
4627,"printf(""trees left: %d\n"", total_trees);"
4628,\%
4629,%%
4630,"""trees left:"""
4631,"""After printing data"""
4632,stdout
4633,stderr
4634,float percentBurned
4635,double percentBurned
4636,%
4637,%%
4638,\%
4639,gcc -Wall
4640,valgrind
4641,#include <stdio.h>
4642,#include <stdlib.h>
4643,#include <string.h>
4644,
4645,struct stack {
4646,    int size;
4647,    int top;
4648,    char *arr;
4649,};
4650,
4651,"void push(struct stack *st,char x) {"
4652,    if (st->top >= st->size - 1) {
4653,"        printf(""stack is full"");"
4654,    }
4655,    else {
4656,        st->top++;
4657,        st->arr[st->top] = x;
4658,    }
4659,}
4660,
4661,char pop(struct stack *st) {
4662,    char x;
4663,
4664,    if (st->top < 0) {
4665,"        printf(""stack is empty"");"
4666,    }
4667,    else {
4668,        x = st->arr[st->top];
4669,        st->top--;
4670,    }
4671,
4672,    return x;
4673,}
4674,
4675,int isempty(struct stack st) {
4676,    if (st.top < 0) {
4677,        return 1;
4678,    }
4679,    else
4680,        return 0;
4681,}
4682,
4683,void display(struct stack st) {
4684,    int i;
4685,    for (i = st.top; i >= 0; i--) {
4686,"        printf(""%c "", st.arr[i]);"
4687,    }
4688,
4689,"    printf(""\n"");"
4690,}
4691,
4692,int balanced(char *expr) {
4693,    int i;
4694,    struct stack st;
4695,    st.size = strlen(expr);
4696,    st.top = -1;
4697,    st.arr = (char *)malloc(st.size * sizeof(char));
4698,    
4699,    for (i = 0; expr[i] != '\0'; i++) {
4700,        if (expr[i] = '(') {
4701,"            push(&st, expr[i]);"
4702,        }
4703,        else if (expr[i] = ')') {
4704,            if (st.top < 0) return false;
4705,            else pop(&st);
4706,        }
4707,    }
4708,
4709,    if (st.top < 0) return 1;
4710,    else return 0;
4711,}
4712,
4713,int main() {
4714,"    char *expr = ""((a+b))"";"
4715,"    printf(""%d"", balanced(expr));"
4716,
4717,    return 0;
4718,}
4719,   for (i = 0; expr[i] != '\0'; i++) {
4720,       if (expr[i] = '(') {
4721,"           push(&st, expr[i]);"
4722,       }
4723,       else if (expr[i] = ')') {
4724,           if (st.top < 0) return false;
4725,           else pop(&st);
4726,       }
4727,   }
4728,=
4729,==
4730,'('
4731,<stdbool.h>
4732,true
4733,false
4734,1
4735,(
4736,)
4737,0
4738,)
4739,0
4740,assignment
4741,test for equality
4742,#include <stdio.h>
4743,#include <stdbool.h>
4744,
4745,int main() {
4746,"    char *str = ""{(foo)({gib(bar)gab;}) ((())) []Quick brown fox "";"
4747,
4748,    char stack[ 64 ] = { 0 };
4749,    int stkInd = 1;
4750,    bool good = true;
4751,    for( char *cp = str; *cp; cp++ ) {
4752,        switch( *cp ) {
4753,            case '(': stack[ stkInd++ ] = ')'; break;
4754,            case '{': stack[ stkInd++ ] = '}'; break;
4755,            case '[': stack[ stkInd++ ] = ']'; break;
4756,            case '<': stack[ stkInd++ ] = '>'; break;
4757,
4758,            case ')':
4759,            case '}':
4760,            case ']':
4761,            case '>': good = *cp == stack[ --stkInd ]; break;
4762,        }
4763,
4764,        if(  stkInd >= sizeof stack ) {
4765,"            printf( ""Stack Full!\n"" );"
4766,            return -1;
4767,        }
4768,
4769,        if( !good ) {
4770,"            printf( ""%s\n"", str );"
4771,"            printf( ""%*s^---\n"", cp - str, "" "" );"
4772,"            printf( ""Unmatched '%c'\n"", *cp );"
4773,            return -1;
4774,        }
4775,    }
4776,
4777,    while( stkInd > 1 ) {
4778,        char c = stack[ --stkInd ];
4779,        switch( c ) {
4780,            case ')': c = '('; break;
4781,            case '}': c = '{'; break;
4782,            case ']': c = '['; break;
4783,            case '>': c = '<'; break;
4784,        }
4785,"        printf( ""Unpairable %c\n"", c );"
4786,    }
4787,
4788,    return 0;
4789,}
4790,isempty( )
4791,display( )
4792,if(  stkInd >= sizeof stack )
4793,switch
4794,realloc( )
4795,:-)
4796,:-)
4797,gcc $(pkg-config --cflags gtk4) -o hello-world-gtk hello-world-gtk.c $(pkg-config --libs gtk4) 
4798,Package gtk4 was not found in the pkg-config search path.
4799,Perhaps you should add the directory containing `gtk4.pc'
4800,to the PKG_CONFIG_PATH environment variable
4801,No package 'gtk4' found
4802,Package gtk4 was not found in the pkg-config search path.
4803,Perhaps you should add the directory containing `gtk4.pc'
4804,to the PKG_CONFIG_PATH environment variable
4805,No package 'gtk4' found
4806,hello-world-gtk.c:1:10: fatal error: 'gtk/gtk.h' file not found
4807,#include <gtk/gtk.h>
4808,         ^~~~~~~~~~~
4809,1 error generated.
4810,#include <gtk/gtk.h>
4811,#include <gtk-2.0/gtk/gtk.h>
4812,Package gtk4 was not found in the pkg-config search path.
4813,Perhaps you should add the directory containing `gtk4.pc'
4814,to the PKG_CONFIG_PATH environment variable
4815,No package 'gtk4' found
4816,Package gtk4 was not found in the pkg-config search path.
4817,Perhaps you should add the directory containing `gtk4.pc'
4818,to the PKG_CONFIG_PATH environment variable
4819,No package 'gtk4' found
4820,In file included from hello-world-gtk.c:1:
4821,/usr/local/include/gtk-2.0/gtk/gtk.h:32:10: fatal error: 'gdk/gdk.h' file not
4822,      found
4823,#include <gdk/gdk.h>
4824,         ^~~~~~~~~~~
4825,1 error generated.
4826,-I/usr/include/gtk-2.0 -lgtk2.0
4827,pD3D
4828,LPDIRECT3D9EX
4829,RegisterSoftwareDevice
4830,C:\Windows\System32\d3d9.dll
4831,c:\Program Files (x86)\Windows Kits\8.1\lib\winv6.3\um\x64\d3d9.lib
4832,C:\Program Files (x86)\Windows Kits\8.1\Include\shared\d3d9.h
4833,push_swap
4834,        |helpers/        -> *.c files
4835,        |format_parsing/ -> *.c files
4836,"        |push_swaph/     -> push_swap.c, sort_a.c"
4837,"        |libft/          -> *.c files, libft.h"
4838,"        |ft_printf/      -> *.c files, libftprintf.h"
4839,        |includes/       -> header_push_swap.h          
4840,______________________________________________________
4841,NAME         = push_swap
4842,LIBFT        = libft.a
4843,PRINTF       = libftprintf.a
4844,HEADER       = includes/header_push_swap.h
4845,LIBFTHEADER  = libft/libft.h
4846,PRINTFHEADER = ft_printf/includes/header.h
4847,OBJS_DIR     = objs/
4848,SRC          = $(wildcard ./format_parsing/*.c) \
4849,        $(wildcard ./helpers/*.c) \
4850,        $(wildcard ./push_swaph/*.c)
4851,OBJS         = $(SRC:.c=.o)
4852,CC           = gcc
4853,FLAGS        = -Wall -Wextra -Werror
4854,
4855,
4856,all: $(NAME)
4857,
4858,$(NAME) : $(LIBFTHEADER) $(PRINTFHEADER) $(LIBFT) $(PRINTF) $(OBJS)
4859,    @$(CC) $(FLAGS) $(OBJS) -o $(NAME)
4860,
4861,$(LIBFT) :
4862,    @cd ./libft && make
4863,
4864,$(PRINTF) :
4865,    @cd ./ft_printf/ && make
4866,
4867,
4868,clean :
4869,    @rm -rf $(OBJS_DIR)
4870,    @rm -f $(OBJS)
4871,
4872,fclean : clean
4873,    @rm -rf $(OBJS)
4874,    @cd ./libft/ && make fclean
4875,    @cd ./ft_printf/ && make fclean
4876,/usr/bin/ld: ./format_parsing/parsing.o: in function `stack_nums_counter':
4877,parsing.c:(.text+0x3b): undefined reference to `ft_strlen'
4878,/usr/bin/ld: ./helpers/actions1.o: in function `pa':
4879,actions1.c:(.text+0x60): undefined reference to `ft_printf'
4880,/usr/bin/ld: ./helpers/actions1.o: in function `pb':
4881,actions1.c:(.text+0xc9): undefined reference to `ft_printf'
4882,/usr/bin/ld: ./helpers/actions1.o: in function `ra':
4883,actions1.c:(.text+0x156): undefined reference to `ft_printf'
4884,/usr/bin/ld: ./helpers/actions1.o: in function `rb':
4885,actions1.c:(.text+0x1e3): undefined reference to `ft_printf'
4886,/usr/bin/ld: ./helpers/actions2.o: in function `rr':
4887,actions2.c:(.text+0x35): undefined reference to `ft_printf'
4888,/usr/bin/ld: ./helpers/actions2.o:actions2.c:(.text+0x8e): more undefined references to `ft_printf' follow
4889,/usr/bin/ld: ./helpers/helpers.o: in function `__store__':
4890,helpers.c:(.text+0x4c): undefined reference to `ft_split'
4891,/usr/bin/ld: helpers.c:(.text+0xd9): undefined reference to `ft_atoi'
4892,/usr/bin/ld: ./helpers/helpers.o: in function `__check__collection':
4893,helpers.c:(.text+0x342): undefined reference to `ft_printf'
4894,collect2: error: ld returned 1 exit status
4895,make: *** [Makefile:18: push_swap] Error 1
4896,Makefile
4897,@
4898,make -s
4899,OBJS = $(SRC:.c=.o)
4900,"OBJS = $(addprefix $(OBJS_DIR), $(OBJS))"
4901,wildcard
4902,.PHONY: all clean
4903,NAME = push_swap
4904,VPATH = src
4905,
4906,all: $(NAME)
4907,
4908,clean:
4909,    rm -f objs/* $(MAME)
4910,
4911,$(NAME): objs/push_swap.o
4912,
4913,objs/%.o: %.c
4914,    $(CC) -o $@ $<
4915,mkdir objs src
4916,#include <stdio.h>
4917,  
4918,int main(void) {
4919,"    printf(""ok\n"");"
4920,    return 1;
4921,}
4922,make
4923,$ ls objs/* push_swap
4924,ls: cannot access 'objs/*': No such file or directory
4925,ls: cannot access 'push_swap': No such file or directory
4926,$ make
4927,$ ls objs/* push_swap
4928,objs/push_swap.o
4929,push_swap
4930,#include <stdio.h>
4931,#include <stdlib.h>
4932,
4933,#define Size_MainFuncArray 5            // Constant
4934,
4935,                                 // Data that needs to be inside my txt file:
4936,                                // StudentData.txt: Jane 55 51 78
4937,struct Student {                        // Lungelo 69 84 75
4938,    char StudentName[10];               // Greg 51 44 52
4939,    int StudentMarks[3];                // Thando 23 78 61
4940,    float StudentAverage;               // Bret 44 33 29
4941,};
4942,
4943,typedef struct Student Student;
4944,
4945,                      // Function Prototypes
4946,int DisplayMenu(void);
4947,"void Read_Data(Student Arr[], int Size);"
4948,"void Calculate_StudentAverage(Student Arr[], int Size);"
4949,"void Display_Data(Student Arr[], int Size);"
4950,"void Write_Graph(Student Arr[], int Size);  // I am not being able to identify"
4951,
4952,"                                               // The type like: int, flot etc."
4953,                               // All are just specified as Student Arr[].
4954,                               // My lecture wants it like this
4955,
4956,                         // Main Function
4957,int
4958,main(void)
4959,{
4960,    int choice;
4961,    Student ESG206B[Size_MainFuncArray];    // How do I use this array?
4962,
4963,    choice = DisplayMenu();
4964,
4965,"    printf(""\nPress any key to continue...\n"");"
4966,    getch();
4967,"    system(""cls"");"
4968,
4969,    return 0;
4970,}
4971,
4972,     // Function Definitions
4973,int
4974,DisplayMenu(void)
4975,{
4976,    int Select;
4977,
4978,"    printf(""************************************\n"");"
4979,"    printf(""*    Welcome to Student Stats      *\n"");"
4980,"    printf(""*    Student Number: 123456789     *\n"");"
4981,"    printf(""************************************\n"");"
4982,
4983,"    printf(""\n1. Load Data and Calculate Average\n"");"
4984,"    printf(""2. Dispaly Student Data\n"");"
4985,"    printf(""3. Save Graph\n"");"
4986,"    printf(""4. Exit\n"");"
4987,"    printf(""Choice: "");"
4988,    fflush(stdin);
4989,"    scanf(""%d"", &Select);"
4990,
4991,    return Select;
4992,}
4993,
4994,void
4995,"Read_Data(Student Arr[], int Size)      // I am not being able to finish this"
4996,{                                       // functions definition
4997,
4998,}
4999,
5000,void
5001,"Calculate_StudentAverage(Student Arr[], int Size)"
5002,{
5003,
5004,}
5005,
5006,void
5007,"Display_Data(Student Arr[], int Size)"
5008,{
5009,
5010,}
5011,
5012,void
5013,"Write_Graph(Student Arr[], int Size)"
5014,{
5015,
5016,}
5017,printf
5018,scanf
5019,do...while
5020,1 <= input <= 4
5021,int DisplayMenu(void)
5022,{
5023,    int Select;
5024,
5025,"    printf(""************************************\n"");"
5026,"    printf(""*    Welcome to Student Stats      *\n"");"
5027,"    printf(""*    Student Number: 123456789     *\n"");"
5028,"    printf(""************************************\n"");"
5029,
5030,    do
5031,    {
5032,"        printf(""\n1. Load Data and Calculate Average\n"");"
5033,"        printf(""2. Dispaly Student Data\n"");"
5034,"        printf(""3. Save Graph\n"");"
5035,"        printf(""4. Exit\n"");"
5036,"        printf(""Choice: "");"
5037,        fflush(stdin);
5038,"        scanf(""%d"", &Select);"
5039,        if (Select < 1 || Select > 4)
5040,        {
5041,"            printf(""Please select a valid choice.\n"");"
5042,        }
5043,    } while (Select < 1 || Select > 4);
5044,
5045,    return Select;
5046,}
5047,switch
5048,choice = DisplayMenu();
5049,switch (choice)
5050,{
5051,case 1:
5052,    // do smth for 1
5053,    break;
5054,case 2:
5055,    // do smth for 2
5056,    break;
5057,case 3:
5058,    // do smth for 3
5059,    break;
5060,case 4:
5061,    // do smth for 4
5062,    break;
5063,default:
5064,    break;
5065,}
5066,while()
5067,int
5068,main(void)
5069,{
5070,    Student ESG206B[Size_MainFuncArray];
5071,
5072,"    printf(""************************************\n"");"
5073,"    printf(""*    Welcome to Student Stats      *\n"");"
5074,"    printf(""*    Student Number: 123456789     *\n"");"
5075,"    printf(""************************************\n"");"
5076,
5077,"    while( 1 ) { // infinite loop, ends with user input = 4"
5078,        putchar( '\n' );
5079,"        printf(""1. Load Data and Calculate Average\n"");"
5080,"        printf(""2. Dispaly Student Data\n"");"
5081,"        printf(""3. Save Graph\n"");"
5082,"        printf(""4. Exit\n"");"
5083,"        printf(""Choice: "");"
5084,        // fflush(stdin); // DO NOT DO This!
5085,
5086,        int choice = 0; // declare variables close to their use
5087,"        scanf( ""%d"", &choice );"
5088,        // should check return value from scanf
5089,
5090,        switch( choice ) {
5091,            case 1:
5092,"                Read_Data( ESG206B, Size_MainFuncArray );"
5093,"                Calculate_StudentAverage( ESG206B, Size_MainFuncArray );"
5094,                break;
5095,
5096,            case 2:
5097,"                Display_Data( ESG206B, Size_MainFuncArray );"
5098,                break;
5099,
5100,            case 3:
5101,"                Write_Graph( ESG206B, Size_MainFuncArray );"
5102,                break;
5103,
5104,            case 4:
5105,"                printf( ""Bye-bye\n"" );"
5106,                return 0; // program ends
5107,
5108,            default:
5109,"                printf( ""Invalid selection\n"" );"
5110,                break;
5111,        }
5112,    }
5113,
5114,    return 0;
5115,}
5116,
5117,/*
5118, * The unwritten code is still yours to write.
5119, */
5120,main()
5121,dequeue()
5122,enqueue(2)
5123,dequeue()
5124,enqueue(5)
5125,display()
5126,temp -> data
5127,#include <stdio.h>
5128,#include <stdlib.h>
5129,
5130,struct queue
5131,{
5132,    int data;
5133,    struct queue *next;
5134,};
5135,"struct queue *QueueNode, *front = NULL, *rear = NULL, *temp;"
5136,
5137,void enqueue();
5138,void dequeue();
5139,void display();
5140,
5141,int main()
5142,{
5143,    enqueue(1);
5144,    enqueue(2);
5145,    dequeue();
5146,    enqueue(3);
5147,    enqueue(4);
5148,    enqueue(5);
5149,    display();
5150,
5151,    return 0;
5152,}
5153,
5154,void enqueue(int value)
5155,{
5156,    QueueNode = (struct queue *)malloc(sizeof(struct queue));
5157,    QueueNode->data = value;
5158,
5159,    if (front == NULL && rear == NULL)
5160,    {
5161,        front = rear = temp = QueueNode;
5162,    }
5163,    else
5164,    {
5165,        temp->next = QueueNode;
5166,        temp = rear = QueueNode;
5167,    }
5168,}
5169,
5170,void dequeue()
5171,{
5172,    if (front == NULL && rear == NULL)
5173,    {
5174,"        printf(""Queue is empty\n"");"
5175,    }
5176,    else if (front == rear)
5177,    {
5178,        temp = front;
5179,        front = rear = NULL;
5180,        free(temp);
5181,    }
5182,    else
5183,    {
5184,        temp = front;
5185,        front = front->next;
5186,        free(temp);
5187,    }
5188,}
5189,
5190,void display()
5191,{
5192,"    printf(""Displaying queue : \n"");"
5193,    if (front == NULL && rear == NULL)
5194,    {
5195,"        printf(""Queue is empty\n"");"
5196,    }
5197,    else
5198,    {
5199,        temp = front;
5200,        rear->next = NULL;
5201,        while (temp != NULL)
5202,        {
5203,"            printf(""%d\n"", temp->data);"
5204,            temp = temp->next;
5205,        }
5206,    }
5207,}
5208,QueueNode->data = value;
5209,QueueNode->next
5210,temp->next = QueueNode;
5211,enqueue
5212,temp
5213,front
5214,rear
5215,temp
5216,front
5217,rear
5218,QueueNode
5219,temp
5220,QueueNode
5221,temp
5222,enqueue
5223,temp
5224,temp->next = QueueNode;
5225,dequeue
5226,enqueue
5227,dequeue
5228,temp
5229,free(temp);
5230,enqueue
5231,temp
5232,enqueue
5233,next
5234,next
5235,next
5236,display
5237,next
5238,enqueue
5239,next
5240,enqueue
5241,void enqueue(int value)
5242,{
5243,    /*  Use local variable to point to new node.
5244,
5245,"        Use ""sizeof *NewNode"" instead of ""sizeof (struct queue)"" so that we"
5246,        always get enough memory for the thing the pointer points to even if
5247,        its type is changed in future code edits.
5248,
5249,"        In C, do not cast the result of malloc.  It will automatically be"
5250,"        converted to the type of the pointer being assigned or initialized, and"
5251,        casting can conceal certain code errors.
5252,     */
5253,    struct queue *NewNode = malloc(sizeof *NewNode);
5254,
5255,    //  Set all members of the new node.
5256,    NewNode->data = value;
5257,    NewNode->next = NULL;
5258,
5259,"    /*  Something ""before"" the new node should point to it.  That might be"
5260,        a prior node or it might be the front-of-queue pointer.
5261,    */
5262,    if (front)
5263,        rear->next = NewNode;
5264,    else
5265,        front      = NewNode;
5266,
5267,    //  Update the rear-of-queue pointer.
5268,    rear = NewNode;
5269,
5270,"    /*  Observe that this routine, excepting comments, is shorter and simpler"
5271,        than the original enqueue.
5272,    */
5273,}
5274,dequeue
5275,display
5276,QueueNode
5277,temp
5278,#include <stdio.h>
5279,#include <stdlib.h>
5280,
5281,
5282,struct queue
5283,{
5284,    int data;
5285,    struct queue *next;
5286,};
5287,
5288,
5289,"struct queue *front = NULL, *rear = NULL;"
5290,
5291,
5292,void enqueue();
5293,void dequeue();
5294,void display();
5295,
5296,
5297,int main(void)
5298,{
5299,    enqueue(1);
5300,    enqueue(2);
5301,    dequeue();
5302,    enqueue(3);
5303,    enqueue(4);
5304,    enqueue(5);
5305,    display();
5306,
5307,    return 0;
5308,}
5309,
5310,
5311,void enqueue(int value)
5312,{
5313,    /*  Use local variable to point to new node.
5314,
5315,"        Use ""sizeof *NewNode"" instead of ""sizeof (struct queue)"" so that we"
5316,        always get enough memory for the thing the pointer points to even if
5317,        its type is changed in future code edits.
5318,
5319,"        In C, do not cast the result of malloc.  It will automatically be"
5320,"        converted to the type of the pointer being assigned or initialized, and"
5321,        casting can conceal certain code errors.
5322,     */
5323,    struct queue *NewNode = malloc(sizeof *NewNode);
5324,
5325,    //  Set all members of the new node.
5326,    NewNode->data = value;
5327,    NewNode->next = NULL;
5328,
5329,"    /*  Something ""before"" the new node should point to it.  That might be"
5330,        a prior node or it might be the front-of-queue pointer.
5331,    */
5332,    if (front)
5333,        rear->next = NewNode;
5334,    else
5335,        front      = NewNode;
5336,
5337,    //  Update the rear-of-queue pointer.
5338,    rear = NewNode;
5339,
5340,"    /*  Observe that this routine, excepting comments, is shorter and simpler"
5341,        than the original enqueue.
5342,    */
5343,}
5344,
5345,
5346,void dequeue()
5347,{
5348,    struct queue *OldNode = front;
5349,
5350,    /*  We do not need to check both front and rear.  If there is no front node
5351,"        in the queue, it is empty."
5352,    */
5353,    if (!OldNode)
5354,"        printf(""Queue is empty\n"");"
5355,    else
5356,    {
5357,        //  Update the front-of-queue pointer.
5358,        front = OldNode->next;
5359,
5360,"        /*  If there is no node in the queue now, update the rear-of-queue"
5361,            pointer.
5362,        */
5363,        if (!front)
5364,            rear = NULL;
5365,
5366,        //  Release the node.
5367,        free(OldNode);
5368,    }
5369,}
5370,
5371,
5372,void display()
5373,{
5374,"    printf(""Displaying queue: \n"");"
5375,    if (!front)
5376,"        printf(""Queue is empty\n"");"
5377,    else
5378,        /*  Iterate through the queue using a simple for loop:
5379,
5380,                Start at the front.
5381,
5382,                Continue as long as there is a node.
5383,
5384,"                After each iteration, proceed to the next node."
5385,        */
5386,        for (struct queue *Node = front; Node; Node = Node->next)
5387,"            printf(""%d\n"", Node->data);"
5388,}
5389,#include <stdio.h>
5390,#include <stdlib.h>
5391,
5392,// Use typedef to reduce verbiage
5393,typedef struct queue {
5394,    int data;
5395,"    struct queue *next; // datatype not yet encountered. Need ""struct name"""
5396,"} queue_t; // Conventional naming using ""_t"" suffix"
5397,
5398,"// Combine two pointers into one 'object' (Could add counter, if desired)"
5399,typedef struct {
5400,    queue_t *head; // use conventional names
5401,    queue_t *tail;
5402,} oneQueue_t;
5403,
5404,"// for brevity, this trio of functions deliberately omit checking *q != NULL"
5405,"void enqueue( oneQueue_t *q, int value ) {"
5406,    // use calloc for reliable initialisation to nulls
5407,    // it's too easy to add a member and forget to initialize a value
5408,"    queue_t *pn = calloc( 1, sizeof *pn );"
5409,    if( pn == NULL ) { // ALWAYS test return codes
5410,        // deal with allocation error
5411,        exit( EXIT_FAILURE );
5412,    }
5413,    pn->data = value; // assign known data; the rest is/are NULL'd
5414,
5415,"    if( q->tail ) // always append to the tail, so test the tail"
5416,        q->tail = q->tail->next = pn;
5417,    else
5418,        q->tail = q->head = pn; // first node; assign head too
5419,}
5420,
5421,void dequeue( oneQueue_t *q ) {
5422,"    if( q->head == NULL ) // report where ""soft error"" occurred"
5423,"        printf( ""dequeue() -- queue is empty\n"" );"
5424,    else {
5425,"        queue_t *del = q->head; // ""del"" winks in-and-out of existence"
5426,        if( ( q->head = q->head->next ) == NULL ) // last entry??
5427,            q->tail = NULL;
5428,        free( del );
5429,    }
5430,}
5431,
5432,void display( oneQueue_t *q ) { // simple traversal
5433,"    printf( ""Displaying queue...\n"" );"
5434,    for( queue_t *pn = q->head; pn; pn = pn->next )
5435,"        printf( ""%d\n"", pn->data );"
5436,"    printf( ""End of Queue\n"" );"
5437,}
5438,
5439,"// put code for ""service functions"" ahead of invocations"
5440,"// definition is then the ""func prototype"". less maintenance"
5441,int main() {
5442,"    oneQueue_t q = { NULL, NULL }; // one initialised queue. could have multiple"
5443,
5444,"    dequeue( &q ); // test ""illicit"" operation"
5445,    display( &q ); // test with empty queue
5446,"    enqueue( &q, 1 );"
5447,"    enqueue( &q, 2 );"
5448,    display( &q ); // test with two items
5449,    dequeue( &q );
5450,"    enqueue( &q, 3 );"
5451,"    enqueue( &q, 4 );"
5452,"    enqueue( &q, 5 );"
5453,    display( &q ); // penultimate test
5454,
5455,    while( q.head ) // memory leaks are bad
5456,        dequeue( &q );
5457,
5458,    display( &q ); // final test
5459,"    dequeue( &q ); // test ""illicit"" operation"
5460,
5461,    return 0;
5462,}
5463,dequeue() -- queue is empty
5464,Displaying queue...
5465,End of Queue
5466,Displaying queue...
5467,1
5468,2
5469,End of Queue
5470,Displaying queue...
5471,2
5472,3
5473,4
5474,5
5475,End of Queue
5476,Displaying queue...
5477,End of Queue
5478,dequeue() -- queue is empty
5479,main()
5480,main()
5481,{
5482,"    oneQueue_t q = { NULL, NULL }, *qp = &q; // one initialised queue. could have multiple"
5483,
5484,"    dequeue( qp ); // test ""illicit"" operation"
5485,    display( qp ); // test with empty queue
5486,"    enqueue( qp, 1 );"
5487,"    enqueue( qp, 2 );"
5488,    display( qp ); // test with two items
5489,    dequeue( qp );
5490,"    enqueue( qp, 3 );"
5491,"    enqueue( qp, 4 );"
5492,"    enqueue( qp, 5 );"
5493,    display( qp ); // penultimate test
5494,
5495,    while( qp->head ) // memory leaks are bad
5496,        dequeue( qp );
5497,
5498,    display( qp ); // final test
5499,"    dequeue( qp ); // test ""illicit"" operation"
5500,
5501,    return 0;
5502,}
5503,#include <stdio.h>
5504,#include <locale.h>
5505,
5506,int main(){
5507,"    setlocale(LC_ALL, ""PORTUGUESE"");"
5508,
5509,    char c;
5510,    int cont;
5511,
5512,"    printf(""Digite uma mensagem:\n"");"
5513,"    scanf(""%c"", &c);"
5514,
5515,    for (cont = 1; cont <= 5; cont++){
5516,"        printf(""%c\n"", c);"
5517,        }
5518,        return 0;
5519,}
5520,%c
5521,%s
5522,%c
5523,%s
5524,swap: ; written by me
5525,"    mov al, byte [rdi]"
5526,"    xchg byte [rsi], al"
5527,"    mov byte [rdi], al"
5528,    ret
5529,"void swap(char *a, char *b) {"
5530,  char temp = *a;
5531,  *a = *b;
5532,  *b = temp;
5533,}
5534,swap:   ; written by GCC -O3
5535,        endbr64                                         ; 0000 _ F3: 0F 1E. FA
5536,"        movzx   eax, byte [rdi]                         ; 0004 _ 0F B6. 07"
5537,"        movzx   edx, byte [rsi]                         ; 0007 _ 0F B6. 16"
5538,"        mov     byte [rdi], dl                          ; 000A _ 88. 17"
5539,"        mov     byte [rsi], al                          ; 000C _ 88. 06"
5540,        ret                                             ; 000E _ C3
5541,xchg
5542,lock
5543,al
5544,xchg
5545,#define DR_REG_RNG_BASE                        0x3ff75144
5546,
5547,void printBitByBit( ){
5548,
5549,    // READ_PERI_REG is the ESP32 function to read DR_REG_RNG_BASE
5550,    uint32_t rndval = READ_PERI_REG(DR_REG_RNG_BASE);
5551,    int i;
5552,    for (i = 1; i <= 32; i++){ 
5553,      int mask =  1 << i;
5554,      int masked_n = rndval & mask;
5555,      int thebit = masked_n >> i;   
5556,"      Serial.printf(""%i"", thebit);"
5557,    }
5558,"    Serial.println(""\n"");"
5559,}
5560,i
5561,rndval >> i & 1
5562,0001
5563,uint32_t
5564,1 << i
5565,i == 32
5566,i
5567,uint32_t
5568,value >> n & 1
5569,#include <iostream>
5570,#include <cstdint>
5571,#include <inttypes.h>
5572,
5573,int main()
5574,{
5575,    uint32_t test = 0x84FF0048uL;
5576,    int i;
5577,    // Your code ...
5578,    for (i = 1; i <= 32; i++) {
5579,        int mask = 1 << i;
5580,        int masked_n = test & mask;
5581,        int thebit = masked_n >> i;
5582,"        printf(""%i"", thebit);"
5583,    }
5584,"    printf(""\n"");"
5585,    // Corrected limits/order/types ...
5586,    for (i = 31; i >= 0; --i) {
5587,        uint32_t mask = (uint32_t)(1) << i;
5588,        uint32_t masked_n = test & mask;
5589,        uint32_t thebit = masked_n >> i;
5590,"        printf(""%""PRIu32, thebit);"
5591,    }
5592,"    printf(""\n"");"
5593,    // Better ...
5594,    for (i = 31; i >= 0; --i) {
5595,"        printf(""%""PRIu32, test >> i & 1);"
5596,    }
5597,"    printf(""\n"");"
5598,    return 0;
5599,}
5600,001001000000000111111110010000-10
5601,10000100111111110000000001001000
5602,10000100111111110000000001001000
5603,"""%""PRu32"
5604,uint32_t
5605,(uint32_t)(1)
5606,int
5607,unsigned
5608,uint32_t mask = 1 << i;
5609,uint32_t mask = 1u << i;
5610,uint32_t mask = (uint32_t)1 << i;
5611,"printf(""%"" PRIu32, thebit);"
5612,"printf(""%u"", test >> i & 1);"
5613,u
5614,unsigned
5615,u
5616,printf()
5617,UINT32_C(1)
5618,<stdint.h>
5619,UINTn_C()
5620,(uint32_t)1
5621,(uint32_t)(1) << i
5622,1 << i
5623,#include <stdio.h>
5624,
5625,int main() {
5626,    while (height > 0) {
5627,        if (throttle >= 0 && throttle <= 100) {
5628,"            printf(""%d    %.1f  %.1f   %.1f  "", time, height, velocity, fuel);"
5629,"            scanf(""%d"", &throttle);"
5630,            height = heightTemp + velocityTemp - (throttle * K-G) / 2;
5631,            velocity = velocityTemp + (throttle * K-G);
5632,            fuel = fuelTemp - throttle;
5633,            time = time + 1;
5634,            heightTemp = height;
5635,            velocityTemp = velocity;
5636,            fuelTemp = fuel;   
5637,        }
5638,        else {
5639,"            printf(""Please choose a number between 0 and 100! \n"");"
5640,            break;
5641,        }
5642,    }
5643,   
5644,    if (velocity >= -2.0) {
5645,"        printf(""You landed successfully: "");"
5646,    } 
5647,    else {
5648,"        printf(""Failed! You crashed"");"
5649,    }
5650,
5651,    return 0;
5652,}
5653,throttle
5654,time
5655,height
5656,velocity
5657,fuel
5658,didBreak
5659,break
5660,goto pastTheIfElse;
5661,break
5662,pastTheIfElse
5663,return
5664,return
5665,goto
5666,goto
5667,idBreak
5668,break
5669,goto pastTheIfElse;
5670,break;
5671,pastTheIfElse
5672,return
5673,return
5674,goto
5675,#include <stdio.h>
5676,
5677,int main() {
5678,    while (height > 0) {
5679,        if (throttle >= 0 && throttle <= 100) {
5680,"            printf(""%d    %.1f  %.1f   %.1f  "", time, height, velocity, fuel);"
5681,"            scanf(""%d"", &throttle);"
5682,            height = heightTemp + velocityTemp - (throttle * K-G) / 2;
5683,            velocity = velocityTemp + (throttle * K-G);
5684,            fuel = fuelTemp - throttle;
5685,            time = time + 1;
5686,            heightTemp = height;
5687,            velocityTemp = velocity;
5688,            fuelTemp = fuel;   
5689,        }
5690,        else {
5691,"            printf(""Please choose a number between 0 and 100! \n"");"
5692,            goto pastTheIfElse; //instead of break;
5693,            //OR in this case: `return 0;`
5694,        }
5695,    }
5696,
5697,    if (velocity >= -2.0) {
5698,"        printf(""You landed successfully: "");"
5699,    } else {
5700,"        printf(""Failed! You crashed"");"
5701,    }
5702,    pastTheIfElse:
5703,
5704,    return 0;
5705,}
5706,goto
5707,didBreak
5708,goto
5709,break;
5710,return 0;
5711,return -1;
5712,#include <stdlib.h>
5713,return EXIT_SUCCESS
5714,return EXIT_FAILURE
5715,0
5716,255
5717,1
5718,-1
5719,EXIT_SUCCESS
5720,EXIT_FAILURE' and 
5721,EXIT_SUCCESS
5722,if
5723,#include <stdio.h>
5724,
5725,int main() {
5726,    int didBreak = 0;
5727,
5728,    while (height > 0)
5729,    {
5730,        if (throttle >= 0 && throttle <= 100)
5731,        {
5732,"            printf(""%d    %.1f  %.1f   %.1f  "", time, height, velocity, fuel);"
5733,"            scanf(""%d"", &throttle);"
5734,            height = heightTemp + velocityTemp - (throttle * K - G) / 2;
5735,            velocity = velocityTemp + (throttle * K - G);
5736,            fuel = fuelTemp - throttle;
5737,            time = time + 1;
5738,            heightTemp = height;
5739,            velocityTemp = velocity;
5740,            fuelTemp = fuel;
5741,
5742,        }
5743,        else
5744,        {
5745,"            printf(""Please choose a number between 0 and 100! \n"");"
5746,            didBreak = 1;
5747,            break;
5748,        }
5749,    }
5750,
5751,    if (didBreak == 0)
5752,    {
5753,        if (velocity >= -2.0)
5754,        {
5755,"            printf(""You landed successfully: "");"
5756,        }
5757,        else
5758,        {
5759,"            printf(""Failed! You crashed"");"
5760,        }
5761,    }
5762,
5763,    return 0;
5764,}
5765,if (didBreak) return 0;
5766,break
5767,return 1;
5768,#include <stdlib.h>
5769,return EXIT_FAILURE;
5770,break
5771,if
5772,else
5773,"for (;;) //infinite loop, equivalent to while(true)"
5774,{
5775,    if ( height <= 0 )
5776,    {
5777,        if ( velocity >= -2.0 )
5778,        {
5779,"            printf( ""You landed successfully.\n"" );"
5780,        }
5781,        else
5782,        {
5783,"            printf( ""Failed! You crashed!\n"" );"
5784,        }
5785,
5786,        break;
5787,    }
5788,
5789,    if ( throttle >= 0 && throttle <= 100 )
5790,    {
5791,        [...]
5792,    }
5793,    else
5794,    {
5795,"        printf( ""Please choose a number between 0 and 100!\n"" );"
5796,        break;
5797,    }
5798,}
5799,throttle
5800,scanf
5801,fgets
5802,strtol
5803,get_int_from_user
5804,"for (;;) //infinite loop, equivalent to while(true)"
5805,{
5806,"    printf( ""T: %d   H: %.1f   V: %.1f   F: %.1f\n"", time, height, velocity, fuel );"
5807,
5808,    if ( height <= 0 )
5809,    {
5810,        if ( velocity >= -2.0 )
5811,        {
5812,"            printf( ""You landed successfully.\n"" );"
5813,        }
5814,        else
5815,        {
5816,"            printf( ""Failed! You crashed!\n"" );"
5817,        }
5818,
5819,        break;
5820,    }
5821,
5822,    //repeat until user entered a valid integer in the
5823,    //range 0 - 100
5824,    for (;;)
5825,    {
5826,"        throttle = get_int_from_user( ""Enter throttle (0-100): "" );"
5827,        if ( throttle < 0 || throttle > 100 )
5828,        {
5829,"            printf( ""Please choose a number between 0 and 100!\n"" );"
5830,            continue;
5831,        }
5832,
5833,        //input is ok
5834,        break;
5835,    }
5836,
5837,    //do physics calculations (copied from the question)
5838,    height = heightTemp + velocityTemp - (throttle * K-G) / 2;
5839,    velocity = velocityTemp + (throttle * K-G);
5840,    fuel = fuelTemp - throttle;
5841,    time = time + 1;
5842,    heightTemp = height;
5843,    velocityTemp = velocity;
5844,    fuelTemp = fuel;  
5845,}
5846,#include <stdio.h>
5847,#include <stdlib.h>
5848,#include <string.h>
5849,#include <ctype.h>
5850,#include <limits.h>
5851,#include <errno.h>
5852,
5853,int get_int_from_user( const char *prompt );
5854,
5855,int main( void )
5856,{
5857,"    int time = 0, throttle;"
5858,"    double height = 100.0, velocity = -5.0;"
5859,
5860,"    for (;;) //infinite loop, equivalent to while(true)"
5861,    {
5862,"        printf( ""T: %d   H: %.1f   V: %.1f\n"", time, height, velocity );"
5863,
5864,        if ( height <= 0 )
5865,        {
5866,            if ( velocity >= -2.0 )
5867,            {
5868,"                printf( ""You landed successfully.\n"" );"
5869,            }
5870,            else
5871,            {
5872,"                printf( ""Failed! You crashed!\n"" );"
5873,            }
5874,
5875,            break;
5876,        }
5877,
5878,        //repeat until user entered a valid integer in the
5879,        //range 0 - 100
5880,        for (;;)
5881,        {
5882,"            throttle = get_int_from_user( ""Enter throttle (0-100): "" );"
5883,            if ( throttle < 0 || throttle > 100 )
5884,            {
5885,"                printf( ""Please choose a number between 0 and 100!\n"" );"
5886,                continue;
5887,            }
5888,
5889,            //input is ok
5890,            break;
5891,        }
5892,
5893,        //do physics calculations
5894,        velocity += throttle / 100.0;
5895,        velocity -= 0.5; //gravity
5896,        height += velocity;
5897,        time++;
5898,    }
5899,}
5900,
5901,int get_int_from_user( const char *prompt )
5902,{
5903,    //loop forever until user enters a valid number
5904,    for (;;)
5905,    {
5906,"        char buffer[1024], *p;"
5907,        long l;
5908,
5909,        //prompt user for input
5910,"        fputs( prompt, stdout );"
5911,
5912,        //get one line of input from input stream
5913,"        if ( fgets( buffer, sizeof buffer, stdin ) == NULL )"
5914,        {
5915,"            fprintf( stderr, ""Unrecoverable input error!\n"" );"
5916,            exit( EXIT_FAILURE );
5917,        }
5918,
5919,        //make sure that entire line was read in (i.e. that
5920,        //the buffer was not too small)
5921,"        if ( strchr( buffer, '\n' ) == NULL && !feof( stdin ) )"
5922,        {
5923,            int c;
5924,
5925,"            printf( ""Line input was too long!\n"" );"
5926,
5927,            //discard remainder of line
5928,            do
5929,            {
5930,                c = getchar();
5931,
5932,                if ( c == EOF )
5933,                {
5934,"                    fprintf( stderr, ""Unrecoverable error reading from input!\n"" );"
5935,                    exit( EXIT_FAILURE );
5936,                }
5937,
5938,            } while ( c != '\n' );
5939,
5940,            continue;
5941,        }
5942,
5943,        //attempt to convert string to number
5944,        errno = 0;
5945,"        l = strtol( buffer, &p, 10 );"
5946,        if ( p == buffer )
5947,        {
5948,"            printf( ""Error converting string to number!\n"" );"
5949,            continue;
5950,        }
5951,
5952,"        //make sure that number is representable as an ""int"""
5953,        if ( errno == ERANGE || l < INT_MIN || l > INT_MAX )
5954,        {
5955,"            printf( ""Number out of range error!\n"" );"
5956,            continue;
5957,        }
5958,
5959,"        //make sure that remainder of line contains only whitespace,"
5960,"        //so that input such as ""6sdfj23jlj"" gets rejected"
5961,        for ( ; *p != '\0'; p++ )
5962,        {
5963,            if ( !isspace( (unsigned char)*p ) )
5964,            {
5965,"                printf( ""Unexpected input encountered!\n"" );"
5966,
5967,"                //cannot use `continue` here, because that would go to"
5968,"                //the next iteration of the innermost loop, but we"
5969,                //want to go to the next iteration of the outer loop
5970,                goto continue_outer_loop;
5971,            }
5972,        }
5973,
5974,        return l;
5975,
5976,    continue_outer_loop:
5977,        continue;
5978,    }
5979,}
5980,T: 0   H: 100.0   V: -5.0
5981,Enter throttle (0-100): hh7
5982,Error converting string to number!
5983,Enter throttle (0-100): test
5984,Error converting string to number!
5985,Enter throttle (0-100): 6abc
5986,Unexpected input encountered!
5987,Enter throttle (0-100): 200
5988,Please choose a number between 0 and 100!
5989,Enter throttle (0-100): -30
5990,Please choose a number between 0 and 100!
5991,Enter throttle (0-100): 5 
5992,T: 1   H: 94.5   V: -5.5
5993,Enter throttle (0-100): 10
5994,T: 2   H: 88.7   V: -5.9
5995,Enter throttle (0-100): 15
5996,T: 3   H: 82.5   V: -6.2
5997,Enter throttle (0-100): 20
5998,T: 4   H: 76.0   V: -6.5
5999,Enter throttle (0-100): 25
6000,T: 5   H: 69.2   V: -6.8
6001,Enter throttle (0-100): 35
6002,T: 6   H: 62.4   V: -6.9
6003,Enter throttle (0-100): 45
6004,T: 7   H: 55.4   V: -7.0
6005,Enter throttle (0-100): 55
6006,T: 8   H: 48.5   V: -6.9
6007,Enter throttle (0-100): 65
6008,T: 9   H: 41.8   V: -6.8
6009,Enter throttle (0-100): 80
6010,T: 10   H: 35.3   V: -6.5
6011,Enter throttle (0-100): 100
6012,T: 11   H: 29.3   V: -6.0
6013,Enter throttle (0-100): 100
6014,T: 12   H: 23.9   V: -5.5
6015,Enter throttle (0-100): 100
6016,T: 13   H: 18.9   V: -5.0
6017,Enter throttle (0-100): 100
6018,T: 14   H: 14.5   V: -4.5
6019,Enter throttle (0-100): 100
6020,T: 15   H: 10.6   V: -4.0
6021,Enter throttle (0-100): 100
6022,T: 16   H: 7.1   V: -3.5
6023,Enter throttle (0-100): 100
6024,T: 17   H: 4.2   V: -3.0
6025,Enter throttle (0-100): 100
6026,T: 18   H: 1.7   V: -2.5
6027,Enter throttle (0-100): 100
6028,T: 19   H: -0.2   V: -2.0
6029,You landed successfully.
6030,while( height > 0 ) {
6031,"    printf(""%d    %.1f  %.1f   %.1f  "", time, height, velocity, fuel);"
6032,"    scanf(""%d"", &throttle);"
6033,    if( throttle < 0 || throttle > 100 ) {
6034,        if( throttle == 999 ) return -1; // Maybe???
6035,"        printf(""Please choose a number between 0 and 100! (999 to abort) \n"");"
6036,        continue;
6037,    }
6038,
6039,    /* Calculations omitted */
6040,}
6041,(right-left+2)
6042,"char* sub_string(char* str, int left, int right)"
6043,{
6044,    int i;
6045,    char* sub_str = (char*) malloc(sizeof(char)*(right-left+2)); /* 4th line */
6046,}
6047,:)
6048,right-left+2
6049,right-left+1+1
6050,righ-left
6051,return
6052,"""this"""
6053,"""more this than that"""
6054,more this than that
6055,0    5  8
6056,'t'
6057,left
6058,'s'
6059,right
6060,"""this"""
6061,+1
6062,'t'
6063,+1
6064,left = 2
6065,right = 3
6066,3 - 2 = 1
6067,+1
6068,'\0'
6069,0
6070,+1
6071,:)
6072,fwrite
6073,file.txt
6074,Jhonny 18 10.0
6075,#include <stdio.h>
6076,#include <stdlib.h>
6077,#include <string.h>
6078,"#define FILENAME ""file.txt"""
6079,
6080,typedef struct {
6081,    char name[32];
6082,    int age;
6083,    float value;
6084,} Test_struct;
6085,
6086,"int main(int argc, char** argv)"
6087,{
6088,    Test_struct test;
6089,"    strcpy(test.name, ""Jhonny"");"
6090,    test.age = 18;
6091,    test.value = 10.0;
6092,
6093,"    FILE* file = fopen(FILENAME, ""w"");"
6094,    if (file == NULL)
6095,    {
6096,"        fprintf(stderr, ""\nAn error occurred while opening the file\n"");"
6097,        return -1;
6098,    }
6099,
6100,"    if (fwrite(&test, sizeof(test), 1, file) < 0)"
6101,        return -1;
6102,
6103,    fclose(file);
6104,
6105,    return 0;
6106,}
6107,"""Jhonny"""
6108,name
6109,name
6110,float
6111,double
6112,fprintf
6113,fprintf
6114,.txt
6115,fwrite()
6116,fprintf()
6117,#include <stdio.h>
6118,#include <stdlib.h>
6119,#include <string.h>
6120,"#define FILENAME ""file.txt"""
6121,
6122,typedef struct {
6123,    char name[32];
6124,    int age;
6125,    float value;
6126,} Test_struct;
6127,
6128,"int main(int argc, char** argv)"
6129,{
6130,    Test_struct test;
6131,"    strcpy(test.name, ""Jhonny"");"
6132,    test.name[7] = '\0';
6133,    test.age = 18;
6134,    test.value = 10.0;
6135,
6136,"    FILE* file = fopen(FILENAME, ""w"");"
6137,    if (file == NULL)
6138,    {
6139,"        fprintf(stderr, ""\nAn error occurred while opening the file\n"");"
6140,        return -1;
6141,    }
6142,
6143,"    if (fprintf(file, ""%s %d %3.2f"", test.name, test.age, test.value) < 0)"
6144,        return -1;
6145,
6146,    fclose(file);
6147,
6148,    return 0;
6149,}
6150,"""%.17g"""
6151,#include <stdio.h>
6152,#include <stdlib.h>
6153,
6154,struct node
6155,{
6156,    int data;
6157,    struct node *next;
6158,};
6159,struct node *head;
6160,struct node* reverse_ll(struct node* hnode)
6161,{
6162,    if(hnode == 0)
6163,    {
6164,        return 0;
6165,    }
6166,    if(hnode->next == 0)
6167,    {
6168,        head=hnode;
6169,        return hnode;
6170,    }
6171,    struct node* ptr=reverse_ll(hnode->next);
6172,    ptr->next=hnode;
6173,    hnode->next=0;
6174,
6175, //return hnode;
6176,}
6177,void display()
6178,{
6179,    struct node *ptr;
6180,    ptr=head;
6181,    if(ptr==0)
6182,    {
6183,"    printf(""empty"");"
6184,    }
6185,    else
6186,    {
6187,        while(ptr!=0)
6188,        {
6189,"            printf(""%d->"",ptr->data);"
6190,            ptr=ptr->next;
6191,
6192,        }
6193,"          printf(""null"");"
6194,    }
6195,}
6196,int main()
6197,{
6198,struct node* h;    
6199,lastinsert(1);
6200,lastinsert(2);
6201,lastinsert(3);
6202,lastinsert(4);
6203,lastinsert(5);
6204,display();
6205,h=reverse_ll(head);
6206,display();
6207,return 0;
6208,}
6209,ptr
6210,reverse_ll()
6211,struct node *
6212,#include <stdio.h>
6213,#include <stdlib.h>
6214,
6215,struct node {
6216,    int data;
6217,    struct node *next;
6218,};
6219,struct node *head;
6220,
6221,void lastinsert(int data) {
6222,    struct node **c = &head;
6223,    for(; *c; c = &(*c)->next);
6224,    *c = malloc(sizeof(*head));
6225,    if (!(*c)) {
6226,"        printf(""malloc failed\n"");"
6227,        return;
6228,    }
6229,    (*c)->data = data;
6230,    (*c)->next = NULL;
6231,}
6232,
6233,struct node *reverse_ll(struct node* hnode) {
6234,    if(!hnode)
6235,        return NULL;
6236,    if(!hnode->next) {
6237,        head = hnode;
6238,        return hnode;
6239,    }
6240,    struct node *ptr=reverse_ll(hnode->next);
6241,    ptr->next=hnode;
6242,    hnode->next = NULL;
6243,    return hnode;
6244,}
6245,
6246,void display() {
6247,    if(!head) {
6248,"        printf(""empty"");"
6249,        return;
6250,    }
6251,    for(struct node *ptr = head; ptr; ptr = ptr->next) {
6252,"        printf(""%d->"",ptr->data);"
6253,    }
6254,"    printf(""null\n"");"
6255,}
6256,
6257,int main() {
6258,    for(int i = 1; i <= 5; i++) {
6259,        lastinsert(i);
6260,    }
6261,    display();
6262,    reverse_ll(head);
6263,    display();
6264,    // It's good practice to implement a function that frees you list
6265,    // which you would call here.
6266,    return 0;
6267,}
6268,$ ./a.out
6269,1->2->3->4->5->null
6270,5->4->3->2->1->null
6271,MinGW+MSYS
6272,MinGW-w64 + MSYS2
6273,mingw-w64-install
6274,MinGW-w64
6275,Cygwin
6276,MinGW-w64
6277,MinGW+MSYS
6278,MinGW-w64 + MSYS2
6279,MSYS2 64-bit
6280,MSYS2 32-bit
6281,mingw64.exe
6282,mingw32.exe
6283,MINGW64
6284,MINGW32
6285,MSYS
6286,pacman -Syuu
6287,pacman -S mingw-w64-x86_64-toolchain
6288,pacman -S mingw-w64-i686-toolchain
6289,pacman -Ss name_of_something_i_want_to_install
6290,pacman -Ss gsl
6291,pacman -S package_name_of_something_i_want_to_install
6292,pacman -S mingw-w64-x86_64-gsl
6293,mingw-w64-x86_64-
6294,mingw-w64-i686-
6295,grep
6296,sed
6297,make
6298,gcc --version
6299,<MSYS2 root>/mingw64/bin
6300,<MSYS2 root>/mingw32/bin
6301,PATH
6302,pacman
6303,pacman
6304,mingw-w64
6305,mingw
6306,cygwin fork
6307,pacman -Sy pacman
6308,pacman -Syu
6309,pacman -Su
6310,pacman -S mingw-w64-i686-toolchain
6311,pacman -S mingw-w64-x86_64-toolchain
6312,make
6313,pacman -S make
6314,x86_64-6.2.0-release-posix-seh-rt_v5-rev1
6315,Reference
6316,pacman -S mingw-w64-x86_64-cmake
6317,cmake
6318,kuid_t
6319,typedef struct
6320,uid_t
6321,val
6322,kuid_t
6323,typedef uid_t kuid_t
6324,kuid_t.val
6325,typedef struct {
6326,    uid_t val;
6327,} kuid_t;
6328,typedef uid_t kuid_t;
6329,kuid_t
6330,kgid_t
6331,kuid_t
6332,typedef
6333,typedef struct { uid_t val; } kuid_t;
6334,kgid_t
6335,kuid_t
6336,typedef uid_t kuid_t;
6337,typedef gid_t kgid_t;
6338,uid_t
6339,gid_t
6340,uid_t
6341,gid_t
6342,kuid_t
6343,typedef uid_t kuid_t
6344,typedef struct
6345,kuid_t
6346,kgid_t
6347,uid_t
6348,typedef int uid_t; typedef int gid_t; typedef uid_t kuid_t; typedef gid_t kgid_t;
6349,kgid_t
6350,kuid_t
6351,pte_t
6352,pmd_t
6353,pud_t
6354,pgd_t
6355,struct { unsigned long val; }
6356,#include <stdlib.h>
6357,#include <unistd.h>
6358,#include <stdio.h>
6359,#include <sys/syscall.h>
6360,#include <sys/types.h>
6361,#include <fcntl.h>
6362, 
6363, 
6364,int main (){
6365,"    int child1=0, child2=0, fd, fd2, fs, i=0, i2=0;"
6366,"    int count=0, count2=0;"
6367,"    char buf1[20], buf2[20], a, b, con='1', vow='0', check1, check2;"
6368,"    fd=open(""text"", O_RDONLY);"
6369,"    fd2=open(""text2"", O_CREAT|O_RDWR|O_TRUNC,0777);"
6370,"    fs=open(""semaphore"", O_RDWR, 0777);"
6371, 
6372, 
6373,    if (fork()==0)
6374,        child1=1;
6375,    else {
6376,        if (fork()==0)
6377,            child2=1;
6378,    }
6379, 
6380, 
6381,    //access vowel child
6382,    if (child1){
6383,"        printf(""I'm the first child\n"");"
6384,"        while ((read(fd,&a,1))==1){"
6385,            if (a=='a' || a=='e' || a=='i' || a=='o' || a=='u')
6386,                buf1[count]=a;
6387,            count++;
6388,            }
6389,"        printf(""count: %d\n"", count);"
6390,        //vowels are now into buf1
6391,        //wait for the brother to do the same
6392,        sleep(2);
6393,        for (i; i<=count+1; i++){
6394,            if (buf1[i]!='\0'){
6395,"                printf(""%c\n"", buf1[i]);"
6396,                a=buf1[i];
6397,"                write(fd2,&a,1);"
6398,            }
6399,"            lseek(fs,0,SEEK_SET);"
6400,"            write(fs,&con,1);//tell the semaphore it's the consonant's turn (1)         "
6401,            while(check1=='1'){
6402,"                lseek(fs,0,SEEK_SET);"
6403,"                read(fs,&a,1);"
6404,                check1=a;
6405,                sleep(1);
6406,            } //get stuck until it's  somebody's else turn
6407,        }
6408,    }   
6409, 
6410, 
6411, 
6412,    //access consonant child
6413,    else if (child2){
6414,        sleep(1);
6415,"        lseek(fd,0,SEEK_SET);"
6416,"        printf (""I'm the second child\n"");"
6417,"        while ((read(fd,&a,1))==1){"
6418,            if (a=='a' || a=='e' || a=='i' || a=='o' || a=='u')
6419,                ;
6420,            else
6421,                buf2[count2]=a;
6422,            count2++;
6423,        }
6424,        //resync
6425,        sleep(1);
6426,"        printf(""count: %d\n"", count2);"
6427,        //consonants are now into buf1
6428, 
6429,        for (i; i<=count2+1; i++){
6430,"            lseek(fs,0,SEEK_SET);"
6431,            if (buf2[i]!='\0'){
6432,"                printf(""%c\n"", buf2[i]);"
6433,                b=buf2[i];
6434,"                write(fd2,&b,1);"
6435,            } //wait for vowel
6436,            while(check2=='0'){
6437,"                lseek(fs,0,SEEK_SET);"
6438,"                read(fs,&b,1);"
6439,                check2=b;
6440,                sleep(1);
6441,            }
6442,"            lseek(fs,0,SEEK_SET);"
6443,"            write(fs,&vow,1);//tell the semaphore it's the vowel's turn (0)"
6444,        }
6445,    }
6446, 
6447, 
6448, 
6449, 
6450, 
6451,    else
6452,"        printf(""I'm the father\n"");"
6453,    sleep(10);
6454,    exit(0);
6455,}
6456,pthread_mutex_t
6457,sem_t
6458,acquire
6459,release
6460,wait
6461,acquire
6462,release
6463,#include <stdlib.h>
6464,#include <unistd.h>
6465,#include <stdio.h>
6466,#include <sys/syscall.h>
6467,#include <sys/types.h>
6468,#include <sys/wait.h>
6469,#include <fcntl.h>
6470,
6471,void
6472,"acquire(int fs,char iam)"
6473,{
6474,    char own;
6475,
6476,    while (1) {
6477,"        lseek(fs,0,SEEK_SET);"
6478,"        read(fs,&own,1);"
6479,
6480,        if (own == iam)
6481,            break;
6482,
6483,        usleep(1);
6484,    }
6485,}
6486,
6487,void
6488,"release(int fs,char iam)"
6489,{
6490,    char other;
6491,
6492,    if (iam == 1)
6493,        other = 2;
6494,    else
6495,        other = 1;
6496,
6497,"    lseek(fs,0,SEEK_SET);"
6498,"    write(fs,&other,1);"
6499,}
6500,
6501,int
6502,main()
6503,{
6504,"    int child1 = 0,"
6505,"        child2 = 0,"
6506,"        fd,"
6507,"        fd2,"
6508,"        fs,"
6509,"        i = 0,"
6510,        i2 = 0;
6511,"    int count = 0,"
6512,        count2 = 0;
6513,"    char buf1[20],"
6514,"     buf2[20],"
6515,"     a,"
6516,"     b,"
6517,"     con = '1',"
6518,"        vow = '0',"
6519,"        check1,"
6520,        check2;
6521,
6522,"    fd = open(""text"", O_RDONLY);"
6523,"    fd2 = open(""text2"", O_CREAT | O_RDWR | O_TRUNC, 0777);"
6524,
6525,"    fs = open(""semaphore"", O_RDWR | O_CREAT, 0777);"
6526,
6527,    // initialize semaphore to grant access to one or the other
6528,    buf1[0] = 1;
6529,"    write(fs,buf1,1);"
6530,
6531,    if (fork() == 0)
6532,        child1 = 1;
6533,    else {
6534,        if (fork() == 0)
6535,            child2 = 1;
6536,    }
6537,
6538,    // access vowel child
6539,    if (child1) {
6540,"        printf(""I'm the first child\n"");"
6541,"        while ((read(fd, &a, 1)) == 1) {"
6542,            if (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u')
6543,                buf1[count] = a;
6544,            count++;
6545,        }
6546,"        printf(""count: %d\n"", count);"
6547,        // vowels are now into buf1
6548,        // wait for the brother to do the same
6549,        sleep(2);
6550,        for (i; i <= count + 1; i++) {
6551,"            acquire(fs,1);"
6552,            if (buf1[i] != '\0') {
6553,"                printf(""%c\n"", buf1[i]);"
6554,                a = buf1[i];
6555,"                write(fd2, &a, 1);"
6556,            }
6557,"            release(fs,1);"
6558,        }
6559,    }
6560,
6561,    // access consonant child
6562,    else if (child2) {
6563,        sleep(1);
6564,"        lseek(fd, 0, SEEK_SET);"
6565,"        printf(""I'm the second child\n"");"
6566,"        while ((read(fd, &a, 1)) == 1) {"
6567,            if (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u');
6568,            else
6569,                buf2[count2] = a;
6570,            count2++;
6571,        }
6572,        // resync
6573,        sleep(1);
6574,"        printf(""count: %d\n"", count2);"
6575,        // consonants are now into buf1
6576,
6577,        for (i; i <= count2 + 1; i++) {
6578,"            acquire(fs,2);"
6579,            if (buf2[i] != '\0') {
6580,"                printf(""%c\n"", buf2[i]);"
6581,                b = buf2[i];
6582,"                write(fd2, &b, 1);"
6583,            }                           // wait for vowel
6584,"            release(fs,2);"
6585,        }
6586,    }
6587,
6588,    else {
6589,"        printf(""I'm the father\n"");"
6590,        while (wait(NULL) >= 0);
6591,"        printf(""all done\n"");"
6592,    }
6593,
6594,    //sleep(10);
6595,    exit(0);
6596,}
6597,open
6598,lseek
6599,read
6600,write
6601,fork
6602,lseek
6603,read
6604,write
6605,pread
6606,pwrite
6607,void
6608,"acquire(int fs,char iam)"
6609,{
6610,    char own;
6611,
6612,    while (1) {
6613,"        pread(fs,&own,1,0);"
6614,
6615,        if (own == iam)
6616,            break;
6617,
6618,        usleep(1);
6619,    }
6620,}
6621,
6622,void
6623,"release(int fs,char iam)"
6624,{
6625,    char other;
6626,
6627,    if (iam == 1)
6628,        other = 2;
6629,    else
6630,        other = 1;
6631,
6632,"    pwrite(fs,&other,1,0);"
6633,}
6634,InternetSetOption()
6635,new INTERNET_PER_CONN_OPTION[3];
6636,INTERNET_PER_CONN_OPTION
6637,new
6638,"int request(char * host, int port,char * endpoint, char * data, size_t dlen )"
6639,{
6640,"    LPCSTR accept[] = {""*/*"", NULL};"
6641,"    char  hdrs[] = ""Content-Type: application/json"";"
6642,"    HINTERNET hConnect, hSession, hRequest;"
6643,"    hSession = InternetOpen("""","
6644,"                            INTERNET_OPEN_TYPE_PRECONFIG,"
6645,"                            NULL,"
6646,"                            NULL,"
6647,                            0);
6648,    INTERNET_PER_CONN_OPTION_LIST list;
6649,    INTERNET_PER_CONN_OPTION ops[1];
6650,    DWORD   dwBufSize = sizeof(list);
6651,    list.dwSize = sizeof(list);
6652,    list.pszConnection = NULL;
6653,    list.dwOptionCount = 1;
6654,    list.pOptions = ops;
6655,    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
6656,    list.pOptions[0].Value.dwValue = SECURITY_FLAG_IGNORE_UNKNOWN_CA ;
6657,"    hConnect = InternetConnect(hSession,"
6658,"                                host,"
6659,"                                port,"
6660,"                                NULL,"
6661,"                                NULL,"
6662,"                                INTERNET_SERVICE_HTTP,0,1);"
6663,"    hRequest = HttpOpenRequest(hConnect,"
6664,"                                ""GET"", "
6665,"                                endpoint,"
6666,"                                _T(""HTTP/1.1""),"
6667,"                                NULL,"
6668,"                                accept,"
6669,"                                INTERNET_FLAG_IGNORE_CERT_CN_INVALID|INTERNET_FLAG_SECURE,1);"
6670,"    if (!InternetSetOption(hRequest, INTERNET_OPTION_SECURITY_FLAGS, &list, dwBufSize))"
6671,"        printf(""Failed to set options Error: %ld\n"", GetLastError());"
6672,    if (hRequest == NULL)
6673,"        printf(""Error: %ld\n"", GetLastError());"
6674,"    if (HttpSendRequest(hRequest, hdrs, strlen(hdrs), data, dlen))"
6675,    {
6676,        DWORD received;
6677,        char tmp[MAX_LEN];
6678,"        while (InternetReadFile(hRequest, tmp, MAX_LEN, &received) && received)   "
6679,"            printf(""%s\n"", tmp);"
6680,    }
6681,    return 0;
6682,}
6683,InternetSetOption()
6684,SECURITY_FLAG_IGNORE_UNKNOWN_CA
6685,SECURITY_FLAG_IGNORE_UNKNOWN_CA 
6686,InternetSetOption()
6687,SECURITY_FLAG_IGNORE_UNKNOWN_CA
6688,InternetSetOption()
6689,INTERNET_OPTION_SECURITY_FLAGS
6690,InternetSetOption
6691,"int request(char * host, int port,char * endpoint, char * data, size_t dlen )"
6692,{
6693,"    LPCSTR accept[] = {""*/*"", NULL};"
6694,"    char  hdrs[] = ""Content-Type: application/json"";"
6695,"    HINTERNET hConnect, hSession, hRequest;"
6696,    DWORD dwFlags;
6697,    DWORD dwBuffLen = sizeof(dwFlags);
6698,"    hSession = InternetOpen("""","
6699,"                            INTERNET_OPEN_TYPE_DIRECT,"
6700,"                            NULL,"
6701,"                            NULL,"
6702,                            0);
6703,
6704,"    hConnect = InternetConnect(hSession,"
6705,"                                host,"
6706,"                                port,"
6707,"                                NULL,"
6708,"                                NULL,"
6709,"                                INTERNET_SERVICE_HTTP,0,1);"
6710,"    hRequest = HttpOpenRequest(hConnect,"
6711,"                                ""GET"", "
6712,"                                endpoint,"
6713,"                                _T(""HTTP/1.1""),"
6714,"                                NULL,"
6715,"                                accept,"
6716,"                                INTERNET_FLAG_IGNORE_CERT_CN_INVALID|INTERNET_FLAG_SECURE,1);"
6717,"    if (!InternetSetOption(hRequest, INTERNET_OPTION_SECURITY_FLAGS, &dwFlags, dwBuffLen))"
6718,"        printf(""Failed to set options Error: %ld\n"", GetLastError());"
6719,    if (hRequest == NULL)
6720,"        printf(""Error: %ld\n"", GetLastError());"
6721,"    if (InternetQueryOption (hRequest, INTERNET_OPTION_SECURITY_FLAGS, &dwFlags, &dwBuffLen))"
6722,    {
6723,        dwFlags |= SECURITY_FLAG_IGNORE_UNKNOWN_CA|SECURITY_FLAG_IGNORE_CERT_CN_INVALID|SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
6724,"        InternetSetOption (hRequest, INTERNET_OPTION_SECURITY_FLAGS, &dwFlags, sizeof (dwFlags));"
6725,    }
6726,"    if (HttpSendRequest(hRequest, hdrs, strlen(hdrs), data, dlen))"
6727,    {
6728,        DWORD received;
6729,        char tmp[MAX_LEN];
6730,"        while (InternetReadFile(hRequest, tmp, MAX_LEN, &received) && received)   "
6731,"            printf(""%s\n"", tmp);"
6732,    }
6733,    return 0;
6734,}
6735,InternetSetOption
6736,"int compare_num(int num1, int num2)"
6737,{
6738,    return (int)(((num1 + num2) - sqrt((num1 - num2) * (num1 - num2))) / 2);
6739,}
6740,"bool_t is_increasing2(int arr[], int size)"
6741,{
6742,    int tmin = arr[0];
6743,    int res = 0;
6744,    for (int i = 0; i < size - 1; i++)
6745,    {
6746,"        tmin = compare_num(arr[i + 1], tmin);"
6747,        res = tmin ^ arr[i + 1];
6748,    }
6749,
6750,    return res;
6751,}
6752,int main(void)
6753,{
6754,"    int arr[] = {10, 9, 8, 7, 6, 5};"
6755,"    int arr2[] = {1, 2, 3, 4, 5};"
6756,"    int res = is_increasing2(arr2, N);"
6757,
6758,    if (res == 0)
6759,    {
6760,"        printf(""Decreasing\n"");"
6761,    }
6762,    else
6763,    {
6764,"        printf(""Increasing\n"");"
6765,    }
6766,    return 0;
6767,}
6768,"bool_t is_increasingSine2(int arr[], int size){"
6769,    int tmax = 0;
6770,    int res = 0;
6771,    for(int i = 0; i < size; i += 3){
6772,        for(int j = i; j < i + 2 && j < size - 1; j++){
6773,"            tmax = compare_num(arr[j], arr[j + 1]);"
6774,            res = tmax ^ arr[j + 1];
6775,        }
6776,"     //There if res == 0 part of sine is increasing otherwise not, but what to do next???"
6777,    }
6778,
6779,    return 0;
6780,}
6781,a ? b : c
6782,a && b || !a && c
6783,printf
6784,#include <stdio.h>
6785,#include <stdlib.h>
6786,
6787,
6788,"/*  Given array Array with N elements, return true iff each of the first two"
6789,"    elements is less than the one following it, each of the next two is greater"
6790,"    than the one following it, and then repeating in a cycle until the end of"
6791,    the array.
6792,*/
6793,"static _Bool TestCriterion(int Array[], size_t N)"
6794,{
6795,    /*  Iterate through each element of the array except the last (the one
6796,"        with index N-1), since there is no element following the last element"
6797,        to compare it to.
6798,    */
6799,    for (size_t i = 0; i < N-1; ++i)
6800,    {
6801,"        /*  Set phase to 0 for the first two elements, 1 for the next two,"
6802,"            then 0, 1, 0, 1…  Note that while ""i & 2"" has the value 0 or 2,"
6803,            assigning it to a Boolean produces a value of 0 or 1.
6804,        */
6805,        _Bool Phase = i & 2;
6806,
6807,"        /*  For phase 0, test whether the element with index i is less than"
6808,"            the element with index i+1, and return false (0) if it is not.  For"
6809,"            phase 1, compare element i+1 with element i."
6810,        */
6811,        if (! (Array[i+Phase] < Array[i+1-Phase]))
6812,            return 0;
6813,    }
6814,
6815,"    //  All elements passed the test, so return true (1)."
6816,    return 1;
6817,}
6818,
6819,
6820,/*  Compute the number of elements in an array by dividing the size of the
6821,    array by the size of an element.
6822,*/
6823,#define NumberOf(a) (sizeof (a) / sizeof *(a))
6824,
6825,
6826,int main(void)
6827,{
6828,"    int Array[] = { 1, 2, 3, 2, 1, 2, 3, 2, 1 };"
6829,
6830,"    printf(""%s.\n"", TestCriterion(Array, NumberOf(Array)) ? ""Passes"" : ""Fails"");"
6831,}
6832,leerVectorDeEnteros
6833,"void leerVectorDeEnteros(char mensaje[], int vec[], int cant) {"
6834,"   printf(""%s\n"", mensaje);"
6835,   for(int i = 0; i < cant; i++){
6836,"        printf(""[%d]: "", i);"
6837,"        scanf(""%d"", &(vec[i]));"
6838,  }
6839,}
6840,
6841,"void leerVectorDeFloats(char mensaje[], float vec[], int cant) {"
6842,"   printf(""%s\n"", mensaje);"
6843,   for(int i = 0; i < cant; i++){
6844,"        printf(""[%d]: "", i);"
6845,"        scanf(""%f"", &vec[i]);"
6846,   }
6847,}
6848,
6849,"void leerVectorDeCaracteres(char mensaje[], char vec[], int cant) {"
6850,"   printf(""%s\n"", mensaje);"
6851,   for(int i = 0; i < cant; i++){
6852,"        printf(""[%d]: "", i);"
6853,        fflush(stdin);
6854,"        scanf(""%c"", &vec[i]);"
6855,   }
6856, } 
6857,void main() {
6858,  char vec[3];
6859,"  leerVectorDeCaracteres(""Ingrese los valores del vector:"",vec[3],3);"
6860,"  mostrarVectorDeCaracteres(vec[3],3);"
6861,}
6862,vec[3]
6863,vec
6864,fflush(stdin);
6865,"scanf("" %c"", &vec[i]);"
6866,#include <stdio.h>
6867,#include <termios.h>
6868,#include <unistd.h>
6869,
6870,#define ARRAY_SIZE 99
6871,
6872,int main() {
6873,"  struct termios old_tio, new_tio;"
6874,
6875,  /* get the terminal settings for stdin */
6876,"  tcgetattr(STDIN_FILENO, &old_tio);"
6877,
6878,  /* we want to keep the old setting to restore them a the end */
6879,  new_tio = old_tio;
6880,
6881,  /* disable canonical mode (buffered i/o) and local echo */
6882,  new_tio.c_lflag &= (~ICANON & ~ECHO);
6883,
6884,  /* set the new settings immediately */
6885,"  tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);"
6886,
6887,"  int c, length, lengthArray[ARRAY_SIZE], word, lastChar, longestWord;"
6888,
6889,  word = 0;
6890,  longestWord = 0;
6891,
6892,  while ((c = getchar()) != 'q') {
6893,    if (c == ' ' || c == '\t' || c == '\n') {
6894,      if (lastChar != ' ' && lastChar != '\t' && lastChar != '\n') {
6895,        lengthArray[word] = length;
6896,        word++;
6897,        length = 0;
6898,      }
6899,    } else {
6900,      length++;
6901,      if (length > longestWord)
6902,        longestWord = length;
6903,    }
6904,    putchar(c);
6905,    lastChar = c;
6906,  }
6907,
6908,  int histogram[longestWord];
6909,  for (int i = 0; i < longestWord; i++) {
6910,    histogram[i] = 0;
6911,  }
6912,
6913,  for (int i = 0; i < word; i++) {
6914,    histogram[lengthArray[i]] += 1;
6915,  }
6916,
6917,  for (int i = 0; i < longestWord; i++) {
6918,"    printf(""%d: %d\n"", i, histogram[i]);"
6919,  }
6920,
6921,  /* restore the former settings */
6922,"  tcsetattr(STDIN_FILENO, TCSANOW, &old_tio);"
6923,
6924,  return 0;
6925,}
6926,  for (int i = 0; i < longestWord; i++) {
6927,"    printf(""%d: %d\n"", i, histogram[i]);"
6928,  }
6929,"int c, length, lengthArray"
6930,lastChar
6931,length
6932,exercise 13
6933,K&R
6934,main()
6935,player_name
6936,player_score
6937,//HEADERS
6938,#include <stdio.h>
6939,#include <stdlib.h>
6940,#include <time.h>
6941,#define FALSE 0
6942,#define TRUE 1
6943,
6944,//TYPEDEF STRUCTS
6945,typedef struct
6946,{
6947,    int player_score;
6948,    char *player_name;
6949,} HS_Player;
6950,
6951,//FUNCTION PROTOTYPES
6952,int Random_Value(void);
6953,int Get_User_Choice(void);
6954,"int Check_Result(int computer, int my_choice);"
6955,"int Try_Again(int game_result, int computer);"
6956,"void Player_Infos(HS_Player *player_p, int score); "
6957,int Game_Restart(void);
6958,
6959,//MAIN 
6960,int main(void)
6961,{
6962,    int end_game;
6963,    int high_score_value = 100;
6964,    HS_Player player;
6965,
6966,    while (end_game != TRUE)
6967,    {
6968,        int computer_number = Random_Value();
6969,"        printf(""Guess the number between 0 et 20 chosen by the computer.\n"");"
6970,
6971,        int your_number = Get_User_Choice();
6972,"        int result_game = Check_Result(computer_number, your_number);   "
6973,"        int tries_to_win = Try_Again(result_game, computer_number);"
6974,
6975,"        printf(""Number of tries: %i\n"", tries_to_win);  "
6976,        if (tries_to_win < high_score_value)
6977,        {
6978,"            Player_Infos(&player, tries_to_win );"
6979,            high_score_value = player.player_score;
6980,        }
6981,"        printf(""Highest score: %i   By: %s\n"", player.player_score, player.player_name);"
6982,"        printf(""\n"");"
6983,
6984,        end_game = Game_Restart();
6985,
6986,    }
6987,    return EXIT_SUCCESS;
6988,}
6989,
6990,//Random_Value FUNCTION
6991,int Random_Value(void)
6992,{
6993,    srand(time(NULL));
6994,    int x = rand();
6995,    int y  = x  % 20;
6996,    return y;
6997,}
6998,
6999,//Get_User_Choice FUNCTION
7000,int Get_User_Choice(void)
7001,{
7002,"    int success, x;"
7003,    char ch;
7004,
7005,"    printf(""Your Guess:\t"");"
7006,"    success = scanf(""%i"", &x);"
7007,    while (success != 1)
7008,    {
7009,"        printf(""Your input is not a number. Please try again:\t"");"
7010,        while ((ch = getchar()) != '\n' && ch != EOF);
7011,"        success = scanf(""%i"", &x);"
7012,    }
7013,    if (x < 0 || x > 20)
7014,    {
7015,"        printf(""Your input must be between 0 and 20. Please try again.\n"");"
7016,        Get_User_Choice();
7017,    }
7018,    return x;
7019,}
7020,
7021,//Check_Result FUNCTION
7022,"int Check_Result(int computer, int my_choice)"
7023,{
7024,    int check_result;
7025,
7026,    if (my_choice < computer)
7027,    {
7028,"        printf(""Computer number is larger!\n"");"
7029,        check_result = FALSE;
7030,    }
7031,    else if (my_choice > computer)
7032,    {
7033,"        printf(""Computer number is smaller!\n"");"
7034,        check_result = FALSE;
7035,    }
7036,    else if (my_choice == computer)
7037,    {
7038,"        printf(""It's a Match! You chose the same number than the computer.\n"");"
7039,"        printf(""\n"");"
7040,        check_result = TRUE;
7041,    }
7042,    return check_result;
7043,}
7044,
7045,//Try_Again FUNCTION
7046,"int Try_Again(int game_result, int computer)"
7047,{
7048,    int tries_befor_success = 1;
7049,    while (game_result != TRUE)
7050,    {
7051,        int your_number = Get_User_Choice();
7052,"        game_result = Check_Result(computer, your_number);"
7053,        tries_befor_success++;
7054,    }
7055,    return tries_befor_success;
7056,}
7057,
7058,//Player_Infos FUNCTION
7059,"void Player_Infos(HS_Player *player_p, int score)"
7060,{
7061,    char new_name[80];
7062,"    printf(""Congrats! Your made a new high score.\n"");"
7063,"    printf(""What's your name ?\t"");"
7064,"    scanf(""%s"", new_name);"
7065,"    printf(""\n"");"
7066,
7067,    player_p->player_score = score;
7068,    player_p->player_name = new_name;
7069,}
7070,
7071,//Game_Restart FUNCTION
7072,int Game_Restart(void)
7073,{
7074,    int quit_value;
7075,"    printf(""Quit Game ?\n"");"
7076,"    printf(""Press 'y' to quit or any other keys to continue.\n"");"
7077,    fflush(stdin);
7078,    char quit_game = getchar();
7079,"    printf(""\n"");"
7080,
7081,    if (quit_game == 'y')
7082,    {
7083,        quit_value = TRUE;
7084,    }
7085,    else
7086,    {
7087,        quit_value = FALSE;
7088,    }
7089,    return quit_value;
7090,}
7091,Player_Infos()
7092,new_name
7093,Player_Infos
7094,Player_Infos
7095,Player_Infos
7096,char* player_name
7097,player_score
7098,strdup()
7099,char new_name[80];
7100,free()
7101,player_name
7102,char
7103,strcpy()
7104,player_name
7105,char [80]
7106,typedef struct
7107,{
7108,    int player_score;
7109,    char player_name[80];
7110,} HS_Player;
7111,
7112,//...
7113,
7114,"void Player_Infos(HS_Player *player_p, int score)"
7115,{
7116,"    printf(""Congrats! Your made a new high score.\n"");"
7117,"    printf(""What's your name ?\t"");"
7118,    // Read directly. Limit input to 79 chars (allowing room for null terminator).
7119,"    scanf(""%79s"", player_p->player_name); "
7120,"    printf(""\n"");"
7121,    player_p->player_score = score;
7122,}
7123,score
7124,name
7125,//TYPEDEF STRUCTS
7126,typedef struct
7127,{
7128,    int player_score;
7129,    char player_name[80];
7130,} HS_Player;
7131,//Player_Infos FUNCTION
7132,"void Player_Infos(HS_Player *player_p, int score)"
7133,{
7134,    char new_name[80];
7135,"    printf(""Congrats! Your made a new high score.\n"");"
7136,"    printf(""What's your name ?\t"");"
7137,"    scanf(""%s"", new_name);"
7138,"    printf(""\n"");"
7139,
7140,    player_p->player_score = score;
7141,"    strcpy(player_p->player_name, new_name);"
7142,    //player_p->player_name = new_name;
7143,}
7144,Computer number is smaller!
7145,Your Guess: 4
7146,It's a Match! You chose the same number than the computer.
7147,
7148,Number of tries: 8
7149,Highest score: 4   By: Craig
7150,player.player_name
7151,player_p->player_name = new_name;
7152,player_p->player_name
7153,new_name
7154,new_name
7155,player_p->player_name
7156,prlayer_name
7157,char* player_name
7158,char player_name[80]
7159,strcpy()
7160,#include <string.h>
7161,
7162,// [...]
7163,
7164,//TYPEDEF STRUCTS
7165,typedef struct
7166,{
7167,    unsigned int player_score;
7168,    char player_name[80];
7169,} HS_Player;
7170,
7171,// [...]
7172,
7173,//Player_Infos FUNCTION
7174,"void Player_Infos(HS_Player *player_p, int score)"
7175,{
7176,    char new_name[80];
7177,"    printf(""Congrats! Your made a new high score.\n"");"
7178,"    printf(""What's your name ?\t"");"
7179,"    scanf(""%s"", new_name);"
7180,"    printf(""\n"");"
7181,
7182,    player_p->player_score = score;
7183,"    strcpy(player_p->player_name, new_name);"
7184,}
7185,"int Save_Score(char* filename, HS_Player* player)"
7186,{
7187,"    FILE* file = fopen(filename, ""w"");"
7188,    if (file == NULL)
7189,    {
7190,"        fprintf(stderr, ""\nAn error occurred while opening the file\n"");"
7191,        return -1;
7192,    }
7193,
7194,"    if (fprintf(file, ""%d %s"", player->player_score, player->player_name) < 0)"
7195,        return -1;
7196,
7197,    fclose(file);
7198,
7199,    return 0;
7200,}
7201,
7202,"int Load_Score(char* filename, HS_Player* player)"
7203,{
7204,"    FILE* file = fopen(filename, ""r"");"
7205,    if (file == NULL)
7206,    {
7207,"        fprintf(stderr, ""\nAn error occurred while opening the file\n"");"
7208,        return -1;
7209,    }
7210,
7211,"    if (fscanf(file, ""%d %79s"", &player->player_score, player->player_name) < 0)"
7212,        return -1;
7213,
7214,    fclose(file);
7215,
7216,    return 0;
7217,}
7218,sub.h:1:6: warning conflicting types for built-in function 'isdigit' bool isdigit(char c)
7219,
7220,In file included from sub.c:1:0:
7221,sub.h:1:1: error: unknown type name 'bool'
7222, bool isdigit(char c)
7223,
7224,sub.h:1:6: warning: conflicting types for built-in function 'isdigit'
7225, bool isdigit(char c)
7226,
7227,sub.c:7:6: error: conflicting types for 'isdigit'
7228, bool isdigit(char c)
7229,
7230,In file included from sub.c:1:0:
7231,sub.h:1:6: note: previous declaration of 'isdigit' was here
7232, bool isdigit(char c)
7233,//main.c
7234,#include<stdio.h>
7235,#include<stdbool.h>
7236,#include<string.h>
7237,#include<stdlib.h>
7238,"#include ""sub.h"""
7239,
7240,#define N 120
7241,
7242,int main (void){
7243,
7244,    char eingabe[N+1]={0};
7245,    int zahlen[10]={0};
7246,
7247,"    fgets(eingabe,N,stdin);"
7248,
7249,    for(int i=0; i<N; i++){
7250,        if(isdigit(eingabe[i]))
7251,        {
7252,            int zahl = toNumber(eingabe[i]);
7253,            zahlen[zahl]= zahlen[zahl]+1;
7254,        }
7255,    }
7256,
7257,    for (int j=0; j<10; j++)
7258,    {
7259,"        printf(""%d: %d \n"",j, zahlen[j]);"
7260,    }
7261,    return 0;
7262,}
7263,// sub.h
7264,bool isdigit(char c);
7265,int toNumber(char c);
7266,//sub.c
7267,"#include ""sub.h"""
7268,#include <stdio.h>
7269,#include <stdbool.h>
7270,#include <stdlib.h>
7271,
7272,bool isdigit(char c){
7273,    bool Antwort = false;
7274,    for(int i='0'; i<= '9'; i++){
7275,        if(c==i){
7276,            Antwort = true;
7277,        }
7278,    }
7279,    return Antwort;
7280,}
7281,
7282,int toNumber (char c){
7283,    int num =0;
7284,    num = c- '0';
7285,    return num;
7286,}
7287,isdigit
7288,isDigit
7289,toNumber
7290,isdigit()
7291,isdigit
7292,stdbool.h
7293,sub.h
7294,stdbool.h
7295,sub.h
7296,bool
7297,stdbool.h
7298,sub.h
7299,isdigit
7300,"PHP_METHOD(NaviModel, addRules) {"
7301,"    zval *ruleParam, *rules, function, rv, args[2];"
7302,
7303,"    ZEND_PARSE_PARAMETERS_START(1, 1)"
7304,        Z_PARAM_ZVAL(ruleParam)
7305,    ZEND_PARSE_PARAMETERS_END();
7306,
7307,"    rules = zend_read_property(naviModelCe, Z_OBJ_P(ZEND_THIS), ZEND_STRL(""rules""), ZEND_FETCH_CLASS_SILENT, &rv);"
7308,
7309,"    ZVAL_STRING(&function, ""array_replace_recursive"");"
7310,    args[0] = *ruleParam;
7311,    args[1] = *rules;
7312,
7313,"    call_user_function(NULL, NULL, &function, rules, 2, args);"
7314,
7315,    zval_ptr_dtor(ruleParam);
7316,    zval_ptr_dtor(&function);
7317,    zval_dtor(args);
7318,}
7319,==52047== Invalid read of size 4
7320,==52047==    at 0x708994: zend_gc_addref (zend_types.h:1161)
7321,==52047==    by 0x70C02F: zend_call_function (zend_execute_API.c:798)
7322,==52047==    by 0x70B983: _call_user_function_impl (zend_execute_API.c:659)
7323,==52047==    by 0x72A4707: zim_NaviModel_addRules (model.c:98)
7324,==52047==    by 0x76651B: ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER (zend_vm_execute.h:1755)
7325,==52047==    by 0x7E8E9F: execute_ex (zend_vm_execute.h:55172)
7326,==52047==    by 0x7ED5A7: zend_execute (zend_vm_execute.h:59499)
7327,==52047==    by 0x725AAB: zend_execute_scripts (zend.c:1694)
7328,==52047==    by 0x676877: php_execute_script (main.c:2543)
7329,==52047==    by 0x833443: do_cli (php_cli.c:949)
7330,==52047==    by 0x8342E7: main (php_cli.c:1337)
7331,==52047==  Address 0x715b380 is 0 bytes inside a block of size 56 free'd
7332,==52047==    at 0x4851A40: free (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)
7333,==52047==    by 0x6E651B: _efree_custom (zend_alloc.c:2427)
7334,==52047==    by 0x6E669B: _efree (zend_alloc.c:2547)
7335,==52047==    by 0x73F673: zend_array_destroy (zend_hash.c:1662)
7336,==52047==    by 0x720FC7: rc_dtor_func (zend_variables.c:57)
7337,==52047==    by 0x720F3F: i_zval_ptr_dtor (zend_variables.h:44)
7338,==52047==    by 0x72117B: zval_ptr_dtor (zend_variables.c:84)
7339,==52047==    by 0x72B02D3: naviModelNewsRules (news.c:35)
7340,==52047==    by 0x72B09FF: zim_NaviModelNews___construct (news.c:104)
7341,==52047==    by 0x76651B: ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER (zend_vm_execute.h:1755)
7342,==52047==    by 0x7E8E9F: execute_ex (zend_vm_execute.h:55172)
7343,==52047==    by 0x7ED5A7: zend_execute (zend_vm_execute.h:59499)
7344,zval retval;
7345,"call_user_function(NULL, NULL, &function, &retval, 2, args);"
7346,SDL_PollEvent
7347,SDL_SetEventFilter
7348,SDL_WINDOWEVENT_RESIZED
7349,SDL_WINDOWEVENT_SIZE_CHANGED
7350,SDL_WINDOWEVENT_RESIZED
7351,SDL_WINDOWEVENT_RESIZED
7352,#include <stdio.h>
7353,
7354,int main() {
7355,"  int n,v[100],i;"
7356,  float average;
7357,
7358,  int sum=0;
7359,"  scanf(""%d"",&n);"
7360,
7361,  for (i = 0; i < n; ++i) {
7362,"    scanf(""%d"",&v[i]);"
7363,  }
7364,      
7365,  for(i=0;i<n;i+=3) {
7366,    sum=v[i]+v[i+1]+v[i+3];
7367,    average=sum/3;
7368,"    printf(""%.2f "", average);"
7369,  }
7370,
7371,  return 0;
7372,}
7373,for(i=0; i<n; i+=3)
7374,+= 3
7375,sum/3
7376,int
7377,int
7378,// average=sum/3;
7379,average = sum / 3.0f;
7380,for(i=0;i<n;i+=3) { sum=v[i]+v[i+1]+v[i+3];
7381,v[]
7382,v[i]+v[i+1]+v[i+3]
7383,v[i]+v[i+1]+v[i+2]
7384,for (i = 0; i + 2 < n; i += 3) {
7385,  sum = v[i] + v[i+1] + v[i+2];
7386,float
7387,double
7388,float
7389,for(int i = 0; i+2 < n; i += 3) {
7390,  double sum = 0.0 + v[i] + v[i+1] + v[i+2]; // Addition here uses FP math.
7391,  double average = sum/3.0;
7392,"  printf(""%.2f "", average);"
7393,}
7394,'\n'
7395,""" """
7396,"const char *separator = """";"
7397,for(int i = 0; i+2 < n; i += 3) {
7398,  ...
7399,"  printf(""%s%.2f "", separator, average);"
7400,"  separator = "" "";"
7401,}
7402,"printf(""\n"");"
7403,#include<stdio.h>
7404,int main()
7405,{
7406,"    int a=5, b=2; "
7407,"    printf(""%d"",a+++b);"
7408,}
7409,#include<stdio.h>
7410,int main()
7411,{
7412,"    int a=5, b=2; "
7413,"    printf(""%d"",a++ + b); "
7414,}
7415,#include<stdio.h>
7416,int main()
7417,{
7418,"    int a=5, b=2; "
7419,"    printf(""%d"",a+++b); "
7420,"    printf(""\n%d"",a++ + b); "
7421,}
7422,a++
7423,a
7424,6
7425,printf
7426,a++
7427,a + 1
7428,a++
7429,b
7430,a++
7431,a++
7432,a
7433,a
7434,printf()
7435,printf()
7436,a
7437,printf
7438,++
7439,++
7440,--
7441,i++ + i++
7442,"printf(""%d %d %d\n"", a++, ++a, a)"
7443,for(int i=0;i<sz;i=i+1)
7444,++
7445,--
7446,i = i + 1
7447,++
7448,--
7449,++x
7450,x++++++x
7451,x++ ++ +x
7452,x++ + ++x
7453,a++
7454,a
7455,a++ + b
7456,8
7457,printf
7458,7
7459,a
7460,5
7461,solution
7462,#include <stdio.h>
7463,#include <string.h>
7464,
7465,double atof(s) /* convert string s to double */
7466,char s[];
7467,{
7468,"    double val, power;"
7469,"    int i, sign;"
7470,
7471,    for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++)
7472,        ; /* skip white space */
7473,    sign = 1;
7474,    if (s[i] == '+' || s[i] == '-') /* sign */
7475,        sign = (s[i++] == '+') ? 1 : -1;
7476,    for (val = 0; s[i] >= '0' && s[i] <= '9'; i++)
7477,        val = 10 * val + s[i] - '0';
7478,    if (s[i] == '.')
7479,        i++;
7480,    for (power = 1; s[i] >= '0' && s[i] <= '9'; i++)
7481,    {
7482,        val = 10 * val + s[i] - '0';
7483,        power *= 10;
7484,    }
7485,    return (sign * val / power);
7486,}
7487,
7488,"int main(int argc, char *argv[])"
7489,{
7490,    char str[20];
7491,    double atof();
7492,    double solution;
7493,"    strcpy(str, ""53.44"");"
7494,    solution = atof(str);
7495,"    printf(""string: %s\n"", str);"
7496,"    printf(""solution: %d\n"", solution);"
7497,}
7498,string: 53.44 solution: -1136176480
7499,double atof(s) /* convert string s to double */ char s[]; 
7500,for
7501,if
7502,'\0'
7503,      #include<stdio.h>
7504,
7505,
7506,"      void swap( int* x, int* y)"
7507,      {
7508,        int t = *x;
7509,        *x = *y;
7510,        *y = t;
7511,      }
7512,
7513,"      int part( int a[], int l, int h )"
7514,      {
7515,"         int i = l-1, p = a[h] ;"
7516,
7517,         for( int j=l; j<= h-1; j++ )
7518,      {
7519,         if( a[j]<p )
7520,        {   
7521,            i++;
7522,"            swap( &a[i], &a[j] );"
7523,        }   
7524,      }
7525,
7526,"        swap( &a[i+1], &p);"
7527,
7528,        return (i+1);
7529,      }
7530,
7531,"      void qsort( int a[], int l, int h )"
7532,      {
7533,        if( l<h )
7534,          {
7535,"            int pi = part( a, l, h);"
7536,
7537,"            qsort( a, (pi+1), h );"
7538,
7539,"           qsort( a, l, (pi-1) );"
7540,          }
7541,      }
7542,
7543,"     void print_arr( int a[], int n )"
7544,     {
7545,        for( int i=0; i<n; i++ )
7546,         {
7547,"            printf(""%d"", a[i] );"
7548,         } 
7549,     }
7550,
7551,
7552,   int main()
7553,  {
7554,"     int a[100], n ;"
7555,
7556,"     printf(""Enter the total no. of elements in the array : "");"
7557,"       scanf(""%d"", &n );"
7558,
7559,"     printf(""Enter the elements in the array : "");"
7560,       for(int i=0; i<n; i++)
7561,     {
7562,"           scanf(""%d"", &a[i] );"
7563,     }
7564,
7565,"     qsort( a, 0, (n-1) );"
7566,
7567,"     printf(""The sorted array is : "");"
7568,"      print_arr( a, n );"
7569,
7570,    return 0 ;
7571,  }
7572,"printf(""%d"", a[i] );"
7573,int i = l-1
7574,a[i]
7575,l
7576,0
7577,"int part( int a[], int l, int h )"
7578,{
7579,"    int i = l-1, p = a[h] ;"
7580,
7581,
7582,
7583,    for( int j=l; j< h; j++ )
7584,    {
7585,        if( a[j]<p )
7586,        {
7587,            i++;
7588,"            swap( &a[i], &a[j] );"
7589,        }
7590,    }
7591,
7592,"    //swap( &a[i+1], &p);       "
7593,"    swap( &a[i+1], &a[h]);      /* Using &p just updates a work field and not the array */"
7594,
7595,    return (i+1);
7596,}
7597,File > Auto Save
7598,.dll
7599,int
7600,long long
7601,struct
7602,malloc
7603,free
7604,abs
7605,#include ...
7606,__declspec(dllexport)
7607,#include <...>
7608,...
7609,/MT
7610,/O1 /GR- /GS- /GL /EHscr- /LD /Zl /link /NODEFAULTLIB /OPT:REF /OPT:ICF=9 kernel32.lib user32.lib
7611,/Zl
7612,DllMain
7613,DllMainCRTStartup
7614,/Zl
7615,/LD
7616,/MT
7617,/MD
7618,*crt*
7619,*vc*
7620,"printf(""This is sentence 1. "");"
7621,"write(STDOUT_FILENO, ""This is sentence 2.\n"", 20);"
7622,This is sentence 2.
7623,This is sentence 1. 
7624,"printf(""This is sentence 1. "");"
7625,fflush(stdout);
7626,"write(STDOUT_FILENO, ""This is sentence 2.\n"", 20);"
7627,This is sentence 1. This is sentence 2.
7628,"FILE *file = fdopen(STDOUT_FILENO, ""w"");"
7629,"printf(""This is sentence 1. "");"
7630,fflush(file);
7631,"write(STDOUT_FILENO, ""This is sentence 2.\n"", 20);"
7632,This is sentence 2.
7633,This is sentence 1.
7634,int fd = fileno(stdout);
7635,if(fd == STDOUT_FILENO)
7636,"    printf(""fd == STDOUT_FILENO == %d\n"", fd);"
7637,fd == STDOUT_FILENO == 1
7638,FILE
7639,printf
7640,stdout
7641,stdout
7642,fflush
7643,"FILE *file = fdopen(STDOUT_FILENO, ""w"");`"
7644,FILE
7645,fflush
7646,stdout
7647,stdout
7648,stdout
7649,fflush
7650,\n
7651,printf
7652,stdout
7653,"FILE *file = fdopen(STDOUT_FILENO, ""w"");"
7654,"printf(""This is sentence 1. "");"
7655,fflush(file);
7656,"write(STDOUT_FILENO, ""This is sentence 2.\n"", 20);"
7657,printf
7658,file
7659,stdout
7660,FILE
7661,"printf(""This is sentence 1. "");"
7662,stdout
7663,FILE
7664,fflush(file);
7665,file
7666,"fprintf(file, ""This is sentence 1. "");"
7667,file
7668,fflush(file);
7669,#include <stdio.h>
7670,
7671,void reverse(char theline[150]){
7672,"    int i, j;"
7673,    char tmp[150];
7674,    for (i = 0; theline[i] != 0; i++){
7675,        tmp[i] = theline[i];
7676,    }
7677,    for (j = 0; i >= 0; j++){
7678,        theline[j] = tmp[i];
7679,        i--;
7680,    }
7681,}
7682,
7683,int main() {
7684,    char line[150];
7685,    char c;
7686,    int counter = 0;
7687,    do {
7688,        counter = 0;
7689,        while (((c = getchar()) != '\n') && (c != EOF)) { //one line loop
7690,            line[counter] = c;
7691,            counter++;
7692,        }
7693,        if (counter > 80){
7694,            reverse(line);
7695,"            printf(""%s\n"", line);"
7696,        }
7697,    } 
7698,    while (c != EOF);
7699,
7700,    return 0;
7701,}
7702,EOF
7703,char c;
7704,int c;
7705,    while (((c = getchar()) != '\n') && (c != EOF)) { //one line loop
7706,        line[counter] = c;
7707,        counter++;
7708,    }
7709,'\0'
7710,for (i = 0; theline[i] != 0; i++){
7711,    tmp[i] = theline[i];
7712,}
7713,'\0'
7714,for (i = 0; theline[i] != 0; i++){
7715,    tmp[i] = theline[i];
7716,}
7717,for (j = 0; i >= 0; j++){
7718,    theline[j] = tmp[i];
7719,    i--;
7720,}
7721,theline
7722,c
7723,int
7724,char
7725,signed char
7726,unsigned char
7727,unsigned char
7728,c != EOF
7729,char * reverse( char theline[] )
7730,{
7731,    size_t i = 0;
7732,
7733,    while ( theline[i] != '\0' ) i++;
7734,
7735,    size_t j = 0;
7736,
7737,    while ( j < i )
7738,    {
7739,        char c = theline[j];
7740,        theline[j++] = theline[--i];
7741,        theline[i] = c;
7742,    }
7743,
7744,    return theline;
7745,}
7746,#include <stdio.h>
7747,
7748,char * reverse( char theline[] )
7749,{
7750,    size_t i = 0;
7751,
7752,    while ( theline[i] != '\0' ) i++;
7753,
7754,    size_t j = 0;
7755,
7756,    while ( j < i )
7757,    {
7758,        char c = theline[j];
7759,        theline[j++] = theline[--i];
7760,        theline[i] = c;
7761,    }
7762,
7763,    return theline;
7764,}
7765,
7766,int main( void ) 
7767,{
7768,"    char s[] = ""Hello World!"";"
7769,
7770,    puts( s );
7771,    puts( reverse( s ) );
7772,}
7773,Hello World!
7774,!dlroW olleH
7775,#include <stdio.h>
7776,
7777,int main() {
7778,
7779,    for( ;; ) {
7780,        char line[ 150 ];
7781,"        int c, counter = sizeof line;"
7782,
7783,        line[ --counter ] = '\0';
7784,
7785,"        // NB: EOF is an int, not a char"
7786,        while( ( c = getchar() ) != '\n' && c != EOF && counter > 0 )
7787,            line[ --counter ] = (char)c;
7788,
7789,"        printf( ""%s\n\n"", line + counter );"
7790,        counter = sizeof line;
7791,    }
7792,
7793,    return 0;
7794,}
7795,the quick
7796,kciuq eht
7797,
7798,Once upon a time in a land far awy
7799,ywa raf dnal a ni emit a nopu ecnO
7800,
7801,I wish I was what I was when I wished I was what I am now.
7802,.won ma I tahw saw I dehsiw I nehw saw I tahw saw I hsiw I
7803,getchar()
7804,    public static void main(String[] args) {
7805,        ArrayList<String> dict = new ArrayList<>();
7806,"        dict.add(""cat"");"
7807,"        dict.add(""tag"");"
7808,"        dict.add(""got"");"
7809,"        dict.add(""get"");"
7810,"        dict.add(""tog"");"
7811,        int k = 3;
7812,"        helper(k, dict, new ArrayList<String>());"
7813,    }
7814,
7815,"    public static void helper(int k, ArrayList<String> dict, ArrayList<String> seq) {"
7816,        if (seq.size() == k) {
7817,            System.out.println(seq);
7818,            return;
7819,        }
7820,        for (int i = 0; i < dict.size(); i++) {
7821,            seq.add(dict.get(i));
7822,"            helper(k, dict, seq);"
7823,            seq.remove(dict.get(i));
7824,        }
7825,    }
7826,#include <stdio.h>
7827,
7828,"void sequence(int k, char *seq[], char[] **dic){"
7829,    // base case
7830,    int num = sizeof(seq) / sizeof(seq[0]);
7831,    if(num == k){
7832,        //print
7833,        //return
7834,    }
7835,    for(int i = 0; i < k; i++){
7836,       //recurse 
7837,    }
7838,}
7839,
7840,int main() {
7841,"    char* dict[5][10] = {""cat"", ""dog"", ""got"", ""get"", ""tog""};"
7842,"    char* seq[5][10] = {"""", """", """", """", """", """"};"
7843,    int k = 3;
7844,"    sequence(k, *seq, **dict) "
7845,    return 0;
7846,}
7847,char* dict[5][10]
7848,char dict[5][10]
7849,const char* dict[5]
7850,seq
7851,char *seq[]
7852,char **seq
7853,glfwSetKeyCallback
7854,CTRL + q
7855,ESC
7856,switch
7857,W
7858,A
7859,if
7860,#include<stdio.h>
7861,#include<stdlib.h>
7862,int main() {
7863,    int *n = malloc(sizeof(int*));//line 1
7864,"    scanf(""%d"",n);"
7865,"    printf(""%d"",*n);"
7866,}
7867,int *n = malloc(sizeof(int*));//line 1
7868,sizeof( int * )
7869,n
7870,int *
7871,int
7872,"scanf(""%d"",n);"
7873,"printf(""%d"",*n);"
7874,int *n = malloc( 8 );//line 1
7875,malloc
7876,T *t = malloc(sizeof(*t)); // or
7877,T *t = malloc(sizeof(T));
7878,malloc
7879,malloc
7880,sizeof(int)
7881,sizeof(int*)
7882,sizeof
7883,#include <stdio.h>
7884,#include <stdlib.h>
7885,
7886,#define MAX_VERTEX_NUM 60
7887,
7888,typedef struct node {
7889,    int adjvex;
7890,    int weight;
7891,    struct node* next;
7892,} EdgeNode;
7893,
7894,typedef struct vnode {
7895,    int vex; 
7896,    EdgeNode* firstedge; 
7897,"} VertexNode, AdjList[MAX_VERTEX_NUM];"
7898,
7899,typedef struct {
7900,    AdjList adjlist;
7901,    int vexnum;
7902,} ALGraph;       // adjacency list
7903,
7904,typedef struct {
7905,    int data;
7906,    int parent;
7907,}QUEUE;
7908,
7909,int num = 0;
7910,int cnt = 0;
7911,int result[3000] = { 0 };
7912,
7913,void enterArray(int* b)
7914,{
7915,    int a1 = 0;
7916,    char ch;
7917,    char en[3];
7918,    en[2] = '\0';
7919,    int a = 0;
7920,
7921,    while ((ch = getchar()) != '\n') {
7922,        if (ch == ' ') {
7923,            b[a1] = atoi(en);
7924,            a1++;
7925,            a = 0;
7926,            for (int j = 0; j < 2; j++) {
7927,                en[j] = ' ';
7928,            }
7929,        }
7930,        else {
7931,            en[a] = ch;
7932,            a++;
7933,        }
7934,    }
7935,    if (a != 0)
7936,        b[a1] = atoi(en);
7937,}
7938,
7939,"void ShortPath(ALGraph G, int s, int t, int parents[])"
7940,{
7941,    EdgeNode* p = NULL;
7942,    int w = -1;
7943,    QUEUE qu[G.vexnum];
7944,    for (int m = 0; m < G.vexnum; m++) {
7945,        qu[m].data = -1;
7946,        qu[m].parent = -1;
7947,    }
7948,
7949,"    int front = -1, rear = -1;"
7950,    int visited[G.vexnum]={0};
7951,
7952,    rear++;
7953,    qu[rear].data = s;
7954,    qu[rear].parent = -1;
7955,    visited[s] = 1;
7956,    while (front <= rear) {
7957,        front++;
7958,        w = qu[front].data;
7959,        if (w == -1)    break;
7960,        if (w == t) {
7961,            int i = front;
7962,            int aa = 0;
7963,            while (qu[i].parent != -1) {
7964,                parents[aa] = qu[i].data;
7965,                aa++;
7966,                i = qu[i].parent;
7967,            }
7968,            num++;
7969,            parents[aa] = s;
7970,            break;
7971,        }
7972,
7973,        p = G.adjlist[w].firstedge;
7974,        while (p != NULL) {
7975,            if (visited[p->adjvex] == 0 && p->weight == 1) {
7976,                visited[p->adjvex] = 1;
7977,                rear++;
7978,                qu[rear].data = p->adjvex;
7979,                qu[rear].parent = front;
7980,            }
7981,            p = p->next;
7982,        }
7983,    }
7984,}
7985,
7986,"void Reverse(ALGraph Gf, int parents[])"
7987,{
7988,    int f = 1;
7989,    int r = 0;
7990,    while (parents[f] != -10) {
7991,        EdgeNode* temp1 = Gf.adjlist[parents[f]].firstedge;
7992,        while (temp1 && temp1->adjvex != parents[r]) {
7993,            temp1 = temp1->next;
7994,        }
7995,        if (temp1 != NULL) {
7996,            temp1->weight = 0;
7997,        }
7998,
7999,        EdgeNode* temp2 = Gf.adjlist[parents[r]].firstedge;
8000,        while (temp2 && temp2->adjvex != parents[f]) {
8001,            temp2 = temp2->next;
8002,        }
8003,        if (temp2 != NULL) {
8004,            temp2->weight = 0;
8005,        }
8006,            ;
8007,        f++;
8008,        r++;
8009,    }
8010,}
8011,
8012,"void Disjoint(ALGraph G, int s, int t)"
8013,{
8014,    num = 0;
8015,    int parents[G.vexnum];
8016,    do {
8017,        for (int i = 0; i < G.vexnum; i++)
8018,            parents[i] = -10;
8019,
8020,"        ShortPath(G, s, t, parents);"
8021,"        Reverse(G, parents);"
8022,    } while (parents[0] != -10);
8023,
8024,    if (result[cnt] < num)
8025,        result[cnt] = num;
8026,}
8027,
8028,int main()
8029,{
8030,    int vex = 0;
8031,
8032,"    scanf(""%d"", &vex);"
8033,    getchar();
8034,    while (vex != 0) {
8035,        ALGraph ALG;
8036,        ALG.vexnum = vex;
8037,        // 建立顶点表
8038,        for (int i = 0; i < ALG.vexnum; i++) {
8039,            ALG.adjlist[i].vex = i;
8040,            ALG.adjlist[i].firstedge = NULL;
8041,        }
8042,
8043,        EdgeNode* temp = NULL;
8044,        for (int i = 0; i < ALG.vexnum; i++) {
8045,            int b[MAX_VERTEX_NUM];
8046,            for (int j = 0;j < MAX_VERTEX_NUM;j++)  b[j] = -1;
8047,            enterArray(b);
8048,
8049,            int a1 = 0;
8050,            while (b[a1] != -1) {
8051,                temp = (EdgeNode*)malloc(sizeof(EdgeNode));
8052,                temp->weight = 1;
8053,                temp->adjvex = b[a1++];
8054,                temp->next = ALG.adjlist[i].firstedge;
8055,                ALG.adjlist[i].firstedge = temp;
8056,            }
8057,        }
8058,
8059,        for (int s = 0; s < ALG.vexnum - 1; s++) {  //source
8060,            for (int t = s + 1; t < ALG.vexnum; t++) {  //termination
8061,"                Disjoint(ALG, s, t);"
8062,                for (int i = 0; i < ALG.vexnum; i++) {
8063,                    EdgeNode* temp1 = ALG.adjlist[i].firstedge;
8064,                    while (temp1) {
8065,                        temp1->weight = 1;
8066,                        temp1 = temp1->next;
8067,                    }
8068,                }
8069,            }
8070,        }
8071,
8072,        cnt++;
8073,"        scanf(""%d"", &vex);"
8074,        getchar();
8075,    }
8076,
8077,    for (int i = 0; i < cnt; i++)
8078,"        printf(""%d\n"", result[i]);"
8079,
8080,    return 0;
8081,}
8082,b[a1] = atoi(en);
8083,en
8084,scanf
8085,scanf()
8086,\n
8087,#include <stdio.h>
8088,"// &&, || , ! is for 'and', 'or' and 'not' respectively. in if statements."
8089,int main()
8090,{
8091,"    int age, Vippasscheck;"
8092,"    printf(""Welcome to the land of illegal driving\n"");"
8093,"    printf(""Do you have a vip pass?\n1)Yes\n2)No\n"");"
8094,"    scanf(""%d"", &Vippasscheck);"
8095,    if (Vippasscheck == 1)
8096,    {
8097,"        printf(""Congratulations, You can drive!\n"");"
8098,    }
8099,    else
8100,    {
8101,
8102,"        printf(""Please enter your age\n"");"
8103,"        scanf(""%d"", &age);"
8104,        if (age > 90 || age < 18)
8105,        {
8106,"            printf(""Sorry, You cannot drive!\n"");"
8107,        }
8108,        else
8109,        {
8110,"            printf(""Congratulations, You can drive!\n"");"
8111,        }
8112,    }
8113,
8114,    return 0;
8115,}
8116,#include<stdio.h>
8117,
8118,int main(){
8119,    int age;
8120,    int vipPass = 0;
8121,    vipPass = 1;
8122,
8123,"    printf(""Enter your age\n"");"
8124,"    scanf(""%d"", &age); "
8125,
8126,    
8127,    if ((age <= 90 && age>=18) || (vipPass==1))
8128,    {
8129,"        printf(""You are above 18 and below 90, you can drive\n"");"
8130,    }
8131,    else
8132,    {
8133,"        printf(""You cannot drive\n"");"
8134,    }
8135,   
8136,    return 0;
8137,}
8138,vippass
8139,#include <stdio.h>
8140,#include <math.h>
8141,
8142,int main(){
8143,int a=5;
8144,"printf(""the value of a is %d\n"", a);"
8145,a=7;
8146,"printf(""the value of a is %d\n"", a);"
8147,
8148,return 0;
8149,
8150,} 
8151,int vipPass = 0;
8152,vipPass = 1;
8153,vipPass
8154,i = i  + 1;
8155,i
8156,vipPass
8157,int vipPass;
8158,vipPass
8159,int vipPass = 0;
8160,vipPass = 1;
8161,int vipPass = 1;
8162,int vipPass;
8163,vipPass = 1;
8164,"""1"""
8165,'1'
8166,'1'
8167,49
8168,1
8169,"""1"""
8170,char
8171,49
8172,0
8173,long long
8174,int
8175,double
8176,O
8177,X
8178, 
8179,O
8180,X
8181,O
8182,X
8183,char
8184,#include <stdio.h>
8185,#include <stdlib.h>
8186,
8187,struct _listNode{
8188,    int item;
8189,    struct _listNode* next;
8190,};
8191,typedef struct _listNode ListNode;
8192,
8193,void printList(ListNode *head);
8194,void deleteList(ListNode **ptrHead);
8195,
8196,"void triPartition(ListNode** head, int pivot);"
8197,
8198,int main()
8199,{
8200,"    ListNode *head = NULL, *temp;"
8201,    int i = 0;
8202,    int pivot = 0;
8203,
8204,"    scanf(""%d"",&pivot);"
8205,
8206,"    while (scanf(""%d"", &i)){"
8207,        if (head == NULL){
8208,            head = (ListNode*) malloc(sizeof(ListNode));
8209,            temp = head;
8210,        }
8211,        else{
8212,            temp->next = (ListNode*) malloc(sizeof(ListNode));
8213,            temp = temp->next;
8214,        }
8215,        temp->item = i;
8216,    }
8217,    temp->next = NULL;
8218,
8219,
8220,"    triPartition(&head, pivot);"
8221,    printList(head);
8222,    deleteList(&head);
8223,
8224,    return 0;
8225,}
8226,
8227,void printList(ListNode *head){
8228,    while(head !=NULL){
8229,"        printf(""%d "",head->item);"
8230,        head = head->next;
8231,    }
8232,"    printf(""\n"");"
8233,}
8234,
8235,void deleteList(ListNode **ptrHead){
8236,    ListNode *cur = *ptrHead;
8237,    ListNode *temp;
8238,    while (cur!= NULL) {
8239,        temp=cur->next;
8240,        free(cur);
8241,        cur=temp;
8242,    }
8243,    *ptrHead=NULL;
8244,}
8245,
8246,"void triPartition(ListNode** head, int pivot){"
8247,    ListNode *cur = *head;
8248,    ListNode *nextnode = NULL;
8249,    ListNode *pre = NULL;
8250,    ListNode *temp = NULL;
8251,
8252,    while (cur != NULL) {
8253,        nextnode = cur->next;
8254,        temp = nextnode;
8255,        printList(head);
8256,        if (cur->item > pivot){
8257,            while (temp->next != NULL){
8258,                temp = temp->next;
8259,            }
8260,            temp->next = cur;
8261,            cur->next = NULL;
8262,            pre = cur;
8263,            cur = nextnode;
8264,            nextnode = cur->next;
8265,            head = cur;
8266,            temp = NULL;
8267,            printList(head);
8268,        }
8269,        if (cur->item = pivot){
8270,            pre = cur;
8271,            head = cur;
8272,            cur = cur->next;
8273,            nextnode = nextnode->next;
8274,            printList(head);
8275,        }
8276,        if (cur->item < pivot){
8277,            pre->next=nextnode;
8278,            cur->next = pre;
8279,            pre = cur;
8280,            head = cur;
8281,            cur = nextnode;
8282,            nextnode = nextnode->next;
8283,            printList(head);
8284,        }
8285,    }
8286,}
8287,*head = cur
8288,triPartition()
8289,head
8290,ListNode**
8291,ListNode*
8292,pritnList()
8293,head = cur;
8294,if (cur->item = pivot)
8295,==
8296,1 2 5 5 5 8 7
8297,"printf('matlab = %10.16f, RealWordvalue = %10.16f, Bitshift= %10.16f\n',fi((2^-14),0,32),6.103515625E-5, ( 2 ^ -14));"
8298,
8299,            matlab|     RealWordvalue|          Bitshift|
8300,------------------+------------------+------------------+
8301,0.0000610351562500|0.0000610351562500|0.0000610351562500|
8302,#define thingy ((double)1.0 >> 14)
8303,gdb
8304,"Thread 1 ""a.out"" received signal SIGSEGV, Segmentation fault."
8305,__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:76
8306,"76              VPCMPEQ (%rdi), %ymm0, %ymm1"
8307,debuginfod
8308,gdb
8309,(gdb) bt
8310,#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:76
8311,#1  0x00007ffff7e1b948 in __GI__IO_puts (str=0x0) at ioputs.c:35
8312,"#2  0x00005555555551d6 in main (argc=1, argv=0x7fffffffdb28) at main.c:6"
8313,int[]
8314,1
8315,42
8316,'*'
8317,'*'
8318,42
8319,"'*', '2','3','4'"
8320,"int arr[] = { 1, 2, '$', 4, 5 };"
8321,arr[1] = '*';
8322,int
8323,#include <stdio.h>
8324,#include <stdlib.h>
8325,
8326,struct node{
8327,    int data;
8328,    struct node * next;
8329,}*head=NULL;
8330,
8331,"void create(int A[],int n){"
8332,"    struct node* last,*t;"
8333,    head=(struct node *)malloc(sizeof(struct node));
8334,    head->data = A[0];
8335,    head->next=NULL;
8336,    last = head;
8337,    
8338,    for(int i=1;i<n;i++){
8339,        t=(struct node *)malloc(sizeof(struct node));
8340,        t->data = A[i];
8341,        last->next=t;
8342,        t->next = NULL;
8343,        last= t;
8344,    }
8345,    
8346,}
8347,void display(struct node *p){
8348,    while(p!=NULL){
8349,"        printf(""%d "",p->data);"
8350,        p=p->next;
8351,    }
8352,}
8353,
8354,void midofLL(){
8355,"    struct node *q,*p=head;"
8356,    while(q!=NULL){
8357,        q=q->next;
8358,        if(q) q=q->next;
8359,        if(q) p=p->next;
8360,    }
8361,"   printf(""%d"",p->data);"
8362,    
8363,}
8364,
8365,int main()
8366,{
8367,"  int A[]={2,3,6,7,8};"
8368,"  create(A,5);"
8369,  display(head);
8370,"  printf(""\n"");"
8371,  midofLL();
8372,}
8373,midofLL()
8374,q
8375,"struct node *q = head, *p = head;"
8376,midofLL()
8377,midofLL()
8378,q
8379,"struct node *q = head, *p = head;"
8380,q
8381,p
8382,p
8383,q
8384,#include <stdio.h>
8385,int main()
8386,{
8387,FILE *ptr =  NULL ;
8388,"ptr = fopen(""numbers.txt"", ""r"");"
8389,int i;
8390,int numberArray[6];
8391,for (i = 0; i <5 ; i++)
8392,
8393,{
8394,
8395,"fprintf(ptr , ""%d "", numberArray[i] );"
8396,
8397,
8398,}
8399,fclose(ptr);
8400,}
8401,*pointers
8402,char ***p
8403,void doubling(int x)
8404,{
8405,    x = x * 2;
8406,}
8407,doubling(5);
8408,void doubling2(int *x)
8409,{
8410,    (*x) = (*x) * 2; 
8411,}
8412,doubling2(5)
8413,int a = 5;
8414,doubling2(&a);
8415,a
8416,p
8417,*p
8418,p
8419,"int x, y;"
8420,x
8421,y
8422,fork_child
8423,fork_child
8424,#include <stdio.h>
8425,#include <stdlib.h>
8426,#include <sys/wait.h>
8427,#include <unistd.h>
8428,
8429,"void fork_child(int port_in, int generation) {"
8430,    int number;
8431,    int receive_first_number = 0;
8432,    int pid = -1;
8433,    int fd[2];
8434,
8435,"    while (read(port_in, &number, sizeof(number)) != 0) {"
8436,        if (receive_first_number == 0) {
8437,            receive_first_number = 1;
8438,"            printf(""child-%d (pid %d) receives: %d\n"", generation, getpid(), number);"
8439,            continue;
8440,        }
8441,
8442,        if (pid == -1) {
8443,            // execute only once to create child
8444,            pipe(fd);
8445,            pid = fork();
8446,            if (pid == 0) {
8447,                // child process
8448,                close(fd[1]);
8449,"                fork_child(fd[0], generation + 1);"
8450,                close(fd[0]);
8451,                exit(0);
8452,            } else {
8453,                // parent process
8454,                close(fd[0]);
8455,            }
8456,        }
8457,        // send number to next child
8458,"        write(fd[1], &number, sizeof(number));"
8459,    }
8460,
8461,    close(fd[1]);
8462,    wait(&pid);
8463,}
8464,
8465,int main() {
8466,    int fd[2];
8467,    pipe(fd);
8468,
8469,    int pid = fork();
8470,    if (pid == 0) {
8471,        // child process
8472,        close(fd[1]);
8473,"        fork_child(fd[0], 0);"
8474,        close(fd[0]);
8475,        exit(0);
8476,    } else {
8477,        // parent process
8478,        close(fd[0]);
8479,        for (int number = 0; number < 3; number++) {
8480,"            write(fd[1], &number, sizeof(number));"
8481,        }
8482,        close(fd[1]);
8483,        wait(&pid);
8484,    }
8485,
8486,    return 0;
8487,}
8488,$ ./pipe
8489,child-0 (pid 149437) receives: 0
8490,child-1 (pid 149438) receives: 1
8491,child-2 (pid 149439) receives: 2
8492,$ ./pipe > out
8493,$ cat out
8494,child-0 (pid 151246) receives: 0
8495,child-1 (pid 151247) receives: 1
8496,child-2 (pid 151248) receives: 2
8497,child-0 (pid 151246) receives: 0
8498,child-1 (pid 151247) receives: 1
8499,child-0 (pid 151246) receives: 0
8500,$ stdbuf -o 0 ./pipe 
8501,child-0 (pid 864370) receives: 0
8502,child-1 (pid 864371) receives: 1
8503,child-2 (pid 864372) receives: 2
8504,$ stdbuf -o 0 ./pipe > out && cat out
8505,child-0 (pid 864355) receives: 0
8506,child-1 (pid 864356) receives: 1
8507,child-2 (pid 864357) receives: 2
8508,$ stdbuf -o L ./pipe 
8509,child-0 (pid 866493) receives: 0
8510,child-1 (pid 866494) receives: 1
8511,child-2 (pid 866495) receives: 2
8512,$ stdbuf -o L ./pipe > out && cat out
8513,child-0 (pid 866501) receives: 0
8514,child-1 (pid 866502) receives: 1
8515,child-2 (pid 866503) receives: 2
8516,$ stdbuf -o 4096 ./pipe 
8517,child-0 (pid 864399) receives: 0
8518,child-1 (pid 864400) receives: 1
8519,child-2 (pid 864401) receives: 2
8520,child-0 (pid 864399) receives: 0
8521,child-1 (pid 864400) receives: 1
8522,child-0 (pid 864399) receives: 0
8523,$ stdbuf -o 4096 ./pipe > out && cat out
8524,child-0 (pid 864385) receives: 0
8525,child-1 (pid 864386) receives: 1
8526,child-2 (pid 864387) receives: 2
8527,child-0 (pid 864385) receives: 0
8528,child-1 (pid 864386) receives: 1
8529,child-0 (pid 864385) receives: 0
8530,printf()
8531,read()
8532,write()
8533,stdbuf -o 0
8534,stdbuf -o L
8535,printf()
8536,printf()
8537,fork()
8538,printf()
8539,fork()
8540,strace
8541,$ strace -o /tmp/trace -f ./x && grep 'write.*child-' /tmp/trace
8542,child-0 (pid 867548) receives: 0
8543,child-1 (pid 867549) receives: 1
8544,child-2 (pid 867550) receives: 2
8545,"867548 write(1, ""child-0 (pid 867548) receives: 0""..., 33) = 33"
8546,"867549 write(1, ""child-1 (pid 867549) receives: 1""..., 33) = 33"
8547,"867550 write(1, ""child-2 (pid 867550) receives: 2""..., 33) = 33"
8548,$ strace -o /tmp/trace -f ./x > out && cat out && grep 'write.*child-' /tmp/trace
8549,child-0 (pid 867515) receives: 0
8550,child-1 (pid 867516) receives: 1
8551,child-2 (pid 867517) receives: 2
8552,child-0 (pid 867515) receives: 0
8553,child-1 (pid 867516) receives: 1
8554,child-0 (pid 867515) receives: 0
8555,"867517 write(1, ""child-0 (pid 867515) receives: 0""..., 99) = 99"
8556,"867516 write(1, ""child-0 (pid 867515) receives: 0""..., 66) = 66"
8557,"867515 write(1, ""child-0 (pid 867515) receives: 0""..., 33) = 33"
8558,fflush()
8559,printf()
8560,int count_letters(string text)
8561,{
8562,    //isalpha - check whether a character is alphabetical
8563,    for (int i = 0; i < strlen(text); i++)
8564,    {
8565,        int j = 0;
8566,        if(isalpha(text[i]))
8567,        {
8568,            j++;
8569,        }
8570,        return j;
8571,    }
8572,}
8573,strlen(text)
8574,int j = 0;
8575,return j;
8576,}
8577,text
8578,0
8579,1
8580,j
8581,0
8582,#include<stdio.h>
8583,#include<cs50.h>
8584,
8585,"float discount(int prec , float pri);"
8586,
8587,int main (void){
8588,"  int precent = get_float(""enter the present here "");"
8589,"  float price =  get_float(""enter the price "");"
8590,"  float function1 = discount(precent , price);"
8591,"  printf(""the new number is %.2f\n"", function1);"
8592,}
8593,
8594,"float discount(int prec , float pri){"
8595,    return (100 - prec)/100 * pri ;
8596,}
8597,$ make lesson
8598,$ ./lesson
8599,enter the present here 15
8600,enter the price 100
8601,the new number is 0.00
8602,#include<stdio.h>
8603,#include<cs50.h>
8604,
8605,"float discount(int prec , float pri);"
8606,
8607,int main (void){
8608,"  int precent = get_float(""enter the present here "");"
8609,"  float price =  get_float(""enter the price "");"
8610,"  float function1 = discount(precent , price);"
8611,"  printf(""the new number is %.2f\n"", function1);"
8612,}
8613,
8614,"float discount(int prec , float pri){"
8615,    return pri * (100 - prec)/100 ;
8616,}
8617,$ make lesson
8618,$ ./lesson
8619,enter the present here 14
8620,enter the price 100
8621,the new number is 86.00
8622,(100 - prec) / 100
8623,(100 - (float)prec)/100 * pri
8624,(100f - prec)/100f * pri
8625,prec
8626,typedef struct test test;
8627,
8628,struct test {
8629,    bigThing* thing;
8630,    anotherThing* thingTwo;
8631,    int var1;
8632,    int var2;
8633,};
8634,typedef struct test {
8635,    bigThing* thing;
8636,    anotherThing* thingTwo;
8637,    int var1;
8638,    int var2;
8639,} test ;
8640,test foobar1;
8641,struct test foobar2;
8642,typedef struct {
8643,    bigThing* thing;
8644,    anotherThing* thingTwo;
8645,    int var1;
8646,    int var2;
8647,} test_t;
8648,typedef struct node {
8649,    int value;
8650,"    struct node *next; // ""node_t"" not encountered yet, so ""struct node"" required"
8651,} node_t;
8652,typedef
8653,typedef struct test test;
8654,
8655,struct test {
8656,    bigThing* thing;
8657,    anotherThing* thingTwo;
8658,    int var1;
8659,    int var2;
8660,};
8661,typedef struct test test;
8662,test
8663,struct test
8664,test
8665,struct test
8666,typedef struct test {
8667,    bigThing* thing;
8668,    anotherThing* thingTwo;
8669,    int var1;
8670,    int var2;
8671,} test ;
8672,typedef
8673,test
8674,struct test {
8675,    bigThing* thing;
8676,    anotherThing* thingTwo;
8677,    int var1;
8678,    int var2;
8679,}
8680,    #include <stdio.h>
8681,
8682,int main()
8683,{
8684,    struct test{
8685,     int x;
8686,     int y;
8687,    }t1 ;
8688,
8689,    t1.x = 10;
8690,    t1.y = 2;
8691,
8692,"    printf(""t1 = {%d, %d}"", t1.x, t1.y);"
8693,
8694,    return 0;
8695,}
8696,test x;
8697,struct test x;
8698,test x;
8699,struct test{
8700, int x;
8701, int y;
8702,}x;
8703,struct
8704,new_struct->stage = 1;
8705,struct new_struct {
8706,    stage = 1;
8707,}
8708,init_struct
8709,new_struct
8710,void init_struct(struct new_struct *nsp)
8711,{
8712,    nsp->stage = 1;
8713,}
8714,new_struct
8715,init_struct
8716,struct new_struct ns;
8717,init_struct(&ns);
8718,malloc
8719,new_struct
8720,init_struct
8721,struct new_struct *p = malloc(sizeof(struct new_struct));
8722,if(p != NULL) init_struct(p);
8723,init_struct
8724,stage
8725,memset
8726,void init_struct(struct new_struct *nsp)
8727,{
8728,"    memset(nsp, 0, sizeof(*nsp));"
8729,    nsp->stage = 1;
8730,}
8731,memset
8732,memset
8733,struct new_struct init_struct(void)
8734,{
8735,   struct new_struct s = { .stage = 1 };
8736,
8737,   return s;
8738,}
8739,#define NEW_STRUCT(s) struct new_struct s = { .stage = 1 } 
8740,struct s v;
8741,struct new_struct v = init_struct();
8742,
8743,// or
8744,
8745,NEW_STRUCT(v1);
8746,make
8747,Undefined symbols for architecture x86_64:
8748,"  ""_CMSG_LEN"", referenced from:"
8749,      _guacd_send_fd in guacd-move-fd.o
8750,"  ""_CMSG_SPACE"", referenced from:"
8751,      _guacd_send_fd in guacd-move-fd.o
8752,      _guacd_recv_fd in guacd-move-fd.o
8753,ld: symbol(s) not found for architecture x86_64
8754,clang: error: linker command failed with exit code 1 (use -v to see invocation)
8755,sys/socket.h
8756,"   #include ""calruntime.h"""
8757,
8758,   int main() {
8759,"     char string[2] = ""HI"";"
8760,     write(string);
8761,    }
8762,    #pragma once
8763,
8764,    #include <stdio.h>
8765,    #include <malloc.h>
8766,    #include <Windows.h>
8767,
8768,"    //* Instead of scanf, it's scanf_s because scanf shows an warning if you use it. *//"
8769,
8770,    #define write printf
8771,    #define read scanf_s
8772,    #define allocate malloc
8773,
8774,
8775,"    int calWindow(DWORD dwExStyle, LPCWSTR lpWindowClass, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, intnHeight, HWND hWndParrent, HINSTANCE hInstance, LPVOID lpParam);"
8776,
8777,"    int calMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);"
8778,
8779,   
8780,"char string[2] = ""HI"";"
8781,string
8782,#define write printf
8783,#define read scanf_s
8784,read
8785,write
8786,'\0
8787,"char string[2] = ""HI"";"
8788,"char string[3] = ""HI"";"
8789,"   #include ""calruntime.h"""
8790,
8791,   int main() {
8792,"       char string[3] = ""HI"";"
8793,       write(string);
8794,    }
8795,"char string[] = ""HI"";"
8796,"""/subscriptions/10b1da123141b7e-a4223904u1313/resourceGroups/rg-DEV2-blue/providers/Microsoft.Network/applicationGateways/agw-DEV2-blue-api-ag"" already exists - to be managed via Terraform this resource needs to be imported into the State. Please see the resource documentation for ""azurerm_application_gateway"" for more information."
8797,"terraform import module.caf.module.application_gateways[""agw-web""].azurerm_application_gateway.agw /subscriptions/10b1da123141b7e-a4223904u1313/resourceGroups/rg-DEV2-blue/providers/Microsoft.Network/applicationGateways/agw-DEV2-blue-api-ag"
8798,#define PY_SSIZE_T_CLEAN
8799,#include <Python.h>
8800,"int main(int argl, char **argv)"
8801,{
8802,
8803,        return 0;
8804,}
8805,cmake_minimum_required(VERSION 3.18)
8806,
8807,project(Test)
8808,
8809,add_executable(main main.c)
8810,
8811,find_package(PythonLibs REQUIRED)
8812,include_directories(${Python_INCLUDE_DIRS})
8813,target_link_libraries(main ${Python_LIBRARIES})
8814,$ apt-file search /Python.h|grep h$
8815,libpython2.7-dbg: /usr/include/python2.7_d/Python.h
8816,libpython2.7-dev: /usr/include/python2.7/Python.h
8817,libpython3.9-dbg: /usr/include/python3.9d/Python.h
8818,libpython3.9-dev: /usr/include/python3.9/Python.h
8819,...
8820,$ sudo apt install libpython3.9-dev
8821,-I/usr/include/python3.9
8822,$ pkg-config -cflags python-3.9
8823,-I/usr/include/python3.9 -I/usr/include/x86_64-linux-gnu/python3.9
8824,"scanf(""%s"",employee.gender);"
8825,do
8826,{
8827,"    printf(""Invalid entry"");"
8828,"    printf(""\nEnter Employee's Gender (Male/Female): "");"
8829,"    scanf(""%s"",employee.gender);"
8830,}
8831,"while (employee.gender != ""Male"");"
8832,while
8833,"employee.gender != ""Male"""
8834,"memcmp(employee.gender, ""Male"", 5)"
8835,gets
8836,strcmp()
8837,string.h
8838,string1
8839,string2
8840,string1
8841,string2
8842,char str[MAX_STR_LENGTH];
8843,strcmp()
8844,#include <string.h>
8845,==
8846,strcmp()
8847,do
8848,{
8849,"    printf(""Enter Employee's Gender (Male/Female)"");"
8850,"    scanf(""%s"", employee.gender);"
8851,"    if (strcmp(employee.gender, ""Male"") != 0 && strcmp(employee.gender, ""Female"") != 0)"
8852,    {
8853,"        printf(""Invalid entry\n"");"
8854,    }
8855,"} while (strcmp(employee.gender, ""Male"") != 0 && strcmp(employee.gender, ""Female"") != 0);"
8856,#include <stdio.h>
8857,#include <stdlib.h>
8858,
8859,main() {
8860,    char *movie;
8861,    movie = (char*)malloc(80 * sizeof(char));
8862,    if (movie != NULL)
8863,"        printf(""Enter favorite movie: "");"
8864,"        scanf_s(""%s"",movie);"
8865,"        printf(""You entered : %s"", movie);"
8866,"    system(""pause"");"
8867,}
8868,"scanf_s(""%s"",movie);"
8869,scanf_s()
8870,{}
8871,main()
8872,int main(void)
8873,"int main(int, char **)"
8874,void *
8875,sizeof(char)
8876,sizeof
8877,#include <stdio.h>
8878,#include <stdlib.h>
8879,
8880,#define LEN 79
8881,#define stringify(s) stringify2(s)
8882,#define stringify2(s) #s
8883,
8884,int main(void) {
8885,    char *movie = malloc(LEN+1);
8886,    if (movie) {
8887,"        printf(""Enter favorite movie: "");"
8888,"        scanf_s(""%"" stringify(LEN) ""s"", movie, LEN+1);"
8889,"        printf(""You entered : %s\n"", movie);"
8890,    }
8891,    getchar();
8892,    free(movie);
8893,    return 0;
8894,}
8895,/*
8896, *  This is a simple shell program from
8897, *  rik0.altervista.org/snippetss/csimpleshell.html
8898, *  It's been modified a bit and comments were added.
8899, *
8900," *  But it doesn't allow misdirection, e.g., <, >, >>, or |"
8901, *  The project is to fix this.
8902, */
8903,#include <stdio.h>
8904,#include <stdlib.h>
8905,#include <unistd.h>
8906,#include <string.h>
8907,#include <sys/wait.h>
8908,#include <errno.h>
8909,#include <sys/types.h>
8910,#define BUFFER_SIZE 80
8911,#define ARR_SIZE 80
8912,
8913,#define DEBUG 1  /* In case you want debug messages */
8914,#define step1 /*Detect the pipe char*/
8915,//#define step2 /*create pipes*/
8916,//#define step3 /*fork*/
8917,
8918,/*Variables for pipes*/
8919,"int in[2], out[2], n;"
8920,char buf[255];
8921,
8922,void error(char *s);
8923,
8924,"void parse_args(char *buffer, char** args, "
8925,"                size_t args_size, size_t *nargs)"
8926,{
8927,    char *buf_args[args_size]; 
8928,    
8929,    char *wbuf = buffer;
8930,    buf_args[0]=buffer; 
8931,    args[0]=buffer;  /* First argument */
8932,/*
8933, *  The following replaces delimiting characters with '\0'. 
8934," *  Example:  "" Aloha World\n"" becomes ""\0Aloha\0World\0\0"""
8935, *  Note that the for-loop stops when it finds a '\0' or it
8936, *  reaches the end of the buffer.
8937, */   
8938,"    for(char **cp=buf_args; (*cp=strsep(&wbuf, "" \n\t"")) != NULL ;){"
8939,        if ((**cp != '\0') && (++cp >= &buf_args[args_size]))
8940,            break; 
8941,    }
8942,
8943,
8944,/* Copy 'buf_args' into 'args' */    
8945,    size_t j=0;
8946,    for (size_t i=0; buf_args[i]!=NULL; i++){ 
8947,        if(strlen(buf_args[i])>0)  /* Store only non-empty tokens */
8948,            args[j++]=buf_args[i];
8949,    }
8950,    
8951,    *nargs=j;
8952,    args[j]=NULL;
8953,
8954,
8955,}
8956,
8957,"int main(int argc, char *argv[], char *envp[]){"
8958,    char buffer[BUFFER_SIZE];
8959,    char *args[ARR_SIZE];
8960,    int num_pipes = 0;
8961,    size_t num_args;
8962,    pid_t pid;
8963,    
8964,    while(1){
8965,"        printf(""ee468>> ""); "
8966,"        fgets(buffer, BUFFER_SIZE, stdin); /* Read in command line */"
8967,"        parse_args(buffer, args, ARR_SIZE, &num_args);"
8968,
8969,
8970,#ifdef step1 /*Detect pipe symbol in args*/
8971,"        printf(""Printing the args returned from parse_args:\n"");"
8972,        for(int i = 0; i < ARR_SIZE && args[i]!= NULL; i++){
8973,"            printf(""args[%d]: %s\n"",i, args[i]);"
8974,"            if(args[i]== ""\0|\0"" || args[i]==""|""){"
8975,                num_pipes++;
8976,            }
8977,        }
8978,"        printf(""There are %d pipes in the buffer.\n"",num_pipes);"
8979,#endif
8980,
8981,        if (num_args>0) {
8982,"            if (!strcmp(args[0], ""exit"" )) exit(0);       "
8983,            pid = fork();
8984,            if (pid){  /* Parent */
8985,#ifdef DEBUG
8986,"                printf(""Waiting for child (%d)\n"", pid);"
8987,#endif
8988,                pid = wait(NULL);
8989,#ifdef DEBUG
8990,"                printf(""Child (%d) finished\n"", pid);"
8991,#endif
8992,            } 
8993,            else{  /* Child executing the command */
8994,"                if( execvp(args[0], args)) {"
8995,                    puts(strerror(errno));
8996,                    exit(127);
8997,                }
8998,            }
8999,
9000,        }
9001,    }    
9002,    return 0;
9003,}
9004,
9005,void error(char *s) 
9006,{ 
9007,  perror(s); 
9008,  exit(1); 
9009,}
9010,"args[i]== ""\0|\0"""
9011,strcmp( )
9012,"if(args[i]== ""\0|\0"" || args[i]==""|""){"
9013,strcmp()
9014,"if (!strcmp(args[i], ""|"")) {"
9015,    num_pipes++;
9016,}
9017,str[numbytes-i] = r + 0x30;
9018,"void usitoh( UINT16 val, UINT8 numbytes, char *str )       //extern"
9019,{
9020,    UINT8 i = 0;
9021,    UINT8 r = 0;
9022,        
9023,    //Convert the Base 10 Number to Base 16
9024,    //Starting with LSB (i=1) and work to the MSB
9025,    for (i=1; i <= numbytes; i++) 
9026,    {
9027,        r = val % 16;       //Get the MOD of the number
9028,                            //The MOD of the number represents the Hex value
9029,        val = val / 16;     //Get the Quotient of the number
9030,        
9031,        //Load the value into the string and 
9032,        //add an offset to generate ASCII values
9033,"        // '0' = 0x30, 'A' = 0x41"
9034,        if (r <= 9) //Values < A
9035,        {
9036,            //For values 0-9 the ASCII offset is 0x30 
9037,"            //This produces and offset to get to chars 0,1,2,3,4,5,6,7,8,9"
9038,            //Warning 373 issue
9039,            str[numbytes-i] = r + 0x30;
9040,        }
9041,        else        //Values > 9
9042,        {
9043,            //The MOD of the number represents the Hex value
9044,"            //For values 0-9 the ASCII offset is 0x41 to get to ""A"" and - 0x0A to account 0-9 numbers"
9045,"            //This produces and offset to get to chars A,B,C,D,E,F"
9046,            //Warning 373 issue
9047,            str[numbytes-i] = r + (0x41 - 0x0A);
9048,        }        
9049,    }//END of FOR Loop
9050,"}//END of ""usitoh"""
9051,str[numbytes-i] = r + '0';
9052,UINT8
9053,for(UINT8 i = 1; ...)
9054,r
9055,gcc -Wall -Wextra
9056,#include <stdint.h>
9057,
9058,"void usitoh(uint16_t val, uint8_t numbytes, char *str ) {"
9059,    for (uint8_t i=0; i < numbytes; i++) {
9060,        uint8_t r = val % 16;
9061,        val /= 16;
9062,        str[numbytes-i+1] = r + ((r <= 9) ? '0' : 'A' - 10);
9063,    }
9064,}
9065,int
9066,char
9067,// str[numbytes-i] = r + 0x30;
9068,str[numbytes-i] = (char) (r + '0');
9069,...
9070,// str[numbytes-i] = r + (0x41 - 0x0A);
9071,str[numbytes-i] = (char) (r + ('A' - 10u));
9072,"void usitoh(unsigned val, size_t numbytes, char *str) {"
9073,  str[--numbytes] = 0;  // Include for null character termination
9074,  while (numbytes > 0) {
9075,"    str[--numbytes] = ""0123456789ABCDEF""[val % 16];"
9076,    val = val / 16;
9077,  }
9078,}
9079,str[numbytes-i] = '0' + ((char)r) ;
9080,char
9081,0
9082,str[numbytes-i] = HEX_DIGITS[r]
9083,"static const char HEX_DIGITS[]=""0123456789ABCDEF"";"
9084,if
9085,#define _CRT_SECURE_NO_WARNINGS 
9086,
9087,#include<stdio.h>
9088,#define SECS_PER_HOUR 3600 //1 hour = 60 minutes in an hour * 60 seconds in a minute = 
9089,3600 seconds in 1 hour
9090,#define METERS_PER_MILE 1600
9091,
9092,FILE *fp;
9093,
9094,int main()
9095,{
9096,"    double distance, time, speed_mph, speed_mps;"
9097,
9098,"    fopen_s(&fp, ""csis.txt"", ""w"");"
9099,
9100,"    scanf(""%lf"", &distance);"
9101,"    scanf(""%lf"", &time);"
9102,
9103,    speed_mph = distance / time;
9104,    speed_mps = (speed_mph * METERS_PER_MILE) / SECS_PER_HOUR;
9105,
9106,"    printf(""\nThe speed is %.2f miles per hour. \n"", speed_mph);"
9107,"    printf(fp, ""\nThe speed is %.2f miles per hour. \n"", speed_mph);"
9108,
9109,"    printf(""The speed is %.2f meters per second."", speed_mps);"
9110,"    printf(fp, ""The speed is %.2f meters per second."", speed_mps);"
9111,
9112,    fclose(fp);
9113,
9114,    return 0;
9115,}
9116,"printf(fp, ..."
9117,"fprintf(fp, ..."
9118,fopen( )
9119,#define SECS_PER_HOUR 3600
9120,#define SECS_PER_HOUR 60*60
9121,"printf(""\nThe speed is %.2f miles per hour. \n"", speed_mph);"
9122,"fprintf(fp, ""\nThe speed is %.2f miles per hour. \n"", speed_mph);"
9123,
9124,"printf(""The speed is %.2f meters per second."", speed_mps);"
9125,"fprintf(fp, ""The speed is %.2f meters per second."", speed_mps);"
9126,show_password
9127,enter
9128,#define PASSWORD_LENGTH 13
9129,// password
9130,void _password()
9131,{
9132,
9133,    char pass_word[PASSWORD_LENGTH];
9134,
9135,"    printf(""\nEnter 8-13 character Password\n"");"
9136,    for (j=0; j<=PASSWORD_LENGTH; j++)           //at this code is where i need to make the change
9137,    {
9138,        pass_word[j] = getch();     // Hidden password
9139,"        printf(""*"");"
9140,    }
9141,    pass_word[j] = '\0';
9142,"    printf(""\n"");"
9143,"    printf(""password entered is:"");"
9144,        for (j=0; pass_word[j] != '\0'; j++ )
9145,    {
9146,"        printf(""%c"",pass_word[j]);"
9147,
9148,    }
9149,    getch();
9150,
9151,}
9152,'\n'
9153,break
9154,j < PASSWORD_LENGTH
9155,'\n'
9156,'\r'
9157,RETURN
9158,break
9159,pass_word[j] = getch();
9160,if ((pass_word[j] == '\n' || pass_word[j] == '\r') && j >= 8)
9161,    break;
9162,:-)
9163,ENTER
9164,:-)
9165,\r
9166,enter
9167,// password
9168,void _password()
9169,{
9170,
9171,    char pass_word[PASSWORD_LENGTH];
9172,
9173,"    printf(""\nEnter 8-13 character Password\n"");"
9174,   for (j=0; j<=PASSWORD_LENGTH; j++)
9175,    {
9176,
9177,        pass_word[j] = getch();
9178,"        printf(""*"");"
9179,        if (pass_word[j] == '\n' || pass_word[j] == '\r')
9180,        break;
9181,        
9182,          // Hidden password
9183,
9184,    }
9185,
9186,    pass_word[j] = '\0';
9187,"    printf(""\n"");"
9188,"    printf(""password entered is:"");"
9189,        for (j=0; pass_word[j] != '\0'; j++ )
9190,    {
9191,"        printf(""%c"",pass_word[j]);"
9192,
9193,    }
9194,    getch();
9195,
9196,}
9197,for (j=0; j<=PASSWORD_LENGTH; j++)
9198,for (j=0; j<PASSWORD_LENGTH; j++)
9199,pass_word[j] = getch();
9200,pass_word
9201,anurag@anurag-VivoBook-ASUSLaptop-X570ZD-F570ZD:~/Pictures$ make
9202,Consolidate compiler generated dependencies of target wayab
9203,[ 12%] Building C object CMakeFiles/wayab.dir/render.c.o
9204,In file included from /home/anurag/render.c:9:
9205,/usr/include/cairo/cairo-gl.h:152:3: error: #error Cairo was not compiled with support for the GL backend
9206,  152 | # error Cairo was not compiled with support for the GL backend
9207,      |   ^~~~~
9208,/home/anurag/render.c: In function ‘wayab_renderer_new’:
9209,/home/anurag/render.c:155:23: warning: implicit declaration of function ‘cairo_egl_device_create’; did you mean ‘cairo_region_create’? [-Wimplicit-function-declaration]
9210,"  155 |   ptr->cairo_device = cairo_egl_device_create(ptr->display, ptr->context);"
9211,      |                       ^~~~~~~~~~~~~~~~~~~~~~~
9212,      |                       cairo_region_create
9213,/home/anurag/render.c:155:21: warning: assignment to ‘cairo_device_t *’ {aka ‘struct _cairo_device *’} from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
9214,"  155 |   ptr->cairo_device = cairo_egl_device_create(ptr->display, ptr->context);"
9215,      |                     ^
9216,/home/anurag/render.c:160:24: warning: implicit declaration of function ‘cairo_gl_surface_create_for_egl’; did you mean ‘cairo_surface_create_for_image’? [-Wimplicit-function-declaration]
9217,  160 |   ptr->cairo_surface = cairo_gl_surface_create_for_egl(
9218,      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
9219,      |                        cairo_surface_create_for_image
9220,/home/anurag/render.c:160:22: warning: assignment to ‘cairo_surface_t *’ {aka ‘struct _cairo_surface *’} from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
9221,  160 |   ptr->cairo_surface = cairo_gl_surface_create_for_egl(
9222,      |                      ^
9223,/home/anurag/render.c: In function ‘wayab_renderer_draw’:
9224,/home/anurag/render.c:221:3: warning: implicit declaration of function ‘cairo_gl_surface_swapbuffers’; did you mean ‘cairo_surface_status’? [-Wimplicit-function-declaration]
9225,  221 |   cairo_gl_surface_swapbuffers(ptr->cairo_surface);
9226,      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
9227,      |   cairo_surface_status
9228,make[2]: *** [CMakeFiles/wayab.dir/build.make:90: CMakeFiles/wayab.dir/render.c.o] Error 1
9229,make[1]: *** [CMakeFiles/Makefile2:83: CMakeFiles/wayab.dir/all] Error 2
9230,make: *** [Makefile:91: all] Error 2
9231,cairo-gl.h
9232,cairo-gl.h
9233,/usr/include
9234,char **arr = malloc(4 * sizeof(char *));
9235,char **arr
9236,arr
9237,char **
9238,arr[i]
9239,char *
9240,arr[i] = …
9241,=
9242,arr[i]
9243,=
9244,arr[i]
9245,int *p = (int *) arr;
9246,p[i] = 3;
9247,p[i]
9248,int
9249,int
9250,malloc
9251,void *
9252,char **arr = malloc(…);
9253,malloc
9254,arr
9255,malloc
9256,const
9257,volatile
9258,arr
9259,char **
9260,char **arr = malloc(4 * sizeof(char *));
9261,malloc
9262,void *
9263,int *arr = malloc(4 * sizeof(char *));
9264,#include <iostream>
9265,#include <fstream>
9266,typedef enum {
9267,"    UNDEFINED,"
9268,"    JUMP,"
9269,"    LOAD,"
9270,"    INCREMENT,"
9271,"    DECREMENT,"
9272,"    MULTIPLY,"
9273,"    DIVIDE,"
9274,"    PRINT,"
9275,    PROMPT
9276,} Types;
9277,
9278,int errorHandling(const char* errorMessage);
9279,int main() {
9280,    try {
9281,        Types tempTypes;
9282,        char *tempValue;
9283,
9284,"        std::ifstream f(""test.lang"");"
9285,        if (!f) {
9286,"            errorHandling(""File not found"");"
9287,        }
9288,"        char *fileName = strtok(""test.lang"", ""."");"
9289,        //create output file ending with .c
9290,        char *outputFileName = static_cast<char *>(malloc(strlen(fileName) + 3));
9291,"        strcpy(outputFileName, fileName);"
9292,"        strcat(outputFileName, "".c"");"
9293,        std::ofstream outputFile(outputFileName);
9294,        if (!outputFile) {
9295,"            errorHandling(""Output file not found"");"
9296,        }
9297,        //char *memory[] = {};
9298,        //    int pos = 0;
9299,"        outputFile << ""#include <stdio.h>\n"""
9300,"                      ""int main() {\n"""
9301,"                      ""\tchar *memory[] = {};\n"""
9302,"                      ""\tint pos = 0;\n"";"
9303,
9304,        //remove all new lines from input file
9305,        std::string fileContent;
9306,        std::string line;
9307,"        while (std::getline(f, line)) {"
9308,            fileContent += line;
9309,        }
9310,        for (auto c: fileContent) {
9311,            if (c == ' ') {
9312,                continue;
9313,            } else if (c == '>') {
9314,                if (tempTypes == UNDEFINED) {
9315,                    tempTypes = JUMP;
9316,                } else {
9317,"                    errorHandling(""Invalid syntax"");"
9318,                }
9319,            } else if (c == '<') {
9320,                if (tempTypes == UNDEFINED) {
9321,                    tempTypes = LOAD;
9322,                } else {
9323,"                    errorHandling(""Invalid syntax"");"
9324,                }
9325,            } else if (c == '+') {
9326,                if (tempTypes == UNDEFINED) {
9327,                    tempTypes = INCREMENT;
9328,                } else {
9329,"                    errorHandling(""Invalid syntax"");"
9330,                }
9331,            } else if (c == '-') {
9332,                if (tempTypes == UNDEFINED) {
9333,                    tempTypes = DECREMENT;
9334,                } else {
9335,"                    errorHandling(""Invalid syntax"");"
9336,                }
9337,            } else if (c == '*') {
9338,                if (tempTypes == UNDEFINED) {
9339,                    tempTypes = MULTIPLY;
9340,                } else {
9341,"                    errorHandling(""Invalid syntax"");"
9342,                }
9343,            } else if (c == '/') {
9344,                if (tempTypes == UNDEFINED) {
9345,                    tempTypes = DIVIDE;
9346,                } else {
9347,"                    errorHandling(""Invalid syntax"");"
9348,                }
9349,            } else if (c == '_') {
9350,                if (tempTypes == UNDEFINED) {
9351,                    tempTypes = PRINT;
9352,                } else {
9353,"                    errorHandling(""Invalid syntax"");"
9354,                }
9355,            } else if (c == '?') {
9356,                if (tempTypes == UNDEFINED) {
9357,                    tempTypes = PROMPT;
9358,                } else {
9359,"                    errorHandling(""Invalid syntax"");"
9360,                }
9361,            } else if (c == ';') {
9362,                if (tempTypes == UNDEFINED) {
9363,"                    errorHandling(""Invalid syntax"");"
9364,                } else if (tempTypes == JUMP) {
9365,"                    outputFile << ""\tpos = "" << tempValue << "";\n"";"
9366,                } else if (tempTypes == LOAD) {
9367,"                    outputFile << ""\tpos = "" << tempValue << "";\n"";"
9368,                } else if (tempTypes == INCREMENT) {
9369,"                    outputFile << ""\t*memory[pos] += "" << tempValue << "";\n"";"
9370,                } else if (tempTypes == DECREMENT) {
9371,"                    outputFile << ""\t*memory[pos] -= "" << tempValue << "";\n"";"
9372,                } else if (tempTypes == MULTIPLY) {
9373,"                    outputFile << ""\t*memory[pos] *= "" << tempValue << "";\n"";"
9374,                } else if (tempTypes == DIVIDE) {
9375,"                    outputFile << ""\t*memory[pos] /= "" << tempValue << "";\n"";"
9376,                } else if (tempTypes == PRINT) {
9377,"                    outputFile << ""\tprintf(\""%c\"", *memory[pos]);\n"";"
9378,                } else if (tempTypes == PROMPT) {
9379,"                    outputFile << ""\tscanf(\""%c\"", *memory[pos]);\n"";"
9380,                }
9381,            } else {
9382,                tempValue = &c;
9383,            }
9384,
9385,        }
9386,"        outputFile << ""\treturn 0;\n"""
9387,"                      ""}"";"
9388,    } catch (std::exception &e) {
9389,        errorHandling(e.what());
9390,    }
9391,
9392,    return 0;
9393,}
9394,
9395,int errorHandling(const char* errorMessage) {
9396,    std::cout << errorMessage << std::endl;
9397,    return 1;
9398,}
9399,std::string
9400,tempValue
9401,char
9402,char
9403,std::filesystem::path
9404,case
9405,switch
9406,#include <cstring> //added this
9407,int main() {
9408,"    char *fileName = strtok(""test.lang"", ""."");"
9409,}
9410,const
9411,strtok
9412,'.'
9413,"""test.lang"""
9414,"""test\0lang"""
9415,"""test.lang"""
9416,'.'
9417,'\0'
9418,"""test.c"""
9419,strtok
9420,strtok
9421,#include <sstream> 
9422,#include <string>
9423,int main() {
9424,    
9425,"    std::istringstream stream(""test.lang""); // or use any string, including one provided "
9426,                                            // by the user.
9427,    std::string filename;
9428,"    if (std::getline(stream, filename, '.'))"
9429,    {
9430,"        filename += "".c"";"
9431,    }
9432,    else
9433,    {
9434,        // log error
9435,        return -1;
9436,    }
9437,}
9438,C
9439,register
9440,register char
9441,sizeof()
9442,register char
9443,register char
9444,register char
9445,s_copy.c
9446,libf2c
9447,f2c
9448,"void s_copy(register char *a, register char *b, ftnlen la, ftnlen lb)"
9449,#endif
9450,{
9451,"    register char *aend, *bend;"
9452,
9453,    aend = a + la;
9454,"    printf(""a: -%lu- %d\n"",sizeof(a),__LINE__);"
9455,"    printf(""b: -%lu- %d\n"",sizeof(b),__LINE__);"
9456,
9457,    ...
9458,char
9459,sizeof( char )
9460,1
9461,char
9462,sizeof( char )
9463,1
9464,register
9465,a
9466,b
9467,register char
9468,register char *
9469,register
9470,register
9471,a
9472,b
9473,sizeof(a)
9474,sizeof(*a)
9475,*a
9476,char
9477,1
9478,typedef struct {
9479,    int r;
9480,    int g;
9481,    int b;
9482,} cnv_pixel;
9483,
9484,typedef struct {
9485,"    int width, height, x, y;"
9486,
9487,    cnv_pixel** canvas;
9488,} cnv_canvas;
9489,"cnv_canvas* cnv_new(int width, int height) {"
9490,    cnv_canvas* canvas = malloc(sizeof(cnv_canvas));
9491,    if (!canvas) abort();
9492,
9493,    canvas->width = width;
9494,    canvas->height = height;
9495,    canvas->x = 0;
9496,    canvas->y = 0;
9497,    
9498,    canvas->canvas = (cnv_pixel**) malloc(sizeof(cnv_pixel*) * width);
9499,
9500,    for (int i = 0; i < width; i++) {
9501,        canvas->canvas[i] = (cnv_pixel*) malloc(sizeof(cnv_pixel*) * height);
9502,    }
9503,
9504,    if (!canvas->canvas) {
9505,        free(canvas);
9506,        abort();
9507,    }
9508,
9509,    return canvas;
9510,}
9511,for (int y = 0; y < CANVAS_HEIGHT; y++) {
9512,    for (int x = 0; x < CANVAS_WIDTH; x++) {
9513,        int r = 56;
9514,        int g = 200;
9515,        int b = 64;
9516,
9517,"        if (cnv_put_pixel_next(canvas, r, g, b) == ERR_SOFT_OUT_OF_BOUNDS) break;"
9518,    }
9519,}
9520,"ERR_ERROR cnv_put_pixel_next(cnv_canvas* c, int r, int g, int b) {"
9521,    if (!c) return ERR_NULL_VALUE;
9522,
9523,"    if (!cnv_is_in_bounds(c, c->x, c->y)) {"
9524,        return ERR_SOFT_OUT_OF_BOUNDS;
9525,    }
9526,
9527,    cnv_pixel* position = &c->canvas[c->x][c->y];
9528,
9529,    position->r = r;
9530,    position->g = g;
9531,    position->b = b;
9532,
9533,    if (c->x >= c->width - 1) {
9534,        c->x = 0;
9535,        c->y ++;
9536,    } else { c->x++; }
9537,
9538,    return ERR_NO_ERROR;
9539,}
9540,"ERR_ERROR cnv_write_to_file_ppm(cnv_canvas* c, const char* file_name) {"
9541,    FILE *file;
9542,    errno_t error;
9543,
9544,"    if ((error = fopen_s(&file, file_name, ""w"")) != 0) return ERR_FAILED_IO_WRITE;"
9545,
9546,    // Declare colour type (ascii)
9547,"    fprintf_s(file, ""P3\n%d %d\n255\n"", c->width, c->height);"
9548,
9549,    for (int y = 0; y < c->height; y++) {
9550,        for (int x = 0; x < c->width; x++) {
9551,"            fprintf_s(file, ""%d %d %d\n"", c->canvas[x][y].r, c->canvas[x][y].g, c->canvas[x][y].b);"
9552,        }
9553,    }
9554,
9555,    // Close file
9556,    fclose(file);
9557,
9558,    return ERR_NO_ERROR;
9559,}
9560,56 200 64
9561,64 56 200
9562,canvas->canvas = (cnv_pixel**) malloc(sizeof(cnv_pixel*) * height);
9563,
9564,for (int i = 0; i < height; i++) {
9565,    canvas->canvas[i] = (cnv_pixel*) malloc(sizeof(cnv_pixel) * width);
9566,}
9567,for
9568,main
9569,#include
9570,draw_triangle_2d
9571,"static void draw_top_tri(struct render_buffer *buffer,"
9572,"                     int x1, int y1,"
9573,"                     int x2, int y2,"
9574,"                     int x3, int y3,"
9575,"                     float r, float g, float b, float a)"
9576,{
9577,"unsigned int color = vec4_to_uint(vec4_mul(Vec4(r, g, b, a), 255.0f));"
9578,// this function draws a triangle that has a flat top
9579,
9580,"float dx_right,    // the dx/dy ratio of the right edge of line"
9581,"    dx_left,     // the dx/dy ratio of the left edge of line"
9582,"    xs, xe,       // the starting and ending points of the edges"
9583,    height;      // the height of the triangle
9584,
9585,"int temp_x,        // used during sorting as temps"
9586,"    temp_y,"
9587,"    right,         // used by clipping"
9588,    left;
9589,
9590,// destination address of next scanline
9591,unsigned int *dest_addr = NULL;
9592,
9593,// test order of x1 and x2
9594,if(x2 < x1)
9595,{
9596,    temp_x = x2;
9597,    x2 = x1;
9598,    x1 = temp_x;
9599,} // end if swap
9600,
9601,// compute delta's
9602,height = (float)(y3 - y1);
9603,
9604,dx_left = (x3 - x1) / height;
9605,dx_right = (x3 - x2) / height;
9606,
9607,// set starting points
9608,xs = (float)x1;
9609,xe = (float)x2 + (float)0.5;
9610,
9611,// perform y clipping
9612,if(y1 < MIN_CLIP_Y)
9613,{
9614,    // compute new xs and ys
9615,    xs = xs + dx_left * (float)(-y1 + MIN_CLIP_Y);
9616,    xe = xe + dx_right * (float)(-y1 + MIN_CLIP_Y);
9617,
9618,    // reset y1
9619,    y1 = MIN_CLIP_Y;
9620,
9621,} // end if top is off screen
9622,
9623,if(y3 > MAX_CLIP_X)
9624,    y3 = MAX_CLIP_X;
9625,
9626,// compute starting address in video memory
9627,dest_addr = (unsigned int *)buffer->memory + y1 * buffer->width;
9628,
9629,// test if x clipping is needed
9630,if(x1 >= MIN_CLIP_X && x1 <= MAX_CLIP_X &&
9631,   x2 >= MIN_CLIP_X && x2 <= MAX_CLIP_X &&
9632,   x3 >= MIN_CLIP_X && x3 <= MAX_CLIP_X)
9633,{
9634,    // draw the triangle
9635,"    for(temp_y = y1; temp_y <= y3; temp_y++, dest_addr += buffer->width)"
9636,    {
9637,"        memset((unsigned int *)dest_addr + (unsigned int)xs,"
9638,"               color, (unsigned int)(xe - xs + 1) * 4);"
9639,
9640,        // adjust starting point and ending point
9641,        xs += dx_left;
9642,        xe += dx_right;
9643,
9644,    } // end for
9645,
9646,} // end if no x clipping needed
9647,else
9648,{
9649,    // clip x axis with slower version
9650,
9651,    // draw the triangle
9652,"    for(temp_y = y1; temp_y <= y3; temp_y++, dest_addr += buffer->width)"
9653,    {
9654,        // do x clip
9655,        left = (int)xs;
9656,        right = (int)xe;
9657,
9658,        // adjust starting point and ending point
9659,        xs += dx_left;
9660,        xe += dx_right;
9661,
9662,        // clip line
9663,        if(left < MIN_CLIP_X)
9664,        {
9665,            left = MIN_CLIP_X;
9666,
9667,            if(right < MIN_CLIP_X)
9668,                continue;
9669,        }
9670,
9671,        if(right > MAX_CLIP_X)
9672,        {
9673,            right = MAX_CLIP_X;
9674,
9675,            if(left > MAX_CLIP_X)
9676,                continue;
9677,        }
9678,
9679,"        memset((unsigned int *)dest_addr + (unsigned int)left,"
9680,"               color, (unsigned int)(right - left + 1) * 4);"
9681,
9682,    } // end for
9683,
9684,} // end else x clipping needed
9685,
9686,} // end Draw_Top_Tri
9687,
9688,static void
9689,"draw_bottom_tri(struct render_buffer *buffer,"
9690,"            int x1, int y1,"
9691,"            int x2, int y2,"
9692,"            int x3, int y3,"
9693,"            float r, float g, float b, float a)"
9694,
9695,{
9696,"unsigned int color = vec4_to_uint(vec4_mul(Vec4(r, g, b, a), 255.0f));"
9697,// this function draws a triangle that has a flat bottom
9698,
9699,"float dx_right,    // the dx/dy ratio of the right edge of line"
9700,"    dx_left,     // the dx/dy ratio of the left edge of line"
9701,"    xs, xe,       // the starting and ending points of the edges"
9702,    height;      // the height of the triangle
9703,
9704,"int temp_x,        // used during sorting as temps"
9705,"    temp_y,"
9706,"    right,         // used by clipping"
9707,    left;
9708,
9709,// destination address of next scanline
9710,unsigned int *dest_addr;
9711,
9712,// test order of x1 and x2
9713,if(x3 < x2)
9714,{
9715,    temp_x = x2;
9716,    x2 = x3;
9717,    x3 = temp_x;
9718,} // end if swap
9719,
9720, // compute delta's
9721,height = (float)(y3 - y1);
9722,
9723,dx_left = (x2 - x1) / height;
9724,dx_right = (x3 - x1) / height;
9725,
9726,// set starting points
9727,xs = (float)x1;
9728,xe = (float)x1; // +(float)0.5;
9729,
9730,// perform y clipping
9731,if(y1 < MIN_CLIP_Y)
9732,{
9733,    // compute new xs and ys
9734,    xs = xs + dx_left * (float)(-y1 + MIN_CLIP_Y);
9735,    xe = xe + dx_right * (float)(-y1 + MIN_CLIP_Y);
9736,
9737,    // reset y1
9738,    y1 = MIN_CLIP_Y;
9739,
9740,} // end if top is off screen
9741,
9742,if(y3 > MAX_CLIP_X)
9743,    y3 = MAX_CLIP_X;
9744,
9745,// compute starting address in video memory
9746,dest_addr = (unsigned int *)buffer->memory + y1 * buffer->width;
9747,
9748,// test if x clipping is needed
9749,if(x1 >= MIN_CLIP_X && x1 <= MAX_CLIP_X &&
9750,   x2 >= MIN_CLIP_X && x2 <= MAX_CLIP_X &&
9751,   x3 >= MIN_CLIP_X && x3 <= MAX_CLIP_X)
9752,{
9753,    // draw the triangle
9754,"    for(temp_y = y1; temp_y <= y3; temp_y++, dest_addr += buffer->width)"
9755,    {
9756,"        memset((unsigned int *)dest_addr + (unsigned int)xs,"
9757,"               color, (unsigned int)(xe - xs + 1) * 4);"
9758,
9759,        // adjust starting point and ending point
9760,        xs += dx_left;
9761,        xe += dx_right;
9762,
9763,    } // end for
9764,
9765,} // end if no x clipping needed
9766,else
9767,{
9768,    // clip x axis with slower version
9769,
9770,    // draw the triangle
9771,
9772,"    for(temp_y = y1; temp_y <= y3; temp_y++, dest_addr += buffer->width)"
9773,    {
9774,        // do x clip
9775,        left = (int)xs;
9776,        right = (int)xe;
9777,
9778,        // adjust starting point and ending point
9779,        xs += dx_left;
9780,        xe += dx_right;
9781,
9782,        // clip line
9783,        if(left < MIN_CLIP_X)
9784,        {
9785,            left = MIN_CLIP_X;
9786,
9787,            if(right < MIN_CLIP_X)
9788,                continue;
9789,        }
9790,
9791,        if(right > MAX_CLIP_X)
9792,        {
9793,            right = MAX_CLIP_X;
9794,
9795,            if(left > MAX_CLIP_X)
9796,                continue;
9797,        }
9798,
9799,"        memset((unsigned int *)dest_addr + (unsigned int)left,"
9800,"               color, (unsigned int)(right - left + 1) * 4);"
9801,
9802,    } // end for
9803,
9804,} // end else x clipping needed
9805,
9806,} // end Draw_Bottom_Tri}
9807,
9808,ENGINE_CORE_EXPORT void
9809,"draw_triangle_2d(struct render_buffer *buffer,"
9810,"             int x1, int y1,"
9811,"             int x2, int y2,"
9812,"             int x3, int y3,"
9813,"             float r, float g, float b, float a)"
9814,{
9815,// this function draws a triangle on the destination buffer
9816,"// it decomposes all triangles into a pair of flat top, flat bottom"
9817,
9818,"int temp_x, // used for sorting"
9819,"    temp_y,"
9820,    new_x;
9821,
9822,// test for h lines and v lines
9823,if((x1 == x2 && x2 == x3) || (y1 == y2 && y2 == y3))
9824,    return;
9825,
9826,"// sort p1,p2,p3 in ascending y order"
9827,if(y2 < y1)
9828,{
9829,    temp_x = x2;
9830,    temp_y = y2;
9831,    x2 = x1;
9832,    y2 = y1;
9833,    x1 = temp_x;
9834,    y1 = temp_y;
9835,} // end if
9836,
9837,// now we know that p1 and p2 are in order
9838,if(y3 < y1)
9839,{
9840,    temp_x = x3;
9841,    temp_y = y3;
9842,    x3 = x1;
9843,    y3 = y1;
9844,    x1 = temp_x;
9845,    y1 = temp_y;
9846,} // end if
9847,
9848,// finally test y3 against y2
9849,if(y3 < y2)
9850,{
9851,    temp_x = x3;
9852,    temp_y = y3;
9853,    x3 = x2;
9854,    y3 = y2;
9855,    x2 = temp_x;
9856,    y2 = temp_y;
9857,
9858,} // end if
9859,
9860,// do trivial rejection tests for clipping
9861,if(y3 < MIN_CLIP_Y || y1 > MAX_CLIP_X ||
9862,   (x1 < MIN_CLIP_X && x2 < MIN_CLIP_X && x3 < MIN_CLIP_X) ||
9863,   (x1 > MAX_CLIP_X && x2 > MAX_CLIP_X && x3 > MAX_CLIP_X))
9864,    return;
9865,
9866,// test if top of triangle is flat
9867,if(y1 == y2)
9868,{
9869,"    draw_top_tri(buffer, x1, y1, x2, y2, x3, y3, r, g, b, a);"
9870,} // end if
9871,else
9872,    if(y2 == y3)
9873,    {
9874,"        draw_bottom_tri(buffer, x1, y1, x2, y2, x3, y3, r, g, b, a);"
9875,    } // end if bottom is flat
9876,    else
9877,    {
9878,        // general triangle that's needs to be broken up along long edge
9879,        new_x = x1 + (int)(0.5 + (float)(y2 - y1) * (float)(x3 - x1) / (float)(y3 - y1));
9880,
9881,        // draw each sub-triangle
9882,"        draw_bottom_tri(buffer, x1, y1, new_x, y2, x2, y2, r, g, b, a);"
9883,"        draw_top_tri(buffer, x2, y2, new_x, y2, x3, y3, r, g, b, a);"
9884,
9885,    } // end else
9886,
9887,} // end Draw_Triangle_2D
9888,int main()
9889,{
9890,"    printf(""WELCOME TO THIS AMAZING BINARY TO DECIMAL NUMBER CONVERTER\n"");"
9891,start:;
9892,"    int bin, dgt, rev;"
9893,"    printf(""\nEner the binary number to convert it into decimal number:     "");"
9894,"    scanf(""%d"", &bin);"
9895,"    printf(""\n\nYour binary number = %d\n"", bin);"
9896,    int nib = bin;
9897,    dgt = dgts(bin);
9898,    char str[dgt + 1];
9899,"    sprintf(str, ""%d"", bin);"
9900,"    int dec = BinToDec(dgt, str);"
9901,"    printf(""\n\n*   *   *   *   *   *   *\ndecimal no. is:     %d\n*   *   *   *   *   *   *\n\n"", dec);"
9902,    char qor;
9903,"    printf(""If you want to quit, enter q;\n If you want to use this tool again, enter any other character"");"
9904,"    scanf(""\t% c"", &qor);"
9905,    if (qor == 'q')
9906,    {
9907,        goto end;
9908,    }
9909,    else
9910,    {
9911,        goto start;
9912,    }
9913,end:
9914,    return 0;
9915,}
9916,scanf
9917,"scanf(""\t% c"", &qor);"
9918,%
9919,c
9920,%
9921,"scanf( "" %c"", &qor);"
9922,'\n'
9923,goto
9924,scanf
9925,scanf()
9926,int main()
9927,    {
9928,         int c;
9929,         while ((c = getchar()) != EOF)
9930,             {
9931,                  putchar(c);
9932,"                  printf(""%d\n"", c);"
9933,             }
9934,         return 0;
9935,     }
9936,>A 
9937,>A65
9938,>
9939,>10
9940,>
9941,10
9942,while
9943,1. Enter loop
9944,2. getchar() waits for input from stdin
9945,"2. You enter 'A', hit 'Enter'"
9946,3. c is assigned '65' (integral value of 'A')
9947,"4. putchar(c) and then printf(""%d\n""), so you see 'A65'"
9948,"5. getchar() immediately gets next character from stdin, which is linefeed"
9949,6. c is assigned '10' (integral value of '\n')
9950,"7. putchar(c) and printf(""%d\n""), so you see a newline followed by 10."
9951,isprint
9952,#include <stdio.h>
9953,#include <ctype.h>
9954,
9955,int main() {
9956,    for(int c; (c = getchar()) != EOF;) {
9957,        if (!isprint(c)) {
9958,"            printf(""Ignoring character with value %d\n"", c);"
9959,        } else {
9960,            putchar(c);
9961,"            printf(""%d\n"", c);"
9962,        }
9963,    }
9964,    return 0;
9965,}
9966,root@6f67da78fe9a:~# gcc -o chartest source.c
9967,root@6f67da78fe9a:~# ./chartest
9968,A
9969,A65
9970,Ignoring character with value 10
9971,make: Warning: File `Makefile' has modification time 5.3e+02 s in the future
9972,make -C /lib/modules/3.13.0-00299-ga2e769f/build M=/home/root/timer_interrupt_test modules
9973,make[1]: Entering directory `/usr/src/3.13.0-00299-ga2e769f'
9974,make[1]: Warning: File `/usr/src/3.13.0-00299-ga2e769f/arch/arm/Makefile' has modification time 1.4e+09 s in the future
9975,make[2]: Warning: File `scripts/Makefile.lib' has modification time 1.4e+09 s in the future
9976,  CC [M]  /home/root/timer_interrupt_test/timer.o
9977,make[2]: warning:  Clock skew detected.  Your build may be incomplete.
9978,"  Building modules, stage 2."
9979,make[2]: Warning: File `scripts/Makefile.lib' has modification time 1.4e+09 s in the future
9980,  MODPOST 1 modules
9981,  CC      /home/root/timer_interrupt_test/timer.mod.o
9982,  LD [M]  /home/root/timer_interrupt_test/timer.ko
9983,make[2]: warning:  Clock skew detected.  Your build may be incomplete.
9984,make[1]: warning:  Clock skew detected.  Your build may be incomplete.
9985,make[1]: Leaving directory `/usr/src/3.13.0-00299-ga2e769f'
9986,make: warning:  Clock skew detected.  Your build may be incomplete.
9987,root@de1soclinux:~/timer_interrupt_test# insmod timer.ko
9988,insmod: error inserting 'timer.ko': -1 Invalid parameters
9989,#include <linux/kernel.h>
9990,#include <linux/module.h>
9991,#include <linux/init.h>
9992,#include <linux/interrupt.h>
9993,#include <asm/io.h>
9994,
9995,"MODULE_LICENSE(""GPL"");"
9996,"MODULE_AUTHOR(""Altera University Program"");"
9997,"MODULE_DESCRIPTION(""DE1SoC TImer Interrupt Handler"");"
9998,
9999,void * led_axi_addr;
10000,void * arm_private_timer;
10001,
10002,"irq_handler_t irq_handler(int irq, void *dev_id, struct pt_regs *regs)"
10003,{
10004,    // Increment the value on the LEDs
10005,"    iowrite32(ioread32(led_axi_addr)+1,led_axi_addr);"
10006,"    iowrite32(0x1, arm_private_timer + 0xc);"
10007,    return (irq_handler_t) IRQ_HANDLED;
10008,}
10009,
10010,static int __init intitialize_timer_handler(void)
10011,{
10012,    // get the virtual addr
10013,"    led_axi_addr = ioremap_nocache(0xff200000, 0x1000);"
10014,"    arm_private_timer = ioremap_nocache(0xfffec600,0x2000);"
10015,
10016,    // Set LEDs to 0x200 (the leftmost LED will turn on)
10017,"    iowrite32(0x200, led_axi_addr);"
10018,    // Clear the control bits of the timer 
10019,"    iowrite32(0x0, arm_private_timer + 0x8); "
10020,
10021,    // Clear the Interrupt status register (clear any pending interrupt)
10022,"    iowrite32(0x1, arm_private_timer + 0xc);"
10023,
10024,    // Set load value
10025,"    iowrite32(0xbebc200, arm_private_timer);"
10026,
10027,    // Enable interrupt with auto reload 
10028,"    iowrite32(0b111, arm_private_timer +0x8);"
10029,
10030,    // Register the interrupt handler.
10031,"    return request_irq(29, (irq_handler_t)irq_handler, IRQF_TIMER,""timer"", (void *)(irq_handler));"
10032,}
10033,
10034,static void __exit cleanup_timer_handler(void)
10035,{
10036,    // Turn off LEDs and de-register irq handler
10037,"    iowrite32(0x0,led_axi_addr);"
10038,"    iowrite32(0x0,arm_private_timer+0x8);"
10039,"    iowrite32(0x1,arm_private_timer+0xc);"
10040,"    free_irq(29, (void*) irq_handler);"
10041,}
10042,
10043,module_init(intitialize_timer_handler);
10044,module_exit(cleanup_timer_handler);
10045,int dimension;
10046,int entry;
10047,int winningStreak[4];
10048,
10049,
10050,"scanf(""%d"", &dimension);"
10051,
10052,char** grid = malloc (sizeof(char*)*dimension);
10053,
10054,for(int i = 0; i < dimension; i++)
10055,{
10056,    grid[i] = malloc(sizeof(char) * dimension);
10057,
10058,    for(int j = 0; j < dimension; j++)
10059,    {
10060,        grid[i][j] = ' ';
10061,
10062,"        printf(""\n%d...%d"",i,j);"
10063,    }
10064,
10065,    winningStreak[i] = rand()+i;
10066,}
10067,winningStreak[i] = rand()+i;
10068,i >= 4
10069,char (*grid)[dimensions] = malloc(dimensions * sizeof *grid);
10070,sizeof(char)
10071,1
10072,#include <stdio.h>
10073,#include <stdlib.h>
10074,#include <string.h>
10075,
10076,//======================================================================================
10077,//Creación del nodo a través de estructuras
10078,typedef struct nodo
10079,{
10080,  char data;
10081,  struct nodo *left;
10082,  struct nodo *right;
10083,"} nodeType, *node;"
10084,
10085,
10086,//======================================================================================
10087,//creamos la estructura de tipo árbol BINARIO
10088,typedef struct arbol
10089,{
10090,  node root;
10091,"} treeType, *tree;"
10092,
10093,
10094,//Creamos el nodo con left and right apuntando a nada
10095,node createNode( char data_ );
10096,
10097,//Creamos el arbol
10098,tree createTree();
10099,
10100,
10101,//Escriba el árbol creado en modo inOrder. DEBE TENER POR PARÁMETRO LA RAIZ DEL ARBOL EN LA 1RA SUMMON
10102,void writeInOrder( node node_ );
10103,
10104,//Escriba el árbol creado en modo PreOrder. DEBE TENER POR PARÁMETRO LA RAIZ DEL ARBOL EN LA 1RA SUMMON
10105,void writePreOrder( node node_ );
10106,
10107,
10108,//Escriba el árbol creado en modo PostOrder. DEBE TENER POR PARÁMETRO LA RAIZ DEL ARBOL EN LA 1RA SUMMON
10109,void writePostOrder( node node_ );
10110,
10111,
10112,"//Convierte la cadena de caracteres en modo PostFijo a un árbol binario. La primera vez que se invoque la función, el parámetro DEBE OBLIGATORIAMENTE ser el nodo raíz del árbol y el último elemento de la cadena que sea un caracter legible"
10113,"char* convertToTreeFromPost( node node_, char* elemento );"
10114,
10115,int main(void) {
10116,
10117,  tree newTree = createTree();
10118,
10119,  char input[1000];
10120,  
10121,"  printf(""Ingrese el arbol en notacion PostFijo\n"");"
10122,
10123,"  fgets( input, sizeof( input ), stdin );"
10124,
10125,  int inputSize = strlen(input);
10126,
10127,  
10128,  char* lastElement = &input[inputSize - 2];
10129,
10130,"  //printf(""\nLa raiz del arbol apunta a: %p\n"", newTree -> root );"
10131,  
10132,"  //Le restamos 1, para evitar imprimir el '\0' que simboliza el fin del string y le restamos otro 1, porque las posiciones en el arreglo empiezan desde 0 y NO desde 1."
10133,"  char* pierdase = convertToTreeFromPost( newTree -> root, lastElement );"
10134,
10135,"  printf(""\nEl arbol en PreOrden es: \n"");"
10136,
10137,"  //printf(""\nLa raiz del arbol apunta a: %p\n"", newTree -> root );"
10138,  
10139,  writePreOrder( newTree -> root );
10140,  
10141,  return 0;
10142,}
10143,
10144,
10145,node createNode( char data_ )
10146,{
10147,  node newNode = (node) malloc( sizeof( nodeType ) );
10148,  newNode -> data = data_;
10149,  newNode -> left = NULL;
10150,  newNode -> right = NULL;
10151,
10152,  return newNode;
10153,}
10154,
10155,tree createTree()
10156,{
10157,  tree newTree = (tree) malloc( sizeof( treeType ) );
10158,  newTree -> root = NULL;
10159,
10160,  return newTree;
10161,}
10162,
10163,void writeInOrder( node node_ )
10164,{
10165,  if( node_ != NULL )
10166,  {
10167,    writeInOrder( node_ -> left );
10168,"    printf(""%c"", node_ -> data );"
10169,    writeInOrder( node_ -> right );
10170,  }
10171,  else
10172,  {
10173,"    printf(""#"");"
10174,  }
10175,}
10176,
10177,
10178,void writePreOrder( node node_ )
10179,{
10180,  if( node_ != NULL )
10181,  {
10182,"    printf(""%c"", node_ -> data );"
10183,    writePreOrder( node_ -> left );
10184,    writePreOrder( node_ -> right );
10185,  }
10186,  else
10187,  {
10188,"    printf(""#"");"
10189,  }
10190,}
10191,
10192,
10193,void writePostOrder( node node_ )
10194,{
10195,  if( node_ != NULL )
10196,  {
10197,    writePostOrder( node_ -> left );
10198,    writePostOrder( node_ -> right );
10199,"    printf(""%c"", node_ -> data );"
10200,  }
10201,  else
10202,  {
10203,"    printf(""#"");"
10204,  }
10205,}
10206,
10207,"char* convertToTreeFromPost( node node_, char* elemento )"
10208,{
10209,  if( (*elemento) != '#' )
10210,  {
10211,"    //printf(""\nNode 1 es: %p\n"", node_ );"
10212,    node_ = createNode( (*elemento) );
10213,"    //printf(""\nNode 2 es: %p\n"", node_ );"
10214,    elemento = (elemento - 1);
10215,"    elemento = convertToTreeFromPost( node_ -> right, elemento );"
10216,
10217,    if( (*elemento) != '#' )
10218,    {
10219,"      elemento = convertToTreeFromPost( node_ -> left, elemento );"
10220,      return elemento;
10221,    }
10222,    else if( (*elemento) == '#' )
10223,    {
10224,      elemento = (elemento - 1);
10225,      return elemento;
10226,    }
10227,  }
10228,  else if( (*elemento) == '#' )
10229,  {
10230,    
10231,    elemento = (elemento - 1);
10232,    
10233,    if( (*elemento) != '#' )
10234,    {
10235,      return elemento;
10236,    }
10237,    else if( (*elemento) == '#' )
10238,    {
10239,      return elemento;
10240,    }
10241,  } 
10242,}
10243,"char* pierdase = convertToTreeFromPost( newTree -> root, lastElement );"
10244,newTree -> root
10245,lastElement
10246,newTree -> root
10247,convertToTreeFromPost()
10248,#include <stdio.h>
10249,#include <stdlib.h>
10250,
10251,#define result
10252,
10253,"int higher(int num1 , int num2);"
10254,
10255,"int main (int argc, char *argv[]) {"
10256,    int val1;
10257,    int val2;
10258,    int num;
10259,
10260,"    num = higher(val1, val2);"
10261,
10262,"    printf(""Enter two numbers: "");"
10263,"    scanf(""%d %d"", &val1, &val2);"
10264,"    printf(""The higher number is: %d\n"", num);"
10265,    return EXIT_SUCCESS;
10266,}
10267,
10268,"int higher(int num1 , int num2) {"
10269,    // Based on what values are called from the function
10270,    // num1 or num2 should reflect as the highest.
10271,    int result;
10272,
10273,    if (num1 <= num2)
10274,        result = num2;
10275,    else
10276,        result = num1;
10277,
10278,    return result;
10279,}
10280,scanf
10281,higher
10282,return num1 <= num2 ? num2 : num1;
10283,scanf
10284,higher()
10285,scanf
10286,"printf(""Enter two numbers: "");"
10287,"scanf(""%d %d"", &val1, &val2);"
10288,"num = higher(val1, val2);"
10289,"printf(""The higher number is: %d\n"", num);"
10290,# include <stdio.h>
10291,# include <math.h>
10292,# include <stdlib.h>
10293,
10294,int main(void) 
10295,{
10296,"  int n ,N=5;"
10297,"  float theta,msum =0.0,mse; //paramters"
10298,"  int i,j; // loop"
10299,"  printf(""Enter the value of n "");"
10300,"  scanf(""%d"", &n);"
10301,"  printf(""Enter the value of theta "");"
10302,"  scanf(""%f "", &theta);"
10303,  
10304,"  //float u[n], x[n];"
10305,  
10306,  //first we fix theta and find MSE for different values of n
10307,  for(i=0;i<N;i++)
10308,    {
10309,      float sum = 0.0;
10310,      for(j=0;j<n;j++)
10311,        {
10312,          //x[j] = (-1/theta)*log(1-(rand()/RAND_MAX));
10313,          sum += (-1/theta)*log(1-(rand()/RAND_MAX)); //generates random number from unifrom dist and then converts it to exponential using inverse cdf function
10314,"          printf(""%d%d"", i, j);"
10315,        }
10316,      float thetahat = n/sum;
10317,      msum += (thetahat - theta)*(thetahat - theta);
10318,    }
10319,    mse = msum/N;
10320,"  printf(""The MSE with n=%d and theta=%f is %f"", n, theta, mse);"
10321,  
10322, 
10323,  return 0;
10324,}
10325,rand() / RAND_MAX
10326,0
10327,1
10328,(float)rand() / RAND_MAX
10329,double
10330,float
10331,"scanf(""%f "", &theta);"
10332,\n
10333,printf
10334,rand()/RAND_MAX
10335,int
10336,1.0 * rand() / RAND_MAX
10337,log(0)
10338,log(1-(rand()/RAND_MAX)
10339,log(0)
10340,1.0 * rand() / RAND_MAX
10341,log(1.0 * (RAND_MAX + 1LL - rand()) / (RAND_MAX + 1LL)
10342,"scanf(""%f "", &theta)"
10343,scanf()
10344,"if (scanf(""%f"", &theta) != 1) {"
10345,  ; // Handle bad input
10346,}
10347,double
10348,float
10349,float
10350,double
10351,double
10352,float
10353,"int a = 1, b = 2, c = 3;"
10354,"int* t[] = {&a, &b, &c};"
10355,"call memset(t, 0x0, sizeof(int*)*3)"
10356,"$3 = (void *(*)(void *, int, size_t)) 0x7ffff77e7e10 <__memset_avx2_unaligned_erms>"
10357,(gdb) print t
10358,"$4 = {0x7fffffffddc0, 0x7fffffffddc4, 0x7fffffffddc8}"
10359,sizeof(int*) * 3
10360,memset
10361,__memset_avx2_unaligned_erms
10362,$ readelf -Ws /lib64/libc.so.6 | grep ' memset'
10363,  1233: 00000000000b2df0   241 IFUNC   GLOBAL DEFAULT   14 memset@@GLIBC_2.2.5
10364,   557: 00000000000b2df0   241 FUNC    LOCAL  DEFAULT   14 memset_ifunc
10365,  6000: 00000000000b2df0   241 IFUNC   GLOBAL DEFAULT   14 memset
10366,__memset_avx2_unaligned_erms
10367,memset
10368,(gdb) t[0]=0
10369,local_memset()
10370,structures
10371,struct point{
10372,"    double x,y;"
10373,}
10374,struct segment{
10375,    struct point a;
10376,    struct point b;
10377,};
10378,line
10379,rectangle
10380,floodfill
10381,.PPM
10382,"in,out"
10383,"in,out"
10384,#include<stdio.h>
10385,int main()
10386,{ 
10387,    int a=5;
10388,"    printf(""%d"", ++a++);"
10389,    return 0;
10390,}
10391,++
10392,++
10393,a
10394,++
10395,5++
10396,++a
10397,a++
10398,++a++
10399,int a;
10400,a = 42;  // a is an lvalue and can be assigned to
10401,++a++
10402,++(a++)
10403,a++
10404,a
10405,a
10406,a
10407,a
10408,a++ = 42
10409,++a++
10410,stat()
10411,access()
10412,"int my_acess (const char *path, int mode)"
10413,st_mode
10414,#include <stdlib.h>
10415,#include <unistd.h>
10416,#include <stdio.h>
10417,#include <dirent.h>
10418,#include <sys/stat.h>
10419,#include <sys/syscall.h>
10420,#include <sys/types.h>
10421,#include <fcntl.h>
10422, 
10423,"int my_acess (const char *path, int mode){"
10424,    struct stat buf;
10425,    int check;
10426,"    int f, f2;"
10427,    int pmode;
10428,
10429,"    check=stat(path, &buf);"
10430,    if (check==-1) return -1;
10431,"    //printf(""%o\n"",buf.st_mode%512); used this to examine how st_mode worked"
10432,    pmode=buf.st_mode%512;
10433,    f=getuid();
10434,    f2=getgid();
10435,    if (f==buf.st_uid)
10436,"        printf(""you're the owner\n"");"
10437,    else if (f2==buf.st_gid)
10438,"        printf(""you're part of the group\n"");"
10439,    else
10440,"        printf(""you're other\n"");"
10441, 
10442,    return -1;
10443,}
10444,buf.st_mode%512
10445,buf.st_mode & 0777
10446,buf.st_mode & 0x1ff
10447,0777
10448,511
10449,1FF
10450,#define S_IRUSR __S_IREAD   /* Read by owner.  */
10451,#define S_IWUSR __S_IWRITE  /* Write by owner.  */
10452,#define S_IXUSR __S_IEXEC   /* Execute by owner.  */
10453,"/* Read, write, and execute by owner.  */"
10454,#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)
10455,
10456,#define S_IRGRP (S_IRUSR >> 3)  /* Read by group.  */
10457,#define S_IWGRP (S_IWUSR >> 3)  /* Write by group.  */
10458,#define S_IXGRP (S_IXUSR >> 3)  /* Execute by group.  */
10459,"/* Read, write, and execute by group.  */"
10460,#define S_IRWXG (S_IRWXU >> 3)
10461,
10462,#define S_IROTH (S_IRGRP >> 3)  /* Read by others.  */
10463,#define S_IWOTH (S_IWGRP >> 3)  /* Write by others.  */
10464,#define S_IXOTH (S_IXGRP >> 3)  /* Execute by others.  */
10465,"/* Read, write, and execute by others.  */"
10466,#define S_IRWXO (S_IRWXG >> 3)
10467,if (S_ISDIR(buf.st_mode)) {
10468,  // It is a directory
10469,}
10470,if (buf.st_mode & S_IRUSR) {
10471,  // File readable by user
10472,}
10473, char * arr[2];
10474, char ** p;
10475,
10476,
10477, int main(){
10478, 
10479,  p = arr;
10480,
10481,"  printf(""%p\n"",&arr);"
10482,"  printf(""%p\n"",arr);"
10483,
10484,"  printf(""%p\n"",&p);"
10485,"  printf(""%p\n"",p);"
10486,
10487,  /* OUTPUT 
10488,  0x10aa71010
10489,  0x10aa71010
10490,  0x10aa71020
10491,  0x10aa71010
10492,  */
10493,
10494, }
10495,&array
10496,array
10497,array
10498,&array
10499,p
10500,arr
10501,&
10502,p
10503,p
10504,p
10505,&p
10506,arr
10507,&arr
10508,&arr
10509,&arr[0]
10510,&arr
10511,char *(*)[2]
10512,&arr[0]
10513,char **
10514,printf
10515,%p
10516,void *
10517,printf
10518,void *
10519,p = arr;
10520,p
10521,arr
10522,arr
10523,printf
10524,"printf(""%p\n"",p);"
10525,p
10526,arr
10527,p
10528,char * arr[2];
10529,char ** p;
10530,printf
10531,"printf(""%p\n"",&p);"
10532,p
10533,CreateThread
10534,WaitForSingleObject
10535,#define BUFSIZE 4096
10536,
10537,
10538,HANDLE g_hChildStd_IN_Rd = NULL;
10539,HANDLE g_hChildStd_IN_Wr = NULL;
10540,HANDLE g_hChildStd_OUT_Rd = NULL;
10541,HANDLE g_hChildStd_OUT_Wr = NULL;
10542,HANDLE handle = NULL;
10543,
10544,
10545,
10546,DWORD grab_output(void * args)
10547,{   
10548,"   DWORD dwRead, total=0; "
10549,   CHAR chBuf[BUFSIZE]; 
10550,   BOOL bSuccess = FALSE;
10551,   for (;;) 
10552,   { 
10553,"      bSuccess = ReadFile( g_hChildStd_OUT_Rd, chBuf, BUFSIZE, &dwRead, NULL);"
10554,      if( ! bSuccess ) break;
10555,"        printf(""%s"", chBuf);"
10556,
10557,    }
10558,"    printf(""\n"");"
10559,    return 0;
10560,}
10561,
10562,int run()
10563,{
10564,    BOOL res; 
10565,    STARTUPINFO si;
10566,    PROCESS_INFORMATION pi;
10567,    SECURITY_ATTRIBUTES sa;
10568,    
10569,    DWORD n_size; 
10570,    
10571,"    memset(&pi, 0, sizeof(pi));"
10572,"    memset(&sa, 0, sizeof(sa));"
10573,    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
10574,    sa.bInheritHandle = TRUE;
10575,    sa.lpSecurityDescriptor = NULL;
10576,
10577,"    if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &sa, 0)) "
10578,        return GetLastError();
10579,    
10580,"    if (!SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0))"
10581,        return GetLastError();
10582,
10583,"    memset(&si, 0 ,sizeof(si));"
10584,    si.cb = sizeof(STARTUPINFOA);
10585,    si.hStdError = g_hChildStd_OUT_Wr;
10586,    si.hStdOutput = g_hChildStd_OUT_Wr; 
10587,    si.dwFlags |= STARTF_USESTDHANDLES;
10588,
10589,"    if(!CreateProcess(NULL,              "
10590,"                        ""C:\\Windows\\System32\\cmd.exe /c ping google.com"",    "
10591,"                        NULL,    "
10592,"                        NULL,   "
10593,"                        TRUE,         "
10594,"                        CREATE_NO_WINDOW, "
10595,"                        NULL,"
10596,"                        NULL,                              "
10597,"                        &si,              "
10598,                        &pi                 
10599,                        ))
10600,                        {
10601,    }
10602,    else
10603,    {
10604,"        handle = CreateThread(0, 0, grab_output, NULL, 0, NULL);"
10605,"        WaitForSingleObject(handle, INFINITE);"
10606,    }
10607,    return 0;
10608,}
10609,
10610,
10611,int main()
10612,{
10613,    run();
10614,    return 0;
10615,}
10616,GetExitCodeThread
10617,WaitForSingleObject
10618,WAIT_TIMEOUT
10619,$ gcc temp2.c && ./a.exe 
10620,
10621,Pinging google.com [172.217.168.238] with 32 bytes of data:
10622,2.217.168.238] Reply from 172.217.168.238: 7.168.238] bytes=32 time=87ms TTL=57
10623, 7.168.238] Reply from 172.217.168.238: 7.168.238] bytes=32 time=96ms TTL=57
10624, 7.168.238] Reply from 172.217.168.238: 7.168.238] bytes=32 time=86ms TTL=57
10625, 7.168.238] Reply from 172.217.168.238: 7.168.238] bytes=32 time=86ms TTL=57
10626,
10627,Ping statistics for 172.217.168.238:
10628,"    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),"
10629,Approximate round trip times in milli-seconds:
10630,"    Minimum = 86ms, Maximum = 96ms, Average = 88ms"
10631,INFINITE
10632,WaitForSingleObject
10633,INFINITE
10634,WAIT_TIMEOUT
10635,CreateThread
10636,WaitForSingleObject
10637,IcmpSendEcho2
10638,CreateThread
10639,"   if(!CreateProcess(NULL,              "
10640,"                    ""C:\\Windows\\System32\\cmd.exe /c ping google.com"",    "
10641,"                    NULL,    "
10642,"                    NULL,   "
10643,"                    TRUE,         "
10644,"                    CREATE_NO_WINDOW, "
10645,"                    NULL,"
10646,"                    NULL,                              "
10647,"                    &si,              "
10648,                    &pi                 
10649,                    ))
10650,                    {
10651,WaitForSingleObject
10652,INFINITE
10653,0
10654,IcmpSendEcho2
10655,PROCESS_INFORMATION
10656,pi
10657,CreateProcess
10658,for (;;) 
10659,{ 
10660,"   bSuccess = ReadFile( g_hChildStd_OUT_Rd, chBuf, BUFSIZE, &dwRead, NULL);"
10661,   if( ! bSuccess ) break;
10662,"   printf(""%s"", chBuf);"
10663,}
10664,for (;;) { 
10665,"   bSuccess = ReadFile(g_hChildStd_OUT_Rd, chBuf, BUFSIZE, &dwRead, NULL);"
10666,   if (!bSuccess) break;
10667,   if (dwRead == 0) break;
10668,"   fwrite(chBuf, 1, dwRead, stdout);"
10669,}
10670,WaitForSingleObject
10671,grab_output(nullptr)
10672,typedef struct nodeA NodeA;
10673,struct nodeA{
10674,        int data;
10675,        NodeA* next;
10676,};
10677,
10678,void main(){
10679,        NodeA* test1 = (NodeA*) malloc(1 * sizeof(NodeA));
10680,        test1->next = (NodeA*) malloc(1 * sizeof(NodeA));
10681,        test1->data = 999;
10682,"        printf(""NODE: next=%p data=%d\n"", test1->next, test1->data);"
10683,"        printf(""NEXT: next=%p data=%d\n"", test1->next->next, test1->next->data);"
10684,        
10685,        free(test1);
10686,"        printf(""FREE NODE: next=%p data=%d\n"", test1->next, test1->data);"
10687,"        printf(""FREE NEXT: next=%p data=%d\n"", test1->next->next, test1->next->data);"
10688,}
10689,NODE: next=0x563bd8335690 data=999
10690,NEXT: next=(nil) data=0
10691,FREE NODE: next=0x563bd8335010 data=0
10692,FREE NEXT: next=(nil) data=1
10693,test1->next
10694,void main()
10695,int
10696,void
10697,printf
10698,void*
10699,malloc
10700,free
10701,begin
10702,writeln('Umur = ');
10703,readln (umur);
10704,"setLength(tinggi, umur);"
10705,temp := 0;
10706,count := 0;
10707,
10708,in c
10709,"    strcmp(tinggi, umur);"
10710,    temp = 0;
10711,    count = 0;
10712,the output is true but i dont know the code is true or not.
10713,_Atomic
10714,atomic_exchange
10715,_Atomic
10716,typedef double at[5];
10717,_Atomic(at) atomic_array; // constraint violation
10718,_Atomic(double) atomic_array[5]; // valid
10719,_Atomic
10720,_Atomic struct { double a[5]; };
10721,struct { char c[8];}
10722,_Atomic const type*
10723,#include <stdio.h>
10724,#include <stdlib.h>
10725,#include <string.h>
10726,#include <sys/stat.h>
10727,
10728,#define BUFFER_SIZE 100
10729,
10730,"int set_tab_init_arg(char *filename, int space_size)"
10731,{
10732,        struct stat filest;
10733,"        FILE *fp = fopen(filename, ""r+"");"
10734,        int fd = fileno(fp);
10735,"        int line = 0, space = 0, var = 0, offset = 0;"
10736,
10737,"        if (fstat(fd, &filest) < 0)"
10738,                return -1;
10739,
10740,        char *filecontent = (char*)malloc(filest.st_size);
10741,        char buff[BUFFER_SIZE];
10742,
10743,        if (fp == NULL) {
10744,"                fprintf(stderr, ""cyntax: invalid file pointer!\n"");"
10745,                return -1;
10746,        }
10747,
10748,"        while (fgets(buff, BUFFER_SIZE, fp) != NULL)"
10749,"                strcat(filecontent, buff);"
10750,
10751,"        char *tmpcontent, *willbewrited = filecontent;"
10752,
10753,        for (int x = 0; x < strlen(filecontent); x++) {
10754,                if (filecontent[x] == 32) { 
10755,"                        printf(""space\n""); "
10756,                        space++; 
10757,                }
10758,
10759,                else if (filecontent[x++] == 10) { 
10760,                        line++; 
10761,"                        printf(""newline: %d\n"", line); "
10762,                        space = 0; 
10763,                }
10764,
10765,                else {
10766,"                        printf(""char\n"");"
10767,                        x++;
10768,                        var++;
10769,                }
10770,
10771,                if (space == space_size) {
10772,                        replace_spaces_to_tab();
10773,"                        printf(""space = space_size\n"");"
10774,                }
10775,
10776,"                filecontent++, offset++;"
10777,        }
10778,}
10779, a
10780, b
10781, c
10782, d
10783, e f g
10784, c h e
10785, p ğ a
10786,space
10787,newline: 1
10788,newline: 2
10789,newline: 3
10790,newline: 4
10791,space
10792,space
10793,space = space_size
10794,newline: 5
10795,space
10796,space
10797,space = space_size
10798,newline: 6
10799,space
10800,char
10801,./cyntax try -t 2
10802,try
10803,-t 2
10804,x++
10805,for
10806,x
10807,x++
10808,struct {int bet[5]; int chance; double amount}
10809,struct{uint64 numbers; char chance; double amount;}
10810,char [5]
10811,"""but i got 5049484746*10 possibility"""
10812,(49*48*47*46*45) / (5*4*3*2) * 10
10813,1906884*10
10814,19068840
10815,int
10816,Error EDOE05.CPP 55:Cannot convert 'void (interrupt *)(***)' to 'void (*)() in function main()
10817,Error EDOE05.CPP 136:Cannot convert 'void (*)()' to 'void (interrupt *)(***)' in function main()
10818,"Error EDOE05.CPP 136:Type mismatch in parameter '__isr' in call to 'setvect(int,void(interrupt*)(***))' in function main()"
10819,int main(void)
10820,{
10821,    // version printout
10822,"    printf(""\nS11-36E FIRMWARE EDOE05 TEST EDIT#05 2018-12-14\n\n"");"
10823,
10824,    initMasterDMM32(DMM32M);
10825,"    printf(""Master Analog Initialized\n"");"
10826,    initSlaveDMM32(DMM32S);
10827,"    printf(""Slave Analog Initialized\n"");"
10828,
10829,    void (*oldIRQ5handler)();
10830,    /*55*/ oldIRQ5handler = getvect(IRQ5);    // Save old interrupt handler.**
10831,"    setvect(IRQ5, adcHandlerTest);         // Install new interrupt handler."
10832,"    printf(""VECOTOR old:%04X new:%04X\n"", oldIRQ5handler, adcHandlerTest);"
10833,"    outportb(PIC1 + 1, inportb(PIC1 + 1) & ~0x20);   // Read interrupt mask register and unmask IRQ5."
10834,
10835,"    //initSerial(COM3, baudrate);"
10836,
10837,    mainLoops = 0;
10838,"    printf(""Program initiated\n"");"
10839,    //=========== MAIN LOOP============
10840,    uint key;
10841,    do {
10842,        mainLoops++;
10843,"        printf (""mainLoops: %u, interruptCount: %d\n"",  mainLoops, interruptCount);"
10844,
10845,        // Test for ESC keypress.
10846,        key = _bios_keybrd(_KEYBRD_READY)? _bios_keybrd(_KEYBRD_READ): 0;
10847,        key &= 0x00FF;
10848,            
10849,    } while (key != ESC);
10850,    //=========== /MAIN LOOP============
10851,    
10852,"    outportb(DMM32M + 9, 0x00);    // disable timer 0 interrupt."
10853,"    outportb(DMM32M + 8, 0x09);  // reset interrupt (Master analog board INTRST)"
10854,"    outportb(PIC1, EOI);"
10855,
10856,"    /*136*/ setvect(IRQ5, oldIRQ5handler);   // Restore default IRQ5 handler."
10857,    
10858,"    printf(""Program terminated\n"");"
10859,    return 0;
10860,}
10861,#include <dos.h>
10862,#include <stdio.h>
10863,#include <mem.h>
10864,#include <bios.h>
10865,#include <stdlib.h>
10866,"extern ""C"" {"
10867,"#include ""tcp.h"""
10868,}
10869,
10870,typedef unsigned char uchar;
10871,typedef unsigned int uint;
10872,typedef unsigned long ulong;
10873,
10874,const uint scanRate = 1000;  // Number of A/D scans per second.
10875,const int DMM32M = 0x300;
10876,const int DMM32S = 0x280;
10877,const int COM3 = 0x3E8;
10878,const ulong baudrate = 19200;
10879,const int PIC1 = 0x20;
10880,const int WDT = 0x1EE;
10881,const int IRQ5 = 0xD;
10882,const int ESC = 0x001B;
10883,const int EOI = 0x20;
10884,
10885,
10886,// Global variables
10887,unsigned int mainLoops;
10888,uchar oldGate = 0;
10889,uchar newGate = 0;
10890,int outputVoltage[18] = {0};
10891,int outputCurrent[18] = {0};
10892,int temperature[3];
10893,int channelSel = -32767;
10894,int refVoltage = -32767;
10895,uchar faults = 0;
10896,ulong elapsedTime = 0;
10897,int msgTimer = 0;
10898,int meterTimer = 0;
10899,int xmtComplete = 0;
10900,int powerFail = 0;
10901,"const int reset[18] = {-32767, -32767, -32767, -32767, -32767, -32767,"
10902,"                              -32767, -32767, -32767, -32767, -32767, -32767,"
10903,"                              -32767, -32767, -32767, -32767, -32767, -32767};"
10904,
10905,
10906,// Function prototypes
10907,void interrupt (*oldIRQ5handler)(...);
10908,void interrupt adcHandler(...);
10909,int initMasterDMM32(const int base);
10910,int initSlaveDMM32(const int base);
10911,int sendVoltageCurrentMsg(char *buf);
10912,int sendTimeTempMsg(char *buf);
10913,"int updateMeters(int *voltage, int *current);"
10914,int pollSerialRcvr(void);
10915,int adjustTime(char *buffer);
10916,int InitIP(void);
10917,int initCom(const ulong baud);
10918,
10919,// Rob troubleshooting etc
10920,void interrupt adcHandlerTest(...);
10921,int interruptCount;
10922,void sendData(void);
10923,
10924,// Ethernet link variables
10925,udp_Socket usock;
10926,char bigbuf[4096];
10927,char txBuf[256];
10928,char rxBuf[32];
10929,uint lport = 50000U;
10930,uint rport = 50000U;
10931,"ulong remote_addr = 0xFFFFFFFFLU;  // inet_addr(""192.168.1.2"");"
10932,
10933,ulong pkt_count = 0;  // DEBUG CODE
10934,...
10935,***
10936,void interrupt IRQ5( ... ) {
10937,void (*)(...)
10938,void (*)()
10939,void (*)(***)
10940,int
10941,FILE
10942,int
10943,int *
10944,x
10945,&x
10946,x
10947,register
10948,& (int) { 3 }
10949,int
10950,int
10951,int
10952,int
10953,int
10954,const
10955,const
10956,long long
10957,FILE
10958,FILE
10959,FILE
10960,stdio
10961,struct
10962,union
10963,int
10964,lo
10965,eth0
10966,RTNETLINK answers: No such device
10967,#include <stdio.h>
10968,
10969,int main()
10970,{
10971,"    int a, _a, b, _b, c, _c, d;"
10972,    
10973,"    printf(""Enter 1 pair of numbers\n"");"
10974,    
10975,"    scanf ( ""%d ,%d"", &a, &_a );"
10976,    
10977,"    printf(""Enter another pair of numbers\n "");"
10978,    
10979,"    scanf ( ""%d ,%d"", &b, &_b );"
10980,    
10981,            c = a + b;
10982,           _c = _a + _b;
10983,            d = c + _c;
10984,    
10985,"    printf( ""The sum of first numbers in each pair is %d\n"", c);"
10986,    
10987,"    printf( ""The sum of second numbers in each pair is %d\n"", _c);"
10988,    
10989,"    printf( ""the sum of all the numbers is %d\n"", d);"
10990,
10991,    return 0;
10992,}
10993,Enter 1 pair of numbers
10994,3
10995,4
10996,Enter another pair of numbers
10997, 5
10998,The sum of first numbers in each pair is 7
10999,The sum of second numbers in each pair is -785649472
11000,the sum of all the numbers is -785649465 
11001,scanf
11002,scanf
11003,scanf
11004,scanf()
11005,"number , number"
11006,number newline number
11007,"scanf ( ""%d %d"", &a, &_a );"
11008,"scanf ( ""%d ,%d"", &a, &_a );"
11009,scanf
11010,scanf
11011,&_a
11012,"scanf ( ""%d ,%d"", &b, &_b );"
11013,scanf
11014,b
11015,a
11016,b
11017,"""%d ,%d"""
11018,scanf
11019,scanf
11020,scanf
11021,_a
11022,_b
11023,%d
11024,"scanf(""%d%d"", &a, &_a);"
11025,scanf
11026,"int result = scanf(""%d%d"", &a, &_a);"
11027,if (result != 2)
11028,{
11029,"    fprintf(stderr, ""Error, expected two input numbers, but scanf returned %d.\n"", result);"
11030,    exit(EXIT_FAILURE);
11031,}
11032,#include <stdlib.h>
11033,exit
11034,EXIT_FAILURE
11035,","
11036,%d
11037,scanf()
11038,"   int a, _a, b, _b, c, _c, d;"
11039,    
11040,"    printf(""Enter 1 pair of numbers\n"");"
11041,    
11042,"    scanf ( ""%d%d"", &a, &_a );"
11043,    
11044,"    printf(""Enter another pair of numbers\n"");"
11045,    
11046,"    scanf ( ""%d%d"", &b, &_b );"
11047,    
11048,            c = a + b;
11049,           _c = _a + _b;
11050,            d = c + _c;
11051,    
11052,"    printf( ""The sum of first numbers in each pair is %d\n"", c);"
11053,    
11054,"    printf( ""The sum of second numbers in each pair is %d\n"", _c);"
11055,    
11056,"    printf( ""the sum of all the numbers is %d\n"", d);"
11057,
11058,    return 0;
11059,"scanf ( ""%d ,%d"", &a, &_a );"
11060,"scanf ( ""%d ,%d"", &b, &_b );"
11061,"scanf ( ""%d %d"", &a, &_a );"
11062,"scanf ( ""%d %d"", &b, &_b );"
11063,scanf
11064,%
11065,%s
11066,%f
11067,%s
11068,scanf
11069,scanf
11070,scanf
11071,%
11072,scanf
11073,scanf
11074,scanf
11075,"printf(""Enter 1 pair of numbers\n"");"
11076,
11077,"if(scanf(""%d ,%d"", &a, &_a) != 2) {"
11078,"    printf(""input error!\n"");"
11079,    exit(1);
11080,}
11081,
11082,"printf(""Enter another pair of numbers\n"");"
11083,
11084,"if(scanf(""%d ,%d"", &b, &_b != 2) {"
11085,"    printf(""input error!\n"");"
11086,    exit(1);
11087,}
11088,static int
11089,"plugins_open_plugin(const char *filename, void *data)"
11090,{
11091,    struct plugin_class plcl = {NULL};
11092,    lt_dlhandle handle;
11093,
11094,"    print_log(""-> %s %s\n"", __func__, filename);"
11095,
11096,    if (plugins_check_if_plugin_is_disabled(filename)) {
11097,        return CLI_PLUGINS_SUCCESS;
11098,    }
11099,
11100,"    if (!(handle = lt_dlopenadvise(filename, *(lt_dladvise *)data))) {"
11101,        plugins_cli_destroy();
11102,        return CLI_PLUGINS_ERR;
11103,    }
11104,
11105,"    plcl.cli_init = lt_dlsym(handle, ""cli_pre_init"");"
11106,    if (plcl.cli_init == NULL) {
11107,        plugins_cli_destroy();
11108,        return CLI_PLUGINS_ERR;
11109,    }
11110,
11111,"    if (lt_dlcaller_set_data(interface_id, handle, &plcl)) {"
11112,        plugins_cli_destroy();
11113,        return CLI_PLUGINS_ERR;
11114,    }
11115,    plcl.cli_init();
11116,
11117,    return CLI_PLUGINS_SUCCESS;
11118,}
11119,lt_dladvise_global(&advise);
11120,lt_dladvise_ext (&advise);
11121,"lt_dlforeachfile(lt_dlgetsearchpath(), &plugins_open_plugin, &advise);"
11122,"try_dlopen (/usr/lib/Foo/plugins/Bar, .la)"
11123,"try_dlopen (/usr/lib/Foo/plugins/Bar, .so)"
11124,"tryall_dlopen (/usr/lib/Foo/plugins/Bar.so, (ALL))"
11125,Calling lt_dlopen->module_open (/usr/lib/Foo/plugins/Bar.so)
11126,  Result: Failed
11127,  Error message << /usr/lib/Foo/plugins/Bar: undefined symbol: %any symbol from Foo% >>
11128,Calling lt_preopen->module_open (/usr/lib/Foo/plugins/Bar.so)
11129,  Result: Failed
11130,  Error message << file not found >>
11131,#include <stdio.h>
11132,#define do main()
11133,do {
11134,"   printf(""Hello World!\n"");"
11135,}
11136,#if 0
11137,#endif
11138,#if 0
11139,print('Hi there')
11140,#endif
11141,#if 0
11142,""""""""
11143,#endif
11144,#include<iostream>
11145,int main() {
11146,"    std::cout << ""Hi there"" << std::endl;"
11147,    return 0;
11148,}
11149,#if 0
11150,""""""""
11151,#endif
11152,""""""""
11153,""""
11154,""""""""
11155,""""""
11156,""""""" """
11157,""" """""""
11158,#if 0
11159,print('Hi there')
11160,#endif
11161,#if 0
11162,""""""" """
11163,#endif
11164,#include <iostream>
11165,int main() {
11166,"    std::cout << ""Hi there"" << std::endl;"
11167,}
11168,#if 0
11169,""" """""""
11170,#endif
11171,#include<stdio.h> 
11172,
11173,int main(){
11174,"    int sec,h,m,s; "
11175,"    scanf(""%d"", &sec);"
11176, 
11177,    h = (sec/3600);
11178,    m = ((sec-(3600*h))/60);
11179,    s = ((sec-(3600*h)-(60*m)));
11180,
11181,"    printf(""%d,%d,%d\n"", &h, &m, &s);"
11182,
11183,    return 0;
11184,}
11185,m = s / 60; s %= 60; h = m / 60; m %= 60;
11186,%
11187,-Wall -Wextra -pedantic
11188,%d
11189,"printf(""%d,%d,%d\n"", &h, &m, &s);"
11190,"printf(""%d,%d,%d\n"", h, m, s);"
11191,accept()
11192,"int child, len, option = 1, rd;"
11193,SOCKET client_socket;
11194,struct sockaddr_in client_addr;
11195,
11196,"SOCKET server_socket = socket(AF_INET, SOCK_STREAM, 0);"
11197,if (server_socket == INVALID_SOCKET)
11198,{
11199,"    fprintf(stderr, ""Unable to initialize server socket"");"
11200,    return -1;
11201,}
11202,"else printf(""Socket successfully created.\n"");"
11203,
11204,"if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(int)) == SOCKET_ERROR)"
11205,{
11206,"    fprintf(stderr, ""setsockopt for SO_REUSEADDR failed.\n"");"
11207,}
11208,"else printf(""Set SO_REUSEADDR: ON\n"");"
11209,
11210,struct sockaddr_in server_addr;
11211,server_addr.sin_family = AF_INET;
11212,server_addr.sin_addr.s_addr = INADDR_ANY;
11213,server_addr.sin_port = htons(PORT);
11214,
11215,"if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == SOCKET_ERROR)"
11216,{
11217,"    fprintf(stderr, ""Unable to bind to %s port %d\n"", inet_ntoa(server_addr.sin_addr), PORT);"
11218,"    perror("""");"
11219,    close(server_socket);
11220,    return -1;
11221,}
11222,"else printf(""Bind successful.\n"");"
11223,
11224,"if (listen(server_socket, SOMAXCONN) == SOCKET_ERROR)"
11225,{
11226,"    fprintf(stderr, ""Unable to put server socket into listen state.\n"");"
11227,    close(server_socket);
11228,    return -1;
11229,}
11230,"else printf(""Listening on %s:%d.\n"", inet_ntoa(server_addr.sin_addr), PORT);"
11231,socklen_t cli_addr_size = sizeof(client_addr);
11232,
11233,while (true)
11234,{
11235,    //HERE
11236,"    client_socket = accept(server_socket, (struct sockaddr *) &client_addr, (socklen_t*) &cli_addr_size);"
11237,    if (client_socket == INVALID_SOCKET)
11238,    {
11239,"        fprintf(stderr, ""Accept failed with %d\n"", client_socket);"
11240,"        perror("""");"
11241,        return -1;
11242,    }
11243,    else
11244,    {
11245,"        printf(""Client %s:%d joined the server.\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));"
11246,        child = fork();
11247,        if (child < 0)
11248,        {
11249,"            perror(""ERROR on fork"");"
11250,            exit(-1);
11251,        }
11252,"        printf(""fork() returned %d.\n"", child);"
11253,        if (child == 0)
11254,        {
11255,            close(server_socket);
11256,"            rd = recv(client_socket, rcvbuf, sizeof(rcvbuf), 0);"
11257,            if (rd < 0)
11258,"                perror(""Error in receiving message"");"
11259,            else if (rd == 0)
11260,"                printf(""Client %s disconnected\n"", inet_ntoa(client_addr.sin_addr));"
11261,            else
11262,            {
11263,"                sprintf(sndbuf, ""Client %s:%d: %s\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port),"
11264,                    rcvbuf);
11265,                puts(sndbuf);
11266,"                if (send(client_socket, sndbuf, sizeof(sndbuf), 0) < 0)"
11267,                {
11268,"                    perror(""Error in sending message"");"
11269,                }
11270,            }
11271,        }
11272,    }
11273,}
11274,fork()
11275,NTENV
11276,return -1;
11277,if
11278,else
11279,"} else printf(""Socket successfully created.\n"");"
11280,printf()
11281,while (true)
11282,accept
11283,_exit
11284,    if (child == 0)
11285,    {
11286,        close(server_socket);
11287,"        rd = recv(client_socket, rcvbuf, sizeof(rcvbuf), 0);"
11288,        if (rd < 0)
11289,"            perror(""Error in receiving message"");"
11290,        else if (rd == 0)
11291,"            printf(""Client %s disconnected\n"", inet_ntoa(client_addr.sin_addr));"
11292,        else
11293,        {
11294,"            sprintf(sndbuf, ""Client %s:%d: %s\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port),"
11295,                rcvbuf);
11296,            puts(sndbuf);
11297,"            if (send(client_socket, sndbuf, sizeof(sndbuf), 0) < 0)"
11298,            {
11299,"                perror(""Error in sending message"");"
11300,            }
11301,        }
11302,        _exit(0);
11303,    }
11304,wait
11305,_exit(0)
11306,_exit()
11307,#include <stdbool.h>
11308,
11309,typedef struct {
11310,    bool a;
11311,    bool b;
11312,} MyStruct2;
11313,
11314,bool g(MyStruct2 *s) {
11315,    return s->a || s->b;
11316,}
11317,
11318,bool g2(MyStruct2 *s) {
11319,    return s->a | s->b;
11320,}
11321,
11322,int main() {
11323,
11324,    return 0;
11325,}
11326,g:
11327,"        movzx   eax, BYTE PTR [rdi]"
11328,"        test    al, al"
11329,        jne     .L1
11330,"        movzx   eax, BYTE PTR [rdi+1]"
11331,.L1:
11332,        ret
11333,
11334,
11335,g2:
11336,"        movzx   eax, BYTE PTR [rdi]"
11337,"        or      al, BYTE PTR [rdi+1]"
11338,        ret
11339,
11340,
11341,main:
11342,"        xor     eax, eax"
11343,        ret
11344,g2
11345,g
11346,g2
11347,MyStruct2
11348,s->b
11349,g
11350,s->a
11351,s->b
11352,s->b
11353,s->a
11354,MyStruct2
11355,bool
11356,a||b
11357,a|b
11358,int
11359,a.ll
11360,b.ll
11361,Foo
11362,b.ll
11363,hello
11364,hello
11365,a.ll
11366,parseIRFile()
11367,LLVMContext
11368,Foo
11369,a.ll
11370,b.ll
11371,%struct.Foo.1
11372,%struct.Foo.2
11373,b.ll
11374,"void transpose(int size, int matrix[][MAX][2], int index, int index_save){"
11375,
11376,    int auxiliar_matrix[MAX][MAX];
11377,
11378,    for (int i = 0; i < size; i++){
11379,
11380,        for (int j = 0; j < size; j++){
11381,
11382,            auxiliar_matrix[i][j] = matrix[j][i][index];
11383,
11384,    }
11385,
11386,"    save(matrix, index_save, auxiliar_matrix, size) /*this just save the matrix, isnt wrong*/"
11387,
11388,}
11389,int AB[2][100][100];
11390,"[3; 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2, 1,"
11391,"[3; 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 3, 3, 2, 1, 3, 2, 1, 19, "
11392,#include <stdio.h>
11393,#include <stdint.h>
11394,#include <math.h>
11395,
11396,int main()
11397,{
11398,    long double u = 3.1415926535897932384626433832795028841971693993751058209749445923;
11399,
11400,"    printf(""[%lld; "",(unsigned long long)u);"
11401,
11402,    for (int i = 0; i < 20; i++)
11403,    {
11404,        u = 1.0 / (u - floorl(u));
11405,"        printf(""%lld, "",(unsigned long long)u);"
11406,    }
11407,
11408,    return 0;
11409,}
11410,long double
11411,L
11412,double
11413,u
11414,long double
11415,// long double u = 3.1415926535897932384626433832795028841971693993751058209749445923;
11416,long double u = 3.1415926535897932384626433832795028841971693993751058209749445923L;
11417,L
11418,"[3; 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 1, 1,         My output"
11419,"[3; 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2, 1, 84, ... WolframAlhpa"
11420,long double
11421,double
11422,long double
11423,L
11424,"printf(""%La\n"", u);"
11425,u
11426,long double u = 3.1415926535897932384626433832795028841971693993751058209749445923L;
11427,"printf(""%La\n"", u);"
11428,
11429,0x1.921fb54442d1846ap+1  // Your output may differ.
11430,"//printf(""[%lld; "",(unsigned long long)u);"
11431,"  printf(""[%llu; "",(unsigned long long)u);"
11432,double
11433,long double
11434,"printf(""%La\n"", u);"
11435,long double
11436,"%La"""
11437,u = 1.0 / (u - floorl(u));
11438,u = 1.0/0.1415926535897932384626433832795028841971693993751058209749445923
11439,u
11440,0.1415...
11441,1415...
11442,long double
11443,0.141592653589793115997963468544185161590576171875
11444,#ifndef F_CPU
11445,/* prevent compiler error by supplying a default */
11446,"# warning ""F_CPU not defined for <util/delay.h>"""
11447,# define F_CPU 1000000UL
11448,#endif
11449,main.c file : 
11450,
11451,#define BAUDE_RATE_SPEED 115200
11452,"#include ""uart_ctrl.h"""
11453,
11454,
11455,void main(){
11456,
11457,}
11458,
11459,uart_ctrl.h file : 
11460,
11461,#ifndef __UART_CTRL_H__
11462,#define __UART_CTRL_H__
11463,
11464,#ifndef BAUDE_RATE_SPEED
11465,#define BAUDE_RATE_SPEED 9600
11466,"#warning ""BAUDE_RATE_SPEED defined at 9600 in uart_ctrl.h"""
11467,#endif
11468,
11469,void uart_config();
11470,
11471,#endif 
11472,
11473,uart_ctrl.c file : 
11474,
11475,"#include ""uart_ctrl.h"""
11476,
11477,void uart_config(){
11478,
11479,MCU_REGISTER.UART = BAUDE_RATE_SPEED;
11480,
11481,}
11482,
11483,build error :
11484,
11485,"Warning     #warning ""BAUDE_RATE_SPEED defined at 9600 in uart_ctrl.h"" [-Wcpp]  \uart_ctrl.h    Build   1"
11486,#define F_CPU 20000000UL
11487,#ifndef F_CPU
11488,/* prevent compiler error by supplying a default */
11489,"# warning ""F_CPU not defined for <util/delay.h>"""
11490,# define F_CPU 1000000UL
11491,#endif
11492,#ifndef UART_BAUD_SPEED
11493,/* prevent compiler error by supplying a default */
11494,"# warning ""UART_BAUD_SPEED not defined bla bla"""
11495,# define UART_BAUD_SPEED 115200
11496,#endif
11497,#ifndef
11498,#ifndef UART_BAUD_SPEED
11499,UART_BAUD_SPEED
11500,main.c
11501,main.c
11502,BAUDE_RATE_SPEED
11503,uart_ctrl.h
11504,uart_ctrl.c
11505,BAUDE_RATE_SPEED
11506,uart_ctrl.h
11507,-DBAUDE_RATE_SPEED=9600
11508,15 / 2
11509,7
11510,15
11511,% 7
11512,ptr
11513,main
11514,typedef struct Output
11515,{
11516,    char *ptr;
11517,    DWORD len;
11518,
11519,"}Output, *POutput;"
11520,
11521,Output out; // global variable 
11522,
11523,
11524,DWORD grab_output(LPVOID args)
11525,{ 
11526,    DWORD dread;
11527,    BOOL success = FALSE;
11528,    while (1)
11529,    {
11530,"        success = ReadFile(g_hChildStd_OUT_Rd,out.ptr, 1024, &dread, NULL);"
11531,        if (!success || dread == 0 ) break;
11532,"        out.ptr = realloc(out.ptr, out.len+1024);"
11533,        out.len += dread;
11534,    }   
11535,}
11536,
11537,
11538,int run()
11539,{
11540,    BOOL res; 
11541,    STARTUPINFO si;
11542,    PROCESS_INFORMATION pi;
11543,    SECURITY_ATTRIBUTES sa;
11544,    DWORD   dwThreadIdArray[1];
11545,
11546,
11547,    
11548,    DWORD n_size; 
11549,"    memset(&si, 0 ,sizeof(si));"
11550,"    memset(&pi, 0, sizeof(pi));"
11551,"    memset(&sa, 0, sizeof(sa));"
11552,    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
11553,    sa.bInheritHandle = TRUE;
11554,    sa.lpSecurityDescriptor = NULL;
11555,
11556,"    if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &sa, 0)) "
11557,        return GetLastError();
11558,    
11559,"    if (!SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0))"
11560,        return GetLastError();
11561,
11562,    si.cb = sizeof(STARTUPINFOA);
11563,    si.hStdError = g_hChildStd_OUT_Wr;
11564,    si.hStdOutput = g_hChildStd_OUT_Wr; 
11565,    si.dwFlags |= STARTF_USESTDHANDLES;
11566,
11567,"    if(!CreateProcess(NULL,"
11568,"                        ""C:\\Windows\\System32\\cmd.exe /c dir"","
11569,"                        NULL,"
11570,"                        NULL,               "
11571,"                        TRUE,               "
11572,"                        CREATE_NEW_CONSOLE,   "
11573,"                        NULL,                "
11574,"                        NULL,                                      "
11575,"                        &si,                "
11576,                        &pi                 
11577,                        ))
11578,                        {
11579,    }
11580,    else
11581,    {
11582,        
11583,"        handle = CreateThread(0, 0, grab_output, NULL, 0, NULL);"
11584,    }
11585,    return 0;
11586,}
11587,
11588,
11589,int main()
11590,{
11591,    out.ptr = malloc(1024);
11592,    out.len = 0;
11593,    run();
11594,"    printf(""%s\n"", out.ptr);"
11595,
11596,}
11597,out.ptr
11598,gcc example.c && ./a.exe 
11599,└e╔┐═☺
11600,printf
11601,main
11602,volatile
11603,atomic
11604,volatile
11605,atomic
11606,WaitForSingleObject
11607,WaitForSingleObject()
11608,putc()
11609,printf()
11610,while(1)
11611,WaitForSingleObject
11612,CreateThread
11613,if (!success || dread == 0 ) break;
11614,return
11615,main()
11616,printf
11617,ReadFile
11618,ReadFile
11619,printf
11620,WaitForSingleObject
11621,main()
11622,return 0
11623,return
11624,char * longestPalindrome(char * s) {
11625,
11626,  int taille_chaine = sizeof(s);
11627,  s = malloc(taille_chaine * sizeof(char));
11628,
11629,  for (int i = 0; i < taille_chaine; i++) {
11630,    for (int j = i + 1; j < taille_chaine;) {
11631,      if (s[i] == s[j]) {
11632,        for (int p = j; p < taille_chaine; p++) {
11633,          s[p] = s[p + 1];
11634,        }
11635,        taille_chaine--;
11636,      } else {
11637,        j++;
11638,      }
11639,
11640,    }
11641,  }
11642,
11643,  return s;
11644,}
11645,s[p] = s[p + 1];
11646,s
11647,p == taille_chaine - 1
11648,int taille_chaine= sizeof(s);
11649,strlen
11650,s = malloc(taille_chaine *sizeof(char));
11651,malloc
11652,cat first.txt second.txt
11653,printf
11654,    size_t get_size(FILE* f) {
11655,"        fseek(f, 0, SEEK_END);"
11656,        size_t n = ftell(f);
11657,        rewind(f);
11658,        return n;
11659,    }
11660,    
11661,"    int main(int argc, char *argv[]) {"
11662,        FILE *fd;
11663,        char *buffer;
11664,        size_t file_size;
11665,    
11666,        for (int i = 0; i < argc - 1; i++) {
11667,"            fd = fopen(argv[i + 1], ""r"");"
11668,    
11669,            if (fd == NULL) {
11670,"                perror(""Error opening file"");"
11671,            }
11672,    
11673,            file_size = get_size(fd);
11674,            buffer = malloc(file_size);
11675,    
11676,"            if ( (fread(buffer, file_size, 1, fd)) <= 0 ) {"
11677,                free(buffer);
11678,                fclose(fd);
11679,                continue;
11680,            }
11681,    
11682,            else {
11683,"                printf(""%s"", buffer);"
11684,                free(buffer);
11685,                fclose(fd);
11686,            }
11687,    
11688,        }
11689,    
11690,        return 0;
11691,    }
11692,n
11693,n + 1
11694,n
11695,'\0'
11696,fread()
11697,printf()
11698,fread()
11699,fwrite()
11700,i
11701,for (int i = 1; i < argc; i+++)
11702,"fopen(argv[i], ""r"");"
11703,fclose
11704,free
11705,if
11706,continue
11707,fopen
11708,continue
11709,printf
11710,stdout
11711,FILE *
11712,fwrite
11713,"fwrite(buffer, file_size_m 1, stdout)"
11714,#define
11715,const
11716,Open XFS Manager
11717,For each device:
11718,  Open device
11719,  Register to listen device events
11720,  Check device status (and capabilities in case you are working in multi ATM environment so that you know what device you are dealing this time).
11721,  Setup device if need be and recover any error conditions reported in device status
11722,
11723,Start the service loop (Providing ATM service to customers if ATM is healthy and
11724,  maintenance personnel to execute tasks like maintaining faulty
11725,  devices and loading cash into the ATM etc.)
11726,#include<stdio.h>
11727,int main(){
11728,"    int a, b, c;"
11729,"    printf(""Enter any three numbers:"");"
11730,"    scanf(""%d %d %d"", &a, &b, &c);"
11731,    float avg = (a + b + c)/ 3;
11732,"    printf(""%.2f"", avg);"
11733,    return 0;
11734,    } 
11735,3.0f
11736,3
11737,3.0f
11738,(float) (a + b + c) / 3; // cast operator has the precedence over division operator
11739,(a + b + c) / (float) 3;
11740,(a + b + c) / 3.0f;
11741,/
11742,*
11743,/
11744,%
11745,%
11746,*
11747,/
11748,%
11749,/
11750,a/b
11751,(a/b)*b + a%b
11752,a
11753,a/b
11754,a%b
11755,1/2 == 0
11756,3/2 == 1
11757,5/2 == 2
11758,float avg = (a + b + c)/ 3;
11759,float avg = (a + b + c)/ 3.0f;
11760,./contrib/download_prerequisites
11761,mkdir build
11762,cd build
11763,../configure --prefix=/home/user/staging_root --host=arm-buildroot-linux-gnueabihf \
11764,--target=arm-buildroot-linux-gnueabihf --disable-multilib --disable-nls \
11765,--with-system-zlib --enable-languages=c --with-arch=armv7 --with-float=hard
11766,make
11767,arm-buildroot-linux-gnueabihf-cc   -g -O2 -O2  -g -O2 -DIN_GCC    -W -Wall -Wno-narrowing -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition  -isystem ./include  -fPIC -fno-inline -g -DIN_LIBGCC2 -fbuilding-libgcc -fno-stack-protector  -fPIC -fno-inline -I. -I. -I../.././gcc -I../../../libgcc -I../../../libgcc/. -I../../../libgcc/../gcc -I../../../libgcc/../include  -DHAVE_CC_TLS   -o _divsc3.o -MT _divsc3.o -MD -MP -MF _divsc3.dep -DL_divsc3 -c ../../../libgcc/libgcc2.c -fvisibility=hidden -DHIDE_EXPORTS
11768,../../../libgcc/libgcc2.c: In function '__divsc3':
11769,../../../libgcc/libgcc2.c:1874:16: error: '__LIBGCC_SF_MAX__' undeclared (first use in this function)
11770, 1874 | # define RBIG (__LIBGCC_SF_MAX__ / 2)
11771,      |                ^~~~~~~~~~~~~~~~~
11772,../../../libgcc/libgcc2.c:2063:23: note: in expansion of macro 'RBIG'
11773, 2063 |       if (FABS (d) >= RBIG)
11774,      |                       ^~~~
11775,../../../libgcc/libgcc2.c:1874:16: note: each undeclared identifier is reported only once for each function it appears in
11776, 1874 | # define RBIG (__LIBGCC_SF_MAX__ / 2)
11777,      |                ^~~~~~~~~~~~~~~~~
11778,../../../libgcc/libgcc2.c:2063:23: note: in expansion of macro 'RBIG'
11779, 2063 |       if (FABS (d) >= RBIG)
11780,      |                       ^~~~
11781,../../../libgcc/libgcc2.c:1876:17: error: '__LIBGCC_SF_EPSILON__' undeclared (first use in this function)
11782, 1876 | # define RMIN2 (__LIBGCC_SF_EPSILON__)
11783,      |                 ^~~~~~~~~~~~~~~~~~~~~
11784,../../../libgcc/libgcc2.c:2073:22: note: in expansion of macro 'RMIN2'
11785, 2073 |       if (FABS (d) < RMIN2)
11786,      |                      ^~~~~
11787,../../../libgcc/libgcc2.c:1875:16: error: '__LIBGCC_SF_MIN__' undeclared (first use in this function)
11788, 1875 | # define RMIN (__LIBGCC_SF_MIN__)
11789,      |                ^~~~~~~~~~~~~~~~~
11790,../../../libgcc/libgcc2.c:2082:21: note: in expansion of macro 'RMIN'
11791, 2082 |    if (((FABS (a) < RMIN) && (FABS (b) < RMAX2) && (FABS (d) < RMAX2))
11792,      |                     ^~~~
11793,make[2]: *** [Makefile:501: _divsc3.o] Error 1
11794,__LIBGCC_SF_*
11795,touch foo.h; arm-buildroot-linux-gnueabihf-cpp -dM foo.h
11796,__LIBGCC
11797,"grep -r ""__LIBGCC_SF_MAX__"" ."
11798,__LIBGCC_*
11799,__LIBGCC_*
11800,int** resultIndexArr = malloc(sizeof(int*) * n + 8);
11801,"int arrayItemsLastIndex[] = {0,0};"
11802,int lastAnswer = 0;
11803,
11804,for (int i = 0; i < queries_rows; i++) {
11805,    int type = *(*(queries + i));
11806,    int x = *(*(queries + i) + 1);
11807,    int y = *(*(queries + i) + 2);
11808,    
11809,    if(type == 1 ) {
11810,        int idx = ((x ^ lastAnswer) % n);
11811,"        resultIndexArr[idx] = realloc(resultIndexArr[idx], sizeof(int) * (arrayItemsLastIndex[idx] + 1));"
11812,        resultIndexArr[idx][arrayItemsLastIndex[idx]] = y;
11813,"        printf(""%d \n"", idx); //output: 0"
11814,"        print(""%d \n"", arrayItemsLastIndex[idx]); //output: 0"
11815,"        printf(""%d \n"", resultIndexArr[idx][arrayItemsLastIndex[idx]]); //output: y"
11816,        arrayItemsLastIndex[idx]++;
11817,                    
11818,    }
11819,"    printf(""%d \n"", resultIndexArr[0][0]); // garbage value }"
11820,arrayItemsLastIndex[]
11821,n
11822,arrayItemsLastIndex[]
11823,arrayItemsLastIndex[idx]
11824,idx
11825,resultArrIndex
11826,realloc
11827,resultArrIndex
11828,NULL
11829,#include <stdio.h>
11830,#include <string.h>
11831,#include <stdlib.h>
11832,
11833,"int main(int argc, char **argv) {"
11834,"    FILE* file = fopen(argv[1], ""rb"");"
11835,    int st = 0;
11836,
11837,"    fseek(file, 0, SEEK_END);"
11838,    int fileLen=ftell(file);
11839,"    printf(""%d"", fileLen);"
11840,"    fseek(file, 0, SEEK_SET);"
11841,
11842,    ...
11843,}
11844,ftell
11845,long int
11846,stat /path/to/file
11847,"echo -n -e $(printf ""\x86%.0s"" {1..30}) > bytefile"
11848,stat bytefile
11849,"stat --format=""%s bytes"" bytefile"
11850,File: bytefile
11851,  Size: 30              Blocks: 8          IO Block: 4096   regular file
11852,[...]
11853,30 bytes
11854,#include <stdio.h>
11855,#include <stdlib.h>
11856,
11857,"int main(int argc, char **argv) {"
11858,"    FILE* file = fopen(argv[1], ""rb"");"
11859,
11860,"    fseek(file, 0, SEEK_END);"
11861,    int fileLen=ftell(file);
11862,"    printf(""%ld\n"", fileLen);"
11863,    fclose(file);
11864,}
11865,#include <stdio.h>                                                                                         
11866,#include <stdlib.h>                                                                                        
11867,                                                                                                           
11868,#include <sys/types.h>                                                                                     
11869,#include <sys/stat.h>                                                                                      
11870,#include <unistd.h>                                                                                        
11871,                                                                                                           
11872,"int main(int argc, char **argv) {                                                                          "
11873,"    FILE* file = fopen(argv[1], ""rb"");                                                                     "
11874,"    int fileLen, fd;                                                                                       "
11875,    struct stat buff;                                                                                      
11876,                                                                                                           
11877,"    fseek(file, 0, SEEK_END);                                                                              "
11878,    fileLen=ftell(file);                                                                                   
11879,"    printf(""%ld\n"", fileLen);                                                                               "
11880,                      
11881,"    // New method, with fstat.                                                                                 "
11882,    fd = fileno(file);                                                                                     
11883,                                                                                                           
11884,"    fstat(fd, &buff);                                                                                      "
11885,    off_t size = buff.st_size;                                                                             
11886,"    printf(""%ld\n"", size);                                                                                 "
11887,                                                                                                           
11888,    fclose(file);                                                                                          
11889,}
11890,printf 
11891,printf
11892,"printf(""test: %d"", c/ 2);"
11893,int main() {
11894,    float a = 1.5;
11895,    int b = 2;
11896,    int c = a + b;
11897,"    printf(""test: %d"", (a+b)/ 2);"
11898,}
11899,a + b
11900,int
11901,1.5 + 2
11902,3.5
11903,c
11904,3
11905,c
11906,2
11907,int
11908,c / 2
11909,int
11910,3 / 2
11911,1
11912,"printf(""test: %d"", (a+b)/ 2);"
11913,a + b
11914,float
11915,float
11916,float
11917,(a + b) / 2
11918,float
11919,printf
11920,double
11921,"printf(""test: %d"", (double)((a+b)/ 2));"
11922,%d
11923,int
11924,#define _GNU_SOURCE
11925,#include <dlfcn.h>
11926,#include <stdio.h>
11927,#include <time.h>
11928,#include <unistd.h>
11929,
11930,static  struct tm * (*real_localtime)(const time_t *clock) = NULL;
11931,
11932,/* wrapping write function call */
11933,struct tm * localtime(const time_t *clock)
11934,{
11935,"    printf(""Who called me? %d\n"", getuid());"
11936,
11937,    /* Fetch the real localtime function from glibc */
11938,"    real_localtime = dlsym(RTLD_NEXT, ""localtime"");"
11939,    return real_localtime(clock);
11940,}
11941,gcc -fPIC -shared -o localtime.so localtime.c -ldl
11942,LD_PRELOAD=/path/to/your/localtime.so /path/to/app/using/localtime
11943,#include <stdio.h>
11944,#include <time.h>
11945,
11946,int main () {
11947,   time_t rawtime;
11948,   struct tm *info;
11949,   time( &rawtime );
11950,   info = localtime( &rawtime );
11951,"   printf(""Current local time and date: %s"", asctime(info));"
11952,   return(0);
11953,}
11954,"% cc -c localtime.c && gcc -fPIC -shared -o localtime.so localtime.c -ldl ; cc -o x x.c ; sh -c ""LD_PRELOAD=/path/to/your/localtime.so ./x"""
11955,Who called me? 1001
11956,Current local time and date: Fri Sep  2 13:25:00 2022
11957,printf()
11958,syslog()
11959,ltrace
11960,ltrace
11961,CreateThread
11962," HANDLE handle = CreateThread(0,0,custom_function, NULL,0,NULL);"
11963,custom_function
11964,DWORD custom_function(void)
11965,{
11966,"    printf(""Hello from callback function"");"
11967,}
11968,main.c:154:37: warning: passing argument 3 of 'CreateThread' from incompatible pointer type [-Wincompatible-pointer-types]    
11969,"  154 |         handle = CreateThread(0, 0, custom_function, NULL, 0, NULL);"
11970,      |                                     ^~~~~~~~~~~
11971,      |                                     |
11972,      |                                     DWORD (*)(void) {aka long unsigned int (*)(void)}
11973,"In file included from C:/msys64/mingw64/include/winbase.h:29,"
11974,"                 from C:/msys64/mingw64/include/windows.h:70,"
11975,                 from rce.c:3:
11976,C:/msys64/mingw64/include/processthreadsapi.h:279:127: note: expected 'LPTHREAD_START_ROUTINE' {aka 'long unsigned int (*)(void *)'} but argument is of type 'DWORD (*)(void)' {aka 'long unsigned int (*)(void)'}
11977,"  279 |   WINBASEAPI HANDLE WINAPI CreateThread (LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);"
11978,      |                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~
11979,CreateThread
11980,long unsigned int (*)(void *)
11981,DWORD
11982,long unsigned int
11983,void*
11984,void
11985,DWORD custom_function(void* argument)
11986,void*
11987,CreateThread
11988,ThreadProc
11989,void*
11990,DWORD WINAPI custom_function (LPVOID lpParam);
11991,WINAPI
11992,__stdcall
11993,__cdecl
11994,__cdecl
11995,WINAPI
11996,__stdcall
11997,WINAPI
11998,int (__cdecl *ptr)(void) = main;
11999,int (__stdcall *ptr)(void) = main;
12000,__cdecl
12001,__cdecl
12002,__cdecl
12003,"#pragma arm section code=""core0itcm"""
12004,void function1_core0()
12005,{
12006,  < program body xxx>
12007,}
12008,#pragma arm section code
12009,
12010,..
12011,"#pragma arm section code=""core1itcm"""
12012,void function1_core1()
12013,{
12014,    < program body xxx>
12015,}
12016,#pragma arm section code
12017,#define PROGRAM_BODY \
12018,line 1 \
12019,line 2 \
12020,... \
12021,line n-1 \
12022,line n
12023,
12024,"#pragma arm section code=""core0itcm"""
12025,void function1_core0()
12026,{
12027,PROGRAM_BODY
12028,}
12029,#pragma arm section code
12030,"#pragma arm section code=""core0itcm"""
12031,void function1_core0()
12032,{
12033,"#include ""program_body.h"""
12034,}
12035,#pragma arm section code
12036,pragma
12037,array[4]
12038,static int a[4];
12039,static int b;
12040,// ...    
12041,a[4] = 42;
12042,b
12043,struct
12044,struct comms_block {
12045,    enum comms_block_type block_type;
12046,    size_t len;
12047,    uint8_t variable_data[1];
12048,};
12049,t
12050,len
12051,"struct comms_block *new_comms_block(enum_comms_block_type t, size_t len) "
12052,{
12053,    struct comms_block *b = malloc(sizeof(*b) + len - 1);
12054,    b->block_type = t;
12055,    b->len = len;
12056,    return b;
12057,}
12058,struct comms_block
12059,len
12060,variable_data[0]
12061,variable_data[]
12062,(len - 1)
12063,struct
12064,struct
12065,struct
12066,char a[4]; // set aside 4 bytes (uninitialised)
12067,
12068,"char a[] = { 'a', 'b', 'c', 'd' }; // set aside 4 bytes (initialised)"
12069,// Above is NOT a string!
12070,
12071,"char a[] = ""abc""; // 3 + 1 bytes initialised"
12072,// Above IS a string (null terminated array of chars.
12073,"glReadPixels(0, 0,window_width, window_height, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid*) Buffer);"
12074,Buffer
12075,AV_PIX_FMT_YUV420P
12076,Specified pixel format  yuyv422 is invalid or not supported
12077,"ret = avcodec_open2(c, codec, &opt);"
12078,Specified pixel format  yuyv422 is invalid or not supported
12079,#define SCALE_FLAGS SWS_BICUBIC
12080,SWS_BICUBIC
12081,AV_PIX_FMT_RGBA
12082,Buffer
12083,#define STREAM_PIX_FMT AV_PIX_FMT_YUV420P
12084,...
12085,"void video_encoder::set_frame_yuv_from_rgb(AVFrame *frame, struct SwsContext *sws_context) {"
12086,    const int in_linesize[1] = { 4 * width };
12087,
12088,    sws_context = sws_getContext(
12089,"            width, height, AV_PIX_FMT_RGBA,"
12090,"            width, height, STREAM_PIX_FMT,"
12091,"            SWS_BICUBIC, 0, 0, 0);"
12092,
12093,"    sws_scale(sws_context, (const uint8_t * const *)&rgb_data, in_linesize, 0,"
12094,"            height, frame->data, frame->linesize);"
12095,}
12096,#include<stdio.h>
12097,#include<stdlib.h>
12098,
12099,struct Node{
12100,    int data;
12101,    struct Node* next;
12102,    struct Node* prev;
12103,};
12104,
12105,struct Node* head;
12106,
12107,void InsertatBegin(int a){
12108,    struct Node* NewNode = (struct Node*)(malloc(sizeof(struct Node*)));
12109,    NewNode->data = a;
12110,    NewNode->next = NULL;
12111,    NewNode->prev = NULL;
12112,    if (head == NULL){
12113,        head = NewNode;
12114,        return;
12115,    }
12116,    NewNode->next = head;
12117,    head->prev = NewNode;
12118,    head = NewNode;
12119,
12120,}
12121,
12122,void traverse(){
12123,    struct Node* temp = head;
12124,    while (temp != NULL) {
12125,    if (temp->next == NULL) {
12126,"        printf("" %d->NULL"", temp->data);"
12127,        }
12128,        else {
12129,"            printf("" %d->"", temp->data);"
12130,        }
12131,        temp = temp->next; // Traversing the List till end
12132,    }
12133,"    printf(""\n"");"
12134,}
12135,
12136,int main(){
12137,    head = NULL;
12138,    InsertatBegin(5);
12139,    InsertatBegin(6);
12140,    InsertatBegin(7);
12141,    InsertatBegin(8);
12142,    InsertatBegin(9);
12143,    traverse();
12144,
12145,}
12146,Output:
12147,        752904464-> 752904448-> 752904432-> 752904416-> 5->NULL
12148,malloc(sizeof(struct Node*))
12149,malloc(sizeof(struct Node))
12150,sizeof(struct Node*) != sizeof(struct Node)
12151,struct Node* NewNode = (struct Node*)(malloc(sizeof(struct Node*)));
12152,struct Node* NewNode = (struct Node*)malloc( sizeof(struct Node*));
12153,struct Node* NewNode = (struct Node*)malloc(sizeof(struct Node));
12154,malloc( )
12155,struct Node* NewNode = malloc(sizeof(struct Node));
12156,struct Node
12157,struct Node* NewNode = malloc( sizeof *NewNode );
12158,struct Node *NewNode = malloc( sizeof *NewNode );
12159,NewNode
12160,typedef
12161,struct foo {
12162,    int bar0;
12163,    int bar1;
12164,};
12165,typedef struct foo foo_t; // a conventional naming style
12166,/* or  combined...*/
12167,typedef struct foo {
12168,    int bar0;
12169,    int bar1;
12170,} foo_t;
12171,Node_t *NewNode = malloc( sizeof *NewNode );
12172,malloc( sizeof struct Node );
12173,malloc( sizeof  *NewNode );
12174,malloc(sizeof struct Node)
12175,sizeof
12176,malloc(sizeof (struct Node))
12177,malloc(sizeof *NewNode)
12178,*NewNode
12179,Node
12180,Node*
12181,struct Node* NewNode = (struct Node*) malloc(sizeof(struct Node));
12182,struct Node* NewNode = (struct Node*)(malloc(sizeof(struct Node*)));
12183,struct Node* NewNode = (struct Node*)(malloc(sizeof(struct Node)));
12184,sizeof(struct Node*)
12185,struct Node* NewNode = (struct Node*)(malloc(12));
12186,sizeof(struct Node)
12187,sizeof(struct Node*)
12188,    #include<stdio.h>
12189,#include<stdlib.h>
12190,
12191,struct Node {
12192,    int data;
12193,    struct Node* next;
12194,    struct Node* prev;
12195,};
12196,
12197,struct Node* head;
12198,
12199,void InsertatBegin(int a) {
12200,    struct Node* NewNode = (struct Node*)(malloc(sizeof(struct Node)));
12201,    NewNode->data = a;
12202,    NewNode->next = NULL;
12203,    NewNode->prev = NULL;
12204,    if (head == NULL) {
12205,        head = NewNode;
12206,        return;
12207,    }
12208,    NewNode->next = head;
12209,    head->prev = NewNode;
12210,    head = NewNode;
12211,
12212,}
12213,
12214,void traverse() {
12215,    struct Node* temp = head;
12216,    while (temp != NULL) {
12217,        if (temp->next == NULL) {
12218,"            printf("" %d->NULL"", temp->data);"
12219,        }
12220,        else {
12221,"            printf("" %d->"", temp->data);"
12222,        }
12223,        temp = temp->next; // Traversing the List till end
12224,    }
12225,"    printf(""\n"");"
12226,}
12227,
12228,int main() {
12229,    head = NULL;
12230,    InsertatBegin(5);
12231,    InsertatBegin(6);
12232,    InsertatBegin(7);
12233,    InsertatBegin(8);
12234,    InsertatBegin(9);
12235,    traverse();
12236,
12237,}
12238,#include <stdio.h>
12239,
12240,int main()
12241,{
12242,"    function1(1, 2);"
12243,}
12244,
12245,"int function1(int a, int b)"
12246,{
12247,    int c = a + b; 
12248,    return c; 
12249,}
12250,bm CallStackPractice!function1
12251,g
12252,p
12253,ebp+8
12254,0:000> ? poi(ebp+8)
12255,Evaluate expression: 1 = 00000001
12256,ebp+12
12257,0:000> ? poi(ebp+12)
12258,Evaluate expression: 270729434 = 102300da
12259,2 = 00000002
12260,main
12261,argc
12262,argv
12263,function1
12264,ebp
12265,esp+4
12266,esp+8
12267,2
12268,ebp+12
12269,esp+4
12270,2
12271,esp+8
12272,1
12273,[esp+4]
12274,[esp+8]
12275,12
12276,esp+0xc
12277,esp+0n12
12278,esp+c
12279,12
12280,0x12
12281,0n12
12282,0xC
12283,n 10
12284,0:000> ? 12
12285,Evaluate expression: 18 = 00000000`00000012
12286,0:000> n 10
12287,base is 10
12288,0:000> ? 12
12289,Evaluate expression: 12 = 00000000`0000000c
12290,1:005:x86> n 16
12291,base is 16
12292,1:005:x86> ? poi(ebp+8)
12293,Evaluate expression: 1 = 00000001
12294,1:005:x86> ? poi(ebp+c)
12295,Evaluate expression: 2 = 00000002
12296,1:005:x86> ?poi(ebp +c)
12297,Memory access error at ')'
12298,dps
12299,1:005:x86> dps ebp-c L7
12300,008ff60c  cccccccc       <-- magic number (4x INT 3 breakpoint)
12301,008ff610  00000003        
12302,008ff614  cccccccc
12303,008ff618  008ff6f4
12304,008ff61c  00fb189a DebugESPEBP!main+0x2a [C:\...\DebugESPEBP.cpp @ 13]
12305,008ff620  00000001        <-- a
12306,008ff624  00000002        <-- b
12307,dps
12308,int main()
12309,{
12310,    EVP_MD_CTX *mdctx = NULL;
12311,    int ret = 0;
12312,    unsigned char *sig;
12313,    EVP_PKEY *key = NULL;
12314,    EVP_PKEY_CTX *ctx = NULL;
12315,"    char *msg = ""This is a nice message to be signed."";"
12316,    int len;
12317,    size_t siglen;
12318,    FILE *fp;
12319,    char sig64[512];
12320,    unsigned char md[SHA256_DIGEST_LENGTH];
12321,    SHA256_CTX sha256;
12322,    SHA256_Init(&sha256);
12323,"    SHA256_Update(&sha256, msg, strlen(msg));"
12324,"    SHA256_Final(md, &sha256);"
12325,
12326,    sig = NULL;
12327,    len = strlen(msg);
12328,
12329,"    fp = fopen(""MYPRIVATEKEY.KEY"", ""r"");"
12330,    key = EVP_PKEY_new();
12331,"    PEM_read_PrivateKey(fp, &key, NULL, NULL);"
12332,"    ctx = EVP_PKEY_CTX_new(key, NULL);"
12333,
12334,    if (EVP_PKEY_sign_init(ctx) <= 0)
12335,        goto err;
12336,"    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) <= 0)"
12337,        goto err;
12338,"    if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)"
12339,        goto err;
12340,
12341,
12342,    /* Determine buffer length */
12343,"    if (EVP_PKEY_sign(ctx, NULL, &siglen, md, SHA256_DIGEST_LENGTH) <= 0)"
12344,        goto err;
12345,
12346,    sig = OPENSSL_malloc(siglen);
12347,
12348,    if (!sig)
12349,        goto err;
12350,
12351,"    if (EVP_PKEY_sign(ctx, sig, &siglen, md, SHA256_DIGEST_LENGTH) <= 0)"
12352,        goto err;
12353,
12354,    /* Signature is siglen bytes written to buffer sig */
12355,
12356,    /* Success */
12357,    ret = 1;
12358,"    Encode_B64(sig, siglen, sig64);"
12359,"    printf(""Signature: %s\n"", sig64);"
12360,
12361,err:
12362,    if(ret != 1)
12363,    {
12364,        /* Do some error handling */
12365,    }
12366,
12367,    /* Clean up */
12368,    if(mdctx) EVP_MD_CTX_free(mdctx);
12369,    EVP_PKEY_free(key);
12370,    EVP_PKEY_CTX_free(ctx);
12371,    if(sig && !ret) OPENSSL_free(sig);
12372,
12373,    return 0;
12374,}
12375,"EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256())"
12376,EVP_PKEY_CTX_set_rsa_mgf1_md()
12377,EVP_PKEY_CTX_set_rsa_pss_saltlen()
12378,RSA_PSS_SALTLEN_MAX
12379,RSA_PSS_SALTLEN_DIGEST
12380,openssl pkeyutl -verify -in <message hash file> -inkey <public key file> -sigfile <signature file> -pubin -pkeyopt rsa_padding_mode:pss -pkeyopt digest:sha256
12381,-pkeyopt rsa_mgf1_md:sha256 -pkeyopt rsa_pss_saltlen:max
12382,#define N 5
12383,constexpr
12384,ALL_CAPS
12385,enum class
12386,PascalCase
12387,enum
12388,enum class
12389,enum
12390,enum class
12391,Options | Text Editor | C/C++ | Advanced | Browsing/Navigation | Disable Database
12392,#include <stdio.h>
12393,
12394,int main(void) {
12395,  
12396,  int array[5]; //the array with x items
12397,  int target = array[1]; //target is any second value of the array
12398,
12399,  for (int y = 0; y < 5; y++){ //taking 5 user inputs
12400,    if (y == 0){
12401,"      printf(""Enter your %dst item: "", y+1);"
12402,"      scanf(""%d"", &array[5]);"
12403,    } else if (y == 1){    
12404,"      printf(""Enter your %dnd item: "", y+1);"
12405,"      scanf(""%d"", &array[5]);"
12406,    } else if (y == 2){
12407,"      printf(""Enter your %drd item: "", y+1);"
12408,"      scanf(""%d"", &array[5]);"
12409,    } else{
12410,"      printf(""Enter your %dth item: "", y+1);"
12411,"      scanf(""%d"", &array[5]);"
12412,    }
12413,  }
12414,  
12415,  for (int x=0 ; x < 5; x++){ //printing out array
12416,"    printf(""Array[%d] = %d\n"", x, array[x]);"
12417,  }
12418,}
12419,&array[5]
12420,if
12421,"scanf(""%d"", &array[5]);"
12422,"scanf(""%d"", &array[y]);"
12423,&array[5]
12424,-Wall -Wextra -pedantic
12425,int target = array[1];
12426,target
12427,array[1]
12428,&array[5]
12429,"printf(""Array[%d] = %d\n"", x, array[x]);"
12430,#include <stdio.h>
12431,
12432,int main (void) 
12433,{
12434,  int array[5];
12435,  int* target = &array[1];
12436,
12437,  for (int i = 0; i < 5; i++)
12438,  {
12439,"    const char* nstr[] = {""st"", ""nd"", ""rd"", ""th""};"
12440,    int index;
12441,    if(i > 3)
12442,      index = 3;
12443,    else
12444,      index = i;
12445,
12446,"    printf(""Enter your %d%s item: "", i+1, nstr[index]);"
12447,"    scanf(""%d"",&array[i]);"
12448,  }
12449,  for (int i=0; i < 5; i++)
12450,  {
12451,"    printf(""Array[%d] = %d\n"", i, array[i]);"
12452,  }
12453,
12454,"  printf(""Target: %d\n"", *target);"
12455,}
12456,Enter your 1st item: 1
12457,Enter your 2nd item: 2
12458,Enter your 3rd item: 3
12459,Enter your 4th item: 4
12460,Enter your 5th item: 5
12461,Array[0] = 1
12462,Array[1] = 2
12463,Array[2] = 3
12464,Array[3] = 4
12465,Array[4] = 5
12466,Target: 2
12467,for (int y = 0; y < 5; y++){ //taking 5 user inputs
12468,"    printf(""Enter your %dst item: "", y+1);"
12469,"    scanf(""%d"", &array[y]);"
12470,}
12471,for (int y = 0; y < 5; y++){ //taking 5 user inputs
12472,"     printf(""Enter your %dst item: "", y+1);"
12473,"     scanf(""%d"", array+y);"
12474,}
12475,    int main(void) {
12476,
12477,      int array[5]; //the array with x items
12478,      //int target = array[1]; //target is any second value of the array I dont know what you want here
12479,
12480,      for (int y = 0; y < 5; y++){ //taking 5 user inputs
12481,"          printf(""Enter your %dst item: "", y+1);"
12482,"          scanf(""%d"", array+y);"
12483,      }
12484,
12485,      for (int x=0 ; x < 5; x++){ //printing out array
12486,"          printf(""Array[%d] = %d\n"", x, array[x]);"
12487,      }
12488,   }
12489,"err = open(""path/foo.txt"", O_RDWR | O_CREAT,0777);"
12490,open()
12491,man 2 open
12492,open
12493,open(2)
12494,man 2 open
12495,/
12496,n
12497,N
12498,q
12499,O_TRUNC
12500,If the file already exists and is a regular file and the access mode allows
12501,"writing (i.e., is  O_RDWR  or O_WRONLY)  it  will be truncated to length 0."
12502,"If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored."
12503,"Otherwise, the effect of O_TRUNC is unspecified."
12504,fopen(3)
12505,mode
12506,w+
12507,O_RDWR | O_CREAT | O_TRUNC
12508,open(2)
12509,open(2)
12510,FILE*
12511,fread(3)
12512,0777
12513,0666
12514,for(ic = 0; ic < (N_TOTAL-1); ic++)
12515,{
12516,     for (jc = ic+1; jc < N_TOTAL; jc++)
12517,          { 
12518,             
12519,               rc_x = X[ic]-X[jc];
12520,               rc_z = Z[ic]-Z[jc];
12521,
12522,            /* Minimum image convention */
12523,            if (fabs(rc_x) > LxScaled/2.0)
12524,              {
12525,"                rc_x = rc_x - SignR (LxScaled, rc_x);"
12526,              }
12527,            if (fabs(rc_z) > LzScaled/2.0)
12528,              {
12529,"                rc_z = rc_z - SignR (LzScaled, rc_z);"
12530,              }  
12531,     
12532,            rij = sqrt(rc_x * rc_x + rc_z * rc_z);
12533,            rr = rr + (rc_x * rc_x + rc_z * rc_z);
12534,            
12535,            /* Compute Force : Yukawa potential*/
12536,            second = exp (-rij * Xi ) * ((1.0*(1.0))/rij);
12537,            third = (Xi+1.0/rij);
12538,            a = second * third;
12539,
12540,            a_x[ic] = a_x[ic] + (rc_x/rij)*a;
12541,            a_x[jc] = a_x[jc] - (rc_x/rij)*a; 
12542,            a_z[ic] = a_z[ic] + (rc_z/rij)*a;
12543,            a_z[jc] = a_z[jc] - (rc_z/rij)*a;
12544,
12545,        uVal = second;
12546,        uSum = uSum + (second);
12547,        
12548,         }  
12549,      }
12550,    } 
12551,#pragma omp atomic
12552,"#pragma omp parallel for schedule(guided, 8) reduction(+:rr, uSum) default(shared) private(ic, jc, rc_x, rc_z, rij, uVal, second, third, a) "
12553,
12554,for(ic = 0; ic < (N_TOTAL-1); ic++)
12555,{
12556,     for (jc = ic+1; jc < N_TOTAL; jc++)
12557,          { 
12558,             
12559,               rc_x = X[ic]-X[jc];
12560,               rc_z = Z[ic]-Z[jc];
12561,
12562,            /* Minimum image convention */
12563,            if (fabs(rc_x) > LxScaled/2.0)
12564,              {
12565,                #pragma omp atomic
12566,"                rc_x = rc_x - SignR (LxScaled, rc_x);"
12567,              }
12568,            if (fabs(rc_z) > LzScaled/2.0)
12569,              {
12570,                #pragma omp atomic
12571,"                rc_z = rc_z - SignR (LzScaled, rc_z);"
12572,              }  
12573,     
12574,            rij = sqrt(rc_x * rc_x + rc_z * rc_z);
12575,            rr = rr + (rc_x * rc_x + rc_z * rc_z);
12576,            
12577,            /* Compute Force : Yukawa potential*/
12578,            second = exp (-rij * Xi ) * ((1.0*(1.0))/rij);
12579,            third = (Xi+1.0/rij);
12580,            a = second * third;
12581,
12582,            #pragma omp atomic
12583,            a_x[ic] = a_x[ic] + (rc_x/rij)*a;
12584,            #pragma omp atomic
12585,            a_x[jc] = a_x[jc] - (rc_x/rij)*a; 
12586,            #pragma omp atomic
12587,            a_z[ic] = a_z[ic] + (rc_z/rij)*a;
12588,            #pragma omp atomic
12589,            a_z[jc] = a_z[jc] - (rc_z/rij)*a;
12590,
12591,        uVal = second;
12592,        uSum = uSum + (second);
12593,        
12594,         }  
12595,      }
12596,    } 
12597,rc_x
12598,rc_z
12599,uVal
12600,uVal
12601,private
12602,rc_x
12603,rc_z
12604,LxScaled/2.0
12605,LxScaled*0.5
12606,"#pragma omp parallel default(none) shared(X,Z,a_x,a_z, uSum, rr, Xi) "
12607,{
12608,    double a_x_local[N_TOTAL];
12609,    double a_z_local[N_TOTAL];
12610,    for (int jc = 0; jc < N_TOTAL; jc++) {
12611,        a_x_local[jc] = 0.0;
12612,        a_z_local[jc] = 0.0;
12613,    }
12614,
12615,"    #pragma omp for schedule(guided, 8) reduction(+:rr, uSum) "
12616,    for(int ic = 0; ic < (N_TOTAL-1); ic++)
12617,    {
12618,        for (int jc = ic+1; jc < N_TOTAL; jc++)
12619,            { 
12620,                double rc_x = X[ic]-X[jc];
12621,                double rc_z = Z[ic]-Z[jc];
12622,                /* Minimum image convention */
12623,                if (fabs(rc_x) > 0.5*LxScaled)
12624,"                    rc_x -=  SignR (LxScaled, rc_x);"
12625,                if (fabs(rc_z) > 0.5*LzScaled)
12626,"                    rc_z -=  SignR (LzScaled, rc_z);"
12627,                const double d_rr=rc_x * rc_x + rc_z * rc_z;
12628,                rr += d_rr;
12629,                const double rij = sqrt(d_rr);
12630,                const double rij_1 = 1.0/rij;           
12631,                /* Compute Force : Yukawa potential*/
12632,                const double second = exp (-rij * Xi )*rij_1;
12633,                const double second_x_third = second * (Xi+rij_1);
12634,                const double d_rc_x = rc_x* rij_1 * second_x_third;
12635,                const double d_rc_z = rc_z* rij_1 * second_x_third;
12636,
12637,                a_x_local[ic] += d_rc_x;
12638,                a_x_local[jc] -= d_rc_x; 
12639,                a_z_local[ic] += d_rc_z;
12640,                a_z_local[jc] -= d_rc_z;
12641,
12642,                //uVal = second; Shoud be calculated when needed
12643,                uSum += second;
12644,            }  
12645,    }
12646,    for (int jc = 0; jc < N_TOTAL; jc++) {
12647,        #pragma omp atomic
12648,        a_x[jc] += a_x_local[jc];
12649,        #pragma omp atomic
12650,        a_z[jc] += a_z_local[jc];
12651,    } 
12652,} 
12653,SignR
12654,Measured runtimes (N_TOTAL=10000):
12655,Your serial code=0.520492 s
12656,Your parallel code=0.169654 s
12657,PierU's parallel code=0.140338 s
12658,My parallel code=0.092958 s
12659,"#pragma omp parallel for schedule(guided, 8) reduction(+:rr, uSum) default(shared) private(ic, jc, rc_x, rc_z, rij, uVal, second, third, a) "
12660,
12661,for(ic = 0; ic < (N_TOTAL-1); ic++)
12662,{
12663,"    double *a_x_local, *a_z_local;"
12664,    a_x_local = (double *)malloc(N_TOTAL * sizeof(double));
12665,    a_z_local = (double *)malloc(N_TOTAL * sizeof(double));
12666,    for (jc = 0; jc < N_TOTAL; jc++) {
12667,        a_x_local[jc] = 0.0;
12668,        a_z_local[jc] = 0.0;
12669,    }
12670,    for (jc = ic+1; jc < N_TOTAL; jc++)
12671,        { 
12672,            rc_x = X[ic]-X[jc];
12673,            rc_z = Z[ic]-Z[jc];
12674,            /* Minimum image convention */
12675,            if (fabs(rc_x) > LxScaled/2.0)
12676,"                rc_x = rc_x - SignR (LxScaled, rc_x);"
12677,            if (fabs(rc_z) > LzScaled/2.0)
12678,"                rc_z = rc_z - SignR (LzScaled, rc_z);"
12679,            rij = sqrt(rc_x * rc_x + rc_z * rc_z);
12680,            rr = rr + (rc_x * rc_x + rc_z * rc_z);
12681,            /* Compute Force : Yukawa potential*/
12682,            second = exp (-rij * Xi ) * ((1.0*(1.0))/rij);
12683,            third = (Xi+1.0/rij);
12684,            a = second * third;
12685,
12686,            a_x_local[ic] += (rc_x/rij)*a;
12687,            a_x_local[jc] -= (rc_x/rij)*a; 
12688,            a_z_local[ic] += (rc_z/rij)*a;
12689,            a_z_local[jc] -= (rc_z/rij)*a;
12690,
12691,            uVal = second;
12692,            uSum = uSum + (second);
12693,        }  
12694,    }
12695,    #pragma omp critical
12696,    for (jc = 0; jc < N_TOTAL; jc++) {
12697,        a_x[jc] += a_x_local[jc];
12698,        a_z[jc] += a_z_local[jc];
12699,    } 
12700,    free(a_x_local);
12701,    free(a_z_local);
12702,} 
12703,#include <math.h>
12704,#include <stdlib.h>
12705,void main() {
12706,"    int ic, jc, N_TOTAL=50000;"
12707,    double *a_x;
12708,    a_x = (double*)malloc(N_TOTAL*sizeof(double));
12709,    for (jc = 0; jc < N_TOTAL ; jc++) a_x[jc] = 0.0;
12710,
12711,"    #pragma omp parallel private(ic,jc)"
12712,    { 
12713,        double *a_x_local;
12714,        a_x_local = (double*)malloc(N_TOTAL*sizeof(double));
12715,
12716,        #pragma omp parallel for 
12717,        for(ic = 0; ic < (N_TOTAL-1); ic++) {
12718,            for (jc = ic+1; jc < N_TOTAL; jc++) { 
12719,                a_x_local[jc] = sqrt((double)(ic+jc));
12720,                #pragma omp atomic
12721,                a_x[jc] += a_x_local[jc];
12722,            }
12723,        }
12724,        free(a_x_local);
12725,    } /* end parallel */
12726,} /* end main */
12727,#include <math.h>
12728,#include <stdlib.h>
12729,void main() {
12730,"    int ic, jc, N_TOTAL=50000;"
12731,    double *a_x;
12732,    a_x = (double*)malloc(N_TOTAL*sizeof(double));
12733,    for (jc = 0; jc < N_TOTAL ; jc++) a_x[jc] = 0.0;
12734,
12735,"    #pragma omp parallel private(ic,jc)"
12736,    { 
12737,        double *a_x_local;
12738,        a_x_local = (double*)malloc(N_TOTAL*sizeof(double));
12739,
12740,        #pragma omp parallel for 
12741,        for(ic = 0; ic < (N_TOTAL-1); ic++) {
12742,            for (jc = ic+1; jc < N_TOTAL; jc++) { 
12743,                a_x_local[jc] = sqrt((double)(ic+jc));
12744,                #pragma omp atomic
12745,                a_x[jc] += a_x_local[jc];
12746,            }
12747,        }
12748,        free(a_x_local);
12749,    } /* end parallel */
12750,} /* end main */
12751,a_x_local
12752,a_z_local
12753,SignR
12754,rc_x
12755,LxScaled
12756,rc_x
12757,uVal
12758,uVal
12759,scanf
12760,%s
12761,char *
12762,&a
12763,a
12764,"scanf(""%s"", a);"
12765,a
12766,&a[0]
12767,char *
12768,%s
12769,&a
12770,char (*)[21]
12771,&a
12772,a
12773,&a[0]
12774,"printf(""%s"", a);"
12775,&a
12776,&a[0]
12777,#include <stdio.h>
12778,#define test __asm{\
12779,__asm jmp $+5\
12780,}
12781,
12782,#define test1 __asm{\
12783,__asm _emit 0xeb\
12784,__asm _emit 0xff\
12785,__asm _emit 0xc0\
12786,__asm _emit 0x48\
12787,}
12788,
12789,int main()
12790,{
12791,    test1;
12792,}
12793,\n
12794,__asm _emit 0xeb__asm _emit...
12795,__asm{}
12796,asm
12797,__asm
12798,__asm
12799,__asm _emit 0xeb__asm _emit 0xff
12800,0xeb__asm
12801,0xeb \
12802,#include <stdio.h>
12803,#define N 3
12804, 
12805,"int solveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[], int yMove[], int numJog);"
12806, 
12807,"int isSafe(int x, int y, int sol[N][N])"
12808,{
12809,    return (x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);
12810,}
12811, 
12812,void printSolution(int sol[N][N])
12813,{
12814,    for (int x = 0; x < N; x++) {
12815,        for (int y = 0; y < N; y++)
12816,"            printf("" %2d "", sol[x][y]);"
12817,"        printf(""\n"");"
12818,    }
12819,}
12820, 
12821,void solveKT()
12822,{
12823,    int sol[N][N];
12824, 
12825,    /* Initialization of solution matrix */
12826,    for (int x = 0; x < N; x++)
12827,        for (int y = 0; y < N; y++)
12828,            sol[x][y] = -1;
12829, 
12830,    sol[0][0] = 0; // Since the Knight is initially at the first block
12831, 
12832,    /* xMove[] and yMove[] define next move of Knight. */
12833,"    int xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };"
12834,"    int yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };"
12835,     
12836,"    /* Start from 0,0 and explore all tours using solveKTUtil() */"
12837,"    printf(""Numbers of Attempts %d\n"" , solveKTUtil(0, 0, 1, sol, xMove, yMove, 0));"
12838,    printSolution(sol);            
12839, 
12840,}
12841, 
12842,/* A recursive utility function to solve Knight Tour problem */
12843,"int solveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N], int plays)"
12844,{
12845,    int play = 0;
12846,    if (movei == N * N) 
12847,        return 1;
12848, 
12849,    for (int k = 0; k < 8; k++) {
12850,        int next_x = x + xMove[k];
12851,        int next_y = y + yMove[k];
12852,"        if (isSafe(next_x, next_y, sol)) "
12853,        {
12854,            plays = plays +1;
12855,"            printf(""%d"", plays);"
12856,"            printf(""\n"");"
12857,            play = plays + 1;
12858,            sol[next_x][next_y] = movei;
12859,"            if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove, plays) == 1)"
12860,                return play;
12861,            else
12862,                sol[next_x][next_y] = -1; // backtracking
12863,        }
12864,    }
12865,    
12866,    // return 0;
12867,}
12868, 
12869,void main()
12870,{
12871,    solveKT();    
12872,}
12873,"if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove, plays) == 1)"
12874, > 0
12875,play
12876,movei
12877,N*N
12878,movei
12879,#include <stdio.h>
12880,    #define N 3
12881,     
12882,"    int solveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[], int yMove[], int numJog);"
12883,     
12884,"    int isSafe(int x, int y, int sol[N][N])"
12885,    {
12886,        return (x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);
12887,    }
12888,     
12889,    void printSolution(int sol[N][N])
12890,    {
12891,        for (int x = 0; x < N; x++) {
12892,            for (int y = 0; y < N; y++)
12893,"                printf("" %2d "", sol[x][y]);"
12894,"            printf(""\n"");"
12895,        }
12896,    }
12897,     
12898,    void solveKT()
12899,    {
12900,        int sol[N][N];
12901,     
12902,        /* Initialization of solution matrix */
12903,        for (int x = 0; x < N; x++)
12904,            for (int y = 0; y < N; y++)
12905,                sol[x][y] = -1;
12906,     
12907,        sol[0][0] = 0; // Since the Knight is initially at the first block
12908,     
12909,        /* xMove[] and yMove[] define next move of Knight. */
12910,"        int xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };"
12911,"        int yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };"
12912,         
12913,"        /* Start from 0,0 and explore all tours using solveKTUtil() */"
12914,"        printf(""Numbers of Attempts %d\n"" , solveKTUtil(0, 0, 1, sol, xMove, yMove, 0));"
12915,        printSolution(sol);            
12916,     
12917,    }
12918,     
12919,    /* A recursive utility function to solve Knight Tour problem */
12920,"    int solveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N], int plays)"
12921,    {
12922,        int play = 1;
12923,        if (movei == N * N) 
12924,            return movei;
12925,     
12926,        for (int k = 0; k < 8; k++) {
12927,            int next_x = x + xMove[k];
12928,            int next_y = y + yMove[k];
12929,"            if (isSafe(next_x, next_y, sol)) "
12930,            {
12931,                
12932,                sol[next_x][next_y] = movei;
12933,"                play = solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove, plays + 1) + 1;"
12934,                sol[next_x][next_y] = -1; // backtracking
12935,                
12936,            }
12937,        }
12938,    
12939,        return play;
12940,    }
12941,     
12942,    void main()
12943,    {
12944,        solveKT();    
12945,    }
12946,play
12947,#include <stdio.h>
12948,int main(){
12949,static int a = 9;
12950,if (a--){
12951,"   printf(""after decrement a =%d\n"", a);"
12952,   main();
12953,   }
12954,  return 0;
12955,}
12956,after decrement a =8
12957,after decrement a =7
12958,after decrement a =6
12959,after decrement a =5
12960,after decrement a =4
12961,after decrement a =3
12962,after decrement a =2
12963,after decrement a =1
12964,after decrement a =0
12965,a=0
12966,if(--a)
12967,after decrement a =8
12968,after decrement a =7
12969,after decrement a =6
12970,after decrement a =5
12971,after decrement a =4
12972,after decrement a =3
12973,after decrement a =2
12974,after decrement a =1
12975,a=1
12976,if(a--)
12977,0
12978,if(--a)
12979,1
12980,8
12981,9
12982,main
12983,main
12984,--
12985,++
12986,a=1
12987,a=0
12988,a
12989,static
12990,--a
12991,--
12992,a--
12993,a
12994,int a = 5;
12995,"printf(""%d\n"", --a); //Prints 4"
12996,"printf(""%d\n"", a--); //Prints 4"
12997,"printf(""%d\n"", a); //Prints 3"
12998,if( )
12999,printf( )
13000,"char sendline[MAXLINE + 1], recvline[MAXLINE + 1];"
13001,char* ptr;
13002,
13003,size_t n;
13004,
13005,/// Form request
13006,"snprintf(sendline, MAXSUB, "
13007,"     ""GET %s HTTP/1.0\r\n""  // POST or GET, both tested and works. Both HTTP 1.0 HTTP 1.1 works, but sometimes "
13008,"     ""Host: %s\r\n""     // but sometimes HTTP 1.0 works better in localhost type"
13009,"     ""Content-type: application/x-www-form-urlencoded\r\n"""
13010,"     ""Content-length: %d\r\n\r\n"""
13011,"     ""%s\r\n"", page, host, (unsigned int)strlen(poststr), poststr);"
13012,
13013,/// Write the request
13014,"if (write(sockfd, sendline, strlen(sendline))>= 0) "
13015,{
13016,    /// Read the response
13017,"    while ((n = read(sockfd, recvline, MAXLINE)) > 0) "
13018,    {
13019,        recvline[n] = '\0';
13020,
13021,"        if(fputs(recvline, stdout) == EOF)"
13022,        {
13023,"            printf(""fputs() error\n"");"
13024,        }
13025,
13026,        /// Remove the trailing chars
13027,"        ptr = strstr(recvline, ""\r\n\r\n"");"
13028,
13029,        // check len for OutResponse here ?
13030,"        snprintf(OutResponse, MAXRESPONSE,""%s"", ptr);"
13031,    }          
13032,}
13033,#define _XOPEN_SOURCE 700
13034,#include <arpa/inet.h>
13035,#include <assert.h>
13036,#include <netdb.h> /* getprotobyname */
13037,#include <netinet/in.h>
13038,#include <stdbool.h>
13039,#include <stdio.h>
13040,#include <stdlib.h>
13041,#include <string.h>
13042,#include <sys/socket.h>
13043,#include <unistd.h>
13044,
13045,"int main(int argc, char** argv) {"
13046,    char buffer[BUFSIZ];
13047,    enum CONSTEXPR { MAX_REQUEST_LEN = 1024};
13048,    char request[MAX_REQUEST_LEN];
13049,"    char request_template[] = ""GET / HTTP/1.1\r\nHost: %s\r\n\r\n"";"
13050,    struct protoent *protoent;
13051,"    char *hostname = ""example.com"";"
13052,    in_addr_t in_addr;
13053,    int request_len;
13054,    int socket_file_descriptor;
13055,"    ssize_t nbytes_total, nbytes_last;"
13056,    struct hostent *hostent;
13057,    struct sockaddr_in sockaddr_in;
13058,    unsigned short server_port = 80;
13059,
13060,    if (argc > 1)
13061,        hostname = argv[1];
13062,    if (argc > 2)
13063,"        server_port = strtoul(argv[2], NULL, 10);"
13064,
13065,"    request_len = snprintf(request, MAX_REQUEST_LEN, request_template, hostname);"
13066,    if (request_len >= MAX_REQUEST_LEN) {
13067,"        fprintf(stderr, ""request length large: %d\n"", request_len);"
13068,        exit(EXIT_FAILURE);
13069,    }
13070,
13071,    /* Build the socket. */
13072,"    protoent = getprotobyname(""tcp"");"
13073,    if (protoent == NULL) {
13074,"        perror(""getprotobyname"");"
13075,        exit(EXIT_FAILURE);
13076,    }
13077,"    socket_file_descriptor = socket(AF_INET, SOCK_STREAM, protoent->p_proto);"
13078,    if (socket_file_descriptor == -1) {
13079,"        perror(""socket"");"
13080,        exit(EXIT_FAILURE);
13081,    }
13082,
13083,    /* Build the address. */
13084,    hostent = gethostbyname(hostname);
13085,    if (hostent == NULL) {
13086,"        fprintf(stderr, ""error: gethostbyname(\""%s\"")\n"", hostname);"
13087,        exit(EXIT_FAILURE);
13088,    }
13089,    in_addr = inet_addr(inet_ntoa(*(struct in_addr*)*(hostent->h_addr_list)));
13090,    if (in_addr == (in_addr_t)-1) {
13091,"        fprintf(stderr, ""error: inet_addr(\""%s\"")\n"", *(hostent->h_addr_list));"
13092,        exit(EXIT_FAILURE);
13093,    }
13094,    sockaddr_in.sin_addr.s_addr = in_addr;
13095,    sockaddr_in.sin_family = AF_INET;
13096,    sockaddr_in.sin_port = htons(server_port);
13097,
13098,    /* Actually connect. */
13099,"    if (connect(socket_file_descriptor, (struct sockaddr*)&sockaddr_in, sizeof(sockaddr_in)) == -1) {"
13100,"        perror(""connect"");"
13101,        exit(EXIT_FAILURE);
13102,    }
13103,
13104,    /* Send HTTP request. */
13105,    nbytes_total = 0;
13106,    while (nbytes_total < request_len) {
13107,"        nbytes_last = write(socket_file_descriptor, request + nbytes_total, request_len - nbytes_total);"
13108,        if (nbytes_last == -1) {
13109,"            perror(""write"");"
13110,            exit(EXIT_FAILURE);
13111,        }
13112,        nbytes_total += nbytes_last;
13113,    }
13114,
13115,    /* Read the response. */
13116,"    fprintf(stderr, ""debug: before first read\n"");"
13117,"    while ((nbytes_total = read(socket_file_descriptor, buffer, BUFSIZ)) > 0) {"
13118,"        fprintf(stderr, ""debug: after a read\n"");"
13119,"        write(STDOUT_FILENO, buffer, nbytes_total);"
13120,    }
13121,"    fprintf(stderr, ""debug: after last read\n"");"
13122,    if (nbytes_total == -1) {
13123,"        perror(""read"");"
13124,        exit(EXIT_FAILURE);
13125,    }
13126,
13127,    close(socket_file_descriptor);
13128,    exit(EXIT_SUCCESS);
13129,}
13130,gcc -ggdb3 -std=c99 -Wall -Wextra -o wget wget.c
13131,./wget example.com
13132,debug: before first read
13133,debug: after a read
13134,HTTP/1.1 200 OK
13135,Age: 540354
13136,Cache-Control: max-age=604800
13137,Content-Type: text/html; charset=UTF-8
13138,"Date: Tue, 02 Feb 2021 15:21:14 GMT"
13139,"Etag: ""3147526947+ident"""
13140,"Expires: Tue, 09 Feb 2021 15:21:14 GMT"
13141,"Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT"
13142,Server: ECS (nyb/1D11)
13143,Vary: Accept-Encoding
13144,X-Cache: HIT
13145,Content-Length: 1256
13146,
13147,<!doctype html>
13148,<html>
13149,...
13150,</html>
13151,Content-Length
13152,Connection: close
13153,"char request_template[] = ""GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n"";"
13154,host example.com
13155,example.com has address 93.184.216.34
13156,example.com has IPv6 address 2606:2800:220:1:248:1893:25c8:1946
13157,./wget 93.184.216.34
13158,Host:
13159,"read(socket_file_descriptor, buffer, BUFSIZ)"
13160,Content-Length:
13161,Connection: close
13162,#include <windows.h>
13163,#include <string>
13164,#include <stdio.h>
13165,#include <winsock2.h>
13166,
13167,using std::string;
13168,
13169,SOCKET conn;
13170,WSADATA wsaData;
13171,struct hostent *hp;
13172,unsigned int addr;
13173,struct sockaddr_in server;
13174,long fileSize;
13175,const int bufSize = 512;
13176,"char readBuffer[bufSize], sendBuffer[bufSize], tmpBuffer[bufSize];"
13177,char *memBuffer=NULL;
13178,char *headerBuffer=NULL;
13179,"long totalBytesRead, thisReadSize, headerLen;"
13180,"char *tmpResult=NULL, *result;"
13181,
13182,"char* antenna(string host,string path);"
13183,"SOCKET connectToServer(char *szServerName, WORD portNum);"
13184,int getHeaderLength(char *content);
13185,
13186,
13187,int main(){  
13188,  
13189,"    if(WSAStartup(0x101, &wsaData) != 0){printf(""startup failure"");}"
13190,"    memBuffer = antenna(""www.spreadsheets.google.com"", ""/feeds/list/{Published_Sheet_ID-1}/1/public/values?alt=json"");"
13191,"    printf(""Response content:\n%s\n\n"", memBuffer);"
13192,
13193,"    memBuffer = antenna(""www.spreadsheets.google.com"", ""/feeds/list/{Published_Sheet_ID-2}/1/public/values?alt=json"");"
13194,"    printf(""Response content:\n%s"", memBuffer);"
13195,
13196,    WSACleanup();
13197,}
13198,
13199,
13200,"char *antenna(string host, string path){"
13201,
13202,    fileSize=0;
13203,    totalBytesRead=0;
13204,    memBuffer=NULL;
13205,    headerBuffer=NULL;
13206,"    tmpResult=NULL,"
13207,
13208,"    conn = connectToServer((char*)host.c_str(), 80);"
13209,"    if(conn == 0){printf(""No Internet connection"");}"
13210,
13211,"    sprintf(sendBuffer, ""GET %s HTTP/1.0 \r\nHost: %s\r\nConnection: close\r\n\r\n"", path.c_str(),host.c_str());"
13212,"    send(conn, sendBuffer, strlen(sendBuffer), 0);"
13213,"    printf(""Request Format: \n%s"",sendBuffer);"
13214,    while(1){
13215,
13216,"        memset(readBuffer, 0, bufSize);"
13217,"        thisReadSize = recv (conn, readBuffer, bufSize, 0);"
13218,
13219,        if ( thisReadSize <= 0 ){break;}
13220,
13221,"        tmpResult = (char*)realloc(tmpResult, thisReadSize+totalBytesRead);"
13222,
13223,"        memcpy(tmpResult+totalBytesRead, readBuffer, thisReadSize);"
13224,        totalBytesRead += thisReadSize;
13225,    }
13226,
13227,    headerLen = getHeaderLength(tmpResult);
13228,    long contenLen = totalBytesRead-headerLen;
13229,    result = new char[contenLen+1];
13230,"    memcpy(result, tmpResult+headerLen, contenLen);"
13231,    result[contenLen] = 0x0;
13232,    char *myTmp;
13233,    myTmp = new char[headerLen+1];
13234,"    strncpy(myTmp, tmpResult, headerLen);"
13235,    myTmp[headerLen] = 0;
13236,    delete(tmpResult);
13237,    headerBuffer = myTmp;
13238,
13239,"    printf(""Response Header: \n%s"",headerBuffer);"
13240,    fileSize = contenLen;
13241,    closesocket(conn);
13242,
13243,    if(fileSize != 0){
13244,
13245,        delete(memBuffer);
13246,        delete(headerBuffer);
13247,    }
13248,    return(result);
13249,}
13250,
13251,"SOCKET connectToServer(char *szServerName, WORD portNum)"
13252,{
13253,"    conn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);"
13254,    if (conn == INVALID_SOCKET){return 0;}
13255,    if(inet_addr(szServerName)==INADDR_NONE){hp=gethostbyname(szServerName);}
13256,    else{
13257,        addr=inet_addr(szServerName);
13258,"        hp=gethostbyaddr((char*)&addr,sizeof(addr),AF_INET);"
13259,    }
13260,
13261,    if(hp==NULL){closesocket(conn);return 0;}
13262,
13263,    server.sin_addr.s_addr=*((unsigned long*)hp->h_addr);
13264,    server.sin_family=AF_INET;
13265,    server.sin_port=htons(portNum);
13266,"    if(connect(conn,(struct sockaddr*)&server,sizeof(server)))"
13267,    {
13268,        closesocket(conn);
13269,        return 0;
13270,    }
13271,    return conn;
13272,}
13273,
13274,int getHeaderLength(char *content)
13275,{
13276,"    const char *srchStr1 = ""\r\n\r\n"", *srchStr2 = ""\n\r\n\r"";"
13277,    char *findPos;
13278,    int ofset = -1;
13279,
13280,"    findPos = strstr(content, srchStr1);"
13281,    if (findPos != NULL)
13282,    {
13283,        ofset = findPos - content;
13284,        ofset += strlen(srchStr1);
13285,    }
13286,
13287,    else
13288,    {
13289,"        findPos = strstr(content, srchStr2);"
13290,        if (findPos != NULL)
13291,        {
13292,            ofset = findPos - content;
13293,            ofset += strlen(srchStr2);
13294,        }
13295,    }
13296,    return ofset;
13297,}
13298,g++ -static test.cpp -o test.exe -lws2_32
13299,#include <stdio.h>
13300,#include <stdlib.h>
13301,
13302,int main(void)
13303,{
13304,"    printf(""Hello Eclipse\n"");"
13305,    return 0; 
13306,}
13307,"x = np.array([1, 2, 3])"
13308,"y = np.array([1, 2, 3])"
13309,print(x + y)
13310,numpy/core/src/XXX/
13311,core/src/umath/loops.c.src
13312,PyArray_XXX
13313,array_XXX
13314,PyArray_XXX
13315,@TYPE@_add@isa@
13316,@TYPE@
13317,INT
13318,LONG
13319,_add
13320,begin repeat
13321,add
13322,kind
13323,@isa@
13324,core/src/umath/loops.c.src
13325,long long
13326,long long int
13327,unsigned long long int
13328,long long
13329,int
13330,long long
13331,// Program to reverse the number
13332,#include <stdio.h>
13333,#include <math.h>
13334,int main()
13335,{
13336,"    int num, rev_num, a, temp,i;"
13337,"    printf(""\nEnter the number to be reveresed: "");"
13338,"    scanf(""%d"", &num);"
13339,    a = 0;
13340,    for (i = 4; i > (-1); i--)
13341,    {
13342,        temp = num % 10;
13343,        num = (num - temp) / 10;
13344,"        a = a + temp * pow(10, i);"
13345,    }
13346,"    printf(""\nThe reverse number is: %d"",a);"
13347,
13348,    return 0;
13349,}
13350,%05d
13351,printf( )
13352,*10
13353,+1
13354,a
13355,*10
13356,+1
13357,pow()
13358,a
13359,a = a*10 + temp;
13360,a
13361, temp
13362,/
13363,num = num / 10;
13364,a
13365,round()
13366,"int main(char argc, char **argv)"
13367,if( argc > 2 ) ...
13368,main
13369,"int main(char argc, char **argv)"
13370,char
13371,int
13372,"char c; printf(""%i"", c)"
13373,"int main(char argc, char **argv)"
13374,int
13375,char **argv[]
13376,char *argv[]
13377,char **argv
13378,char argc
13379,int argc
13380,main()
13381,char argc
13382,"... main(char argc, ...)"
13383,"... main(char argc, ...)"
13384,argv
13385,argc
13386,argc
13387,argc
13388,int
13389,"... main(char argc, ...)"
13390,"... main(char argc, ...)"
13391,void make_crc_table( void ) {       
13392,"    int i, j;       "
13393,"    unsigned long poly, c;  "
13394,
13395,    poly = 0x03;    // X^6 + x + 1
13396,        
13397,    for ( i = 0; i < 256; i++ ) {       
13398,        c = i >> 2;     
13399,        for ( j = 0; j < 8; j++ ) {     
13400,            c = ( c & 0x20 ) ? poly ^ ( c << 1 ) : ( c << 1 );      
13401,        }       
13402,        crctable[i] = (uint8_t) c;      
13403,    }       
13404,}   
13405,>> 2
13406,c = c & 0x80 ? (c << 1) ^ (poly << 2) : c << 1;
13407,crctable[i] = (c >> 2) & 0x3f;
13408,unsigned long
13409,unsigned
13410,#include<stdio.h>
13411,#include<string.h>
13412,
13413,int main()
13414,{
13415,"    char str[5] = ""World"";"
13416,"    char str1[] = ""hello"";"
13417,"    char str2[] = {'N','a','m','a','s','t','e'};"
13418,"    char* str3 = ""Hi"";"
13419,
13420,"    printf(""%s %zu\n"""
13421,"           ""%s %zu\n"""
13422,"           ""%s %zu\n"""
13423,"           ""%s %zu\n"","
13424,"           str, strlen(str),"
13425,"           str1, strlen(str1),"
13426,"           str2, strlen(str2),"
13427,"           str3, strlen(str3));"
13428,
13429,    return 0;
13430,}
13431,Worldhello 10
13432,hello 5
13433,Namaste 7
13434,Hi 2
13435,str
13436,Worldhello
13437,str2
13438,Namastehello
13439,"""World"""
13440,strlen
13441,size_t
13442,%zu
13443,str
13444,str2
13445,printf()
13446,strlen()
13447,printf()
13448,%s
13449,%.*s
13450,int
13451,size_t
13452,'\0'
13453,0
13454,strcpy()
13455,memcpy()
13456,strcpy()
13457,"char *s = ""Hello World"";"
13458,for (int i = 0; str[i]; i++) { /* do something with each char */ }
13459,"char str[5]=""World"";"
13460,"""World"""
13461,"char str1[]=""hello"";"
13462,"str2[]={'N','a','m','a','s','t','e'};"
13463,printf
13464,str
13465,str2
13466,#include <stdio.h>
13467,#include <string.h>
13468,
13469,int main(void)
13470,{
13471,"    char str[6] = ""World""; // 5 letters plus a null character."
13472,"    char str1[] = ""hello"";"
13473,"    char str2[] = {'N', 'a', 'm', 'a', 's', 't', 'e',  0}; // Include a null."
13474,"    char *str3 = ""Hi"";"
13475,"    printf(""%s %zu\n%s %zu\n%s %zu\n%s %zu\n"","
13476,"        str,  strlen(str),"
13477,"        str1, strlen(str1),"
13478,"        str2, strlen(str2),"
13479,"        str3, strlen(str3));"
13480,    return 0;
13481,}
13482,Worldhello 10
13483,hello 5
13484,World 5
13485,hello 5
13486,printf()
13487,'\0'
13488,hello
13489,World
13490,str
13491,5
13492,str[5]
13493,hello
13494,World
13495,printf()
13496,World
13497,hello
13498,Worldhello
13499,hello
13500,strlen
13501,strlen
13502,printf
13503,printf
13504,printf
13505,int3
13506,nexti
13507,"Sending packet: $Me1dc20,1:cc#6c...Ack"
13508,Timed out.
13509,Timed out.
13510,Timed out.
13511,"Ignoring packet error, continuing..."
13512,cc
13513,int3
13514,0xe1dc20
13515,(gdb) x/16i 0xe1dc20
13516,   0xe1dc20 <_Unwind_DebugHook>: retq   
13517,"   0xe1dc21:    data16 nopw %cs:0x0(%rax,%rax,1)"
13518,   0xe1dc2c:    nopl   0x0(%rax)
13519,$M
13520,$X
13521,nexti
13522,step
13523,RFLAGS.TF
13524,stepi
13525,nexti
13526,step
13527,nexti
13528,stepi
13529,stepi
13530,TF
13531,IF
13532,int3
13533,e1dc50
13534,0xe1dc20  _Unwind_DebugHook
13535,TF
13536,0xe1dc20
13537,stepi
13538,stepi
13539,TF
13540,nexti
13541,call
13542,si
13543,si
13544,set range-stepping off
13545,_Unwind_DebugHook
13546,stepi
13547,stepi
13548,_Unwind_DebugHook
13549,stepi
13550,"(gdb) stepi Sending packet: $me11a00,40#85...Ack Sending packet: $vCont?#49...Ack Sending packet: $Hc0#db...Ack Sending packet: $s#73...Ack Sending packet: $g#67...Ack Sending packet: $m141248c0,40#c4...Ack Sending packet: $me11a00,40#85...Ack Sending packet: $qL1200000000000000000#50...Ack  "
13551,int *minus = malloc(4);    // minus: 0x6a1590
13552,"char *str = malloc(2);    // str : 0x6a15d0 ""\300>������������������������������"""
13553,int *minus = malloc(sizeof(int));
13554,ints
13555,malloc()
13556,calloc()
13557,memset()
13558,int *minus = malloc( sizeof *minus );
13559,:-)
13560,str
13561,int *
13562,char *
13563,char *
13564,malloc
13565,char *
13566,int *
13567,int *
13568,str
13569,char*
13570,char *str = malloc(2); 
13571,*str = ' '; /* set the first byte to be a blank space character */
13572,*(str+1) = '\0'; /* set the second byte to be null */
13573,char *
13574,char *
13575,char *
13576,char
13577,NULL
13578,''
13579,*str = '';
13580,""""""
13581,malloc
13582,calloc
13583,"char *str = calloc( 2, sizeof *str );"
13584,printf
13585,%s
13586,puts
13587,#include <string.h>
13588,#include <stdlib.h>
13589,
13590,"void my_square(int *x, int *y)"
13591,{
13592,"    int i , j;"
13593,    if (*x == 0 || *y == 0) {
13594,"        printf("""");"
13595,    }
13596,    else{
13597,        for(i = 0; i < *x; i++){
13598,            for(j = 0; j < *y; j++){
13599,                if(*x<=2 && j == 0){
13600,"                    printf(""o"");"
13601,                }else if(*x<=2 && j == 1){
13602,"                    printf(""o\n"");"
13603,                }else if(*y<=2 && i == 0){
13604,"                    printf(""o"");"
13605,                }else if(*y<=2 && i == 1){
13606,"                    printf(""o\n"");"
13607,                }else{
13608,"                    //printf("" i: %d, j: %d "", i, j);"
13609,                    if(i == 0 && j == 0 || i == *y-1 && j == 0 || i == 0 && j == *x-1 || i == *y-1 && j == *x-1){
13610,"                        printf(""o"");"
13611,                    } 
13612,                    
13613,                    if(i >= 1 && j == 0 && i != *y-1) {
13614,"                        printf(""|"");"
13615,                    }
13616,                    if(i >= 1 && j == *x-1 && i != *y-1) {
13617,"                        printf(""|"");"
13618,                    }
13619,                    if(i == 0 && j >= 1 && j != *y-1|| i == *x-1 && j >= 1 && j != *y-1){
13620,"                        printf(""-"");"
13621,                    }
13622,                    if(i >= 1 && j >= 1 && i < *x-1 && j < *y-1){
13623,"                        printf("" "");"
13624,                    }
13625,                    if(j == *x-1){
13626,"                        printf(""\n"");"
13627,                    }
13628,                
13629,                }
13630,"            //printf(""> %d, %d"", i, j);"
13631,            }
13632,        }
13633,    }
13634,}
13635,
13636,"int main(int ac, char **av)"
13637,{
13638,    int x = atoi(av[1]);
13639,    int y = atoi(av[2]);
13640,"    my_square(&x, &y);"
13641,    return 0;
13642,}```
13643,av[2]
13644,ac
13645,#include <stdio.h>
13646,ac
13647,av
13648,"int main(int ac, char **av)"
13649,{
13650,"    int x, y;"
13651,    if (ac <= 3)
13652,    {
13653,        x = atoi(av[1]);
13654,"        y = x; // if there's only one argument, we use it for both x and y"
13655,
13656,        if (ac == 3)
13657,        {
13658,            y = atoi(av[2]);
13659,        }
13660,        
13661,"        my_square(&x, &y);"
13662,    }
13663,
13664,    return 0;
13665,}
13666,"int isSpecialCharacter(char str[], int n)"
13667,{
13668,    for(int i=0; i<n;i++)
13669,    {
13670,        if (str[i] == '!' || str[i] == '@' || str[i] == '#' || str[i] == '$' || str[i] == '%' || str[i] == '^' || str[i] == '(' || str[i] == ')')
13671,        {
13672,            return 1;
13673,        } 
13674,        return 0;
13675,    }
13676,}
13677,#include <stdio.h>
13678,#include <string.h>
13679,
13680,char str[30][30];
13681,char test[100];
13682,int myindex = 0;
13683,
13684,"int isSpecialCharacter(char str[], int n)"
13685,{
13686,    for(int i=0; i<n;i++)
13687,    {
13688,        if (str[i] == 33 || str[i] == 35 || str[i] == 36 || str[i] == 37 || str[i] == 40 || str[i] == 41 || str[i] == 64)
13689,        {
13690,            return 1;
13691,        } 
13692,        return 0;
13693,    }
13694,}
13695,
13696,int main()
13697,{
13698,"    printf(""Please enter 10 strings below: \n"");"
13699,    while(myindex < 10)
13700,    {
13701,"        printf(""Enter string %d: "", myindex+1);"
13702,"        fgets(str[myindex], 500, stdin);"
13703,"        strcpy(test, str[myindex]);"
13704,        int t_size = strlen(test);
13705,
13706,        if (strlen(str[myindex])<2||strlen(str[myindex])>26)
13707,        {
13708,"            printf(""Enter string that is between 2 and 25"");"
13709,            continue;
13710,
13711,        }
13712,"        else if(isSpecialCharacter(test, t_size) == 1)"
13713,        {
13714,"            printf(""Your string has some special characters. \n"");"
13715,            continue;
13716,        }
13717,        else
13718,        {
13719,            myindex++;
13720,        }
13721,    }
13722,    return 0;
13723,}
13724,return 0;
13725,for
13726,return 0
13727,"int isSpecialCharacter(char str[], int n)"
13728,{
13729,    for (int i = 0; i < n; i++)
13730,    {
13731,        if (str[i] == 33 || str[i] == 35 || str[i] == 36 || str[i] == 37 || str[i] == 40 || str[i] == 41 || str[i] == 64)
13732,        {
13733,            return 1;
13734,        }
13735,    }
13736,    return 0;
13737,}
13738,test1
13739,test2
13740,test)
13741,test(
13742,test3
13743,test4
13744,test5
13745,test@
13746,test6
13747,test7
13748,test!
13749,test8
13750,test9
13751,test10
13752,'@'
13753,return 0;
13754,"int isSpecialCharacter(char str[], int n) {"
13755,    for(int i=0; i<n;i++)
13756,    {
13757,        if (str[i] == '!' || str[i] == '@' || str[i] == '#' || str[i] == '$' || str[i] == '%' || str[i] == '^' || str[i] == '(' || str[i] == ')')
13758,        {
13759,            return 1;
13760,        } 
13761,        return 0;
13762,    } 
13763,} 
13764,1
13765,0
13766,0
13767,"int isSpecialCharacter(char str[], int n)"
13768,{
13769,    for(int i=0; i<n;i++)
13770,    {
13771,        if (str[i] == '!' || str[i] == '@' || str[i] == '#' || str[i] == '$' || str[i] == '%' || str[i] == '^' || str[i] == '(' || str[i] == ')')
13772,        {
13773,            return 1;
13774,        } 
13775,    }
13776, 
13777,    return 0;
13778,}
13779,if( isSpecialCharacter()
13780,"if( strpbrk( test, ""abqmz"" ) != NULL )"
13781,"char spcl[] = ""!@#$%^()"";"
13782,
13783,"if( strpbrk( test, spcl ) != NULL ) {"
13784,    // Do something because condition is true
13785,\
13786,""""
13787,"char spcl[] = ""\\!@#$%^(\"")""; // notice '\\' and '\"""""
13788,"char spcl[] = { '\\', '!', '@', '#', '$', '%', '^', '(', '\""', ')' '\0' };"
13789,char str[30][30];
13790,
13791,/* Skipping ahead */
13792,
13793,"printf(""Enter string %d: "", myindex+1);"
13794,"fgets(str[myindex], 500, stdin); // 500!!! ????"
13795,/usr/include/float.h
13796,sunfire$ egcc -std=c11 prog.c
13797,prog.c: In function 'main':
13798,prog.c:5:17: error: 'FLT_DECIMAL_DIG' undeclared (first use in this function); did you mean 'DECIMAL_DIG'?
13799,"printf(""%d\n"", FLT_DECIMAL_DIG);"
13800,               ^~~~~~~~~~~~~~~
13801,               DECIMAL_DIG
13802,sunfire$ clang prog.c -std=c11                                                       
13803,prog.c:5:18: error: use of undeclared identifier 'FLT_DECIMAL_DIG'
13804,"        printf(""%d \n"", FLT_DECIMAL_DIG);"
13805,                        ^
13806,1 error generated.
13807,#include <stdio.h>
13808,#include <float.h>
13809,
13810,int main() {
13811,"        printf(""%d \n"", FLT_DECIMAL_DIG);"
13812,}
13813,9\n
13814,find / float.h
13815,PATH
13816,float.h
13817,/usr/local/lib/gcc/x86_64-unkown-openbsd7.1/8.4.0/include
13818,#include <stdio.h>
13819,
13820,"float walking (float start,float duration);"
13821,
13822,int main() {
13823,"  printf (""finish = %.2f"", walking(20.30, 1.40));"
13824,  return 0;
13825,}
13826,
13827,"float walking(float start, float duration) {"
13828,  int finMinuites = (int)(start * 100) % 100 + (int)(duration * 100) % 100;
13829,  int finHours = (start * 100) / 100 + (duration * 100) / 100;
13830,
13831,  if (finMinuites >= 60) {
13832,    finMinuites -= 60;
13833,    finHours++;
13834,  }
13835,
13836,  if (finHours >= 24)
13837,    finHours -= 24;
13838,
13839,    return finHours + finMinuites / 100;
13840,  }
13841,m/60
13842,m%60
13843,float
13844,12.30
13845,12:30
13846,"const char *str = ""12:30""; int sec; int h; int m; sscanf(str,""%d:%d"",&h,&m); sec = (h * 3600) + (m * 60);"
13847,return finHours + finMinuites/100
13848,return finHours + finMinuites/100.
13849,#include<stdio.h>
13850,#include<math.h>
13851,
13852,"float walking(float start,float duration);"
13853,int main() {
13854,"    printf(""finish = %.2f"",walking(20.30, 1.40));"
13855,    return 0;
13856,}
13857,int toMinutes(float time){
13858,    int t = (int)round((time*100));
13859,    int hours = t/100;
13860,    int min = t - hours * 100;
13861,    return hours*60+min;
13862,}
13863,float toFloat(int minutes){
13864,    int hours = minutes/60;
13865,    int min = minutes - hours * 60;
13866,    float t = hours * 100;
13867,    t += min;
13868,    t /= 100;
13869,    return t;
13870,}
13871,"float walking(float start,float duration){"
13872,    int mins = toMinutes(start) + toMinutes(duration);
13873,    int day = 24*60;
13874,    while(mins > day){
13875,        mins -= day;
13876,    }
13877,
13878,    return toFloat(mins);
13879,}
13880,float/double
13881,(int)(start * 100)
13882,(int)
13883,modf()
13884,double
13885,float
13886,double
13887,float
13888,double
13889,#include <math.h>
13890,
13891,double to_hours(double hours_dot_minutes) {
13892,  double h;
13893,"  double m = modf(hours_dot_minutes, &h) * 100.0;"
13894,  return h + m/60.0;
13895,}
13896,
13897,double reduce_to_a_day(double hours) {
13898,  const double hours_per_day = 24.0;
13899,"  hours = fmod(hours, hours_per_day);"
13900,  if (hours < 0.0) {
13901,    hours += hours_per_day;
13902,  }
13903,  return hours;
13904,}
13905,
13906,double to_hours_dot_minutes(double hours) {
13907,  double h;
13908,"  double m = modf(hours, &h) * 60.0;"
13909,  return h + m/100.0;
13910,}
13911,
13912,"double walking(double start, double duration) {"
13913,  double sum = to_hours(start) + to_hours(duration);
13914,  sum = reduce_to_a_day(sum);
13915,  return to_hours_dot_minutes(sum);
13916,}
13917,int
13918,(int)
13919,"double walking(double start, double duration) {"
13920,  int start_h = (int) start;
13921,  int duration_h = (int) duration;
13922,         
13923,  double sum = start_h + duration_h + 
13924,      ((start - start_h) + (duration - duration_h)) * 100.0 / 60.0;
13925,  while  (sum >= 24.0) sum -= 24.0;
13926,  int sum_h = (int) sum;
13927,  return sum_h + (sum - sum_h) * 60.0 / 100.0;
13928,}
13929,#include <stdio.h>
13930,#include <stdlib.h>
13931,
13932,"double walking( double bgn, double dur ) {"
13933,"    printf( ""Start = %5.2f  duration = %5.2f  "", bgn, dur );"
13934,    char str[32];
13935,
13936,"    sprintf( str, ""%.2f %.2f"", bgn, dur );"
13937,"    int res = 0, cnt = 1;"
13938,"    for( char *cp = str; ( cp = strtok( cp, "" ."" ) ) != NULL; cp = NULL )"
13939,"        res += atoi( cp ) * (cnt&1 ? 60 : 1), cnt++;"
13940,
13941,    return res/60%24 + ((res%60)*0.01);
13942,}
13943,
13944,int main() {
13945,    double pairs[][2] = {
13946,"        { 20.30,  1.40 },"
13947,"        {  1.47,  1.13 },"
13948,"        {  0.00,  1.13 },"
13949,"        {  0.00,  0.00 },"
13950,"        { 23.59,  0.01 },"
13951,"        { 12.00, 48.27 },"
13952,    };
13953,
13954,    for( int i = 0; i < sizeof pairs/sizeof pairs[0]; i++ )
13955,"        printf ( ""finish = %5.2f\n"", walking( pairs[i][0], pairs[i][1] ) );"
13956,
13957,    return 0;
13958,}
13959,Start = 20.30  duration =  1.40  finish = 22.10
13960,Start =  1.47  duration =  1.13  finish =  3.00
13961,Start =  0.00  duration =  1.13  finish =  1.13
13962,Start =  0.00  duration =  0.00  finish =  0.00
13963,Start = 23.59  duration =  0.01  finish =  0.00
13964,Start = 12.00  duration = 48.27  finish = 12.27
13965,Dr Who
13966,"sprintf( str, ""%.2f %.2f"", bgn, dur );"
13967,"int res = 0, cnt = 1, sgn = 1;"
13968,"for( char *cp = str; ( cp = strtok( cp, "" ."" ) ) != NULL; cp = NULL, cnt++ )"
13969,    res += atoi( cp )
13970,        * (cnt&1 ? 60 : 1)
13971,"        * sgn,"
13972,    sgn = *cp == '-' ? -1 : 1;
13973,
13974,/* then one additional test case */
13975,
13976,"    { 12.00, -2.30 },"
13977,
13978,/* Output of the single test case: */
13979,
13980,Start = 12.00  duration = -2.30  finish =  9.30
13981,duration < 0
13982,atoi(cp)
13983,sprintf()
13984,double
13985,floor(res/60.0)
13986,res/60
13987,:-)
13988,bgn
13989,dur
13990,:-)
13991,:-)
13992,cp = NULL
13993,cp = NULL
13994,strtok( )
13995,:-)
13996,:-)
13997,#include<stdio.h>
13998,#include<stdlib.h>
13999,"#include ""doubly.h"""
14000,
14001,struct Node* head; 
14002,struct Node* GetNewNode(int x) {
14003,    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
14004,    newNode->data = x;
14005,    newNode->prev = NULL;
14006,    newNode->next = NULL;
14007,    return newNode;
14008,}
14009,
14010,void InsertAtTail(int x) {
14011,    struct Node* temp = head;
14012,    struct Node* newNode = GetNewNode(x);
14013,    if(head == NULL) {
14014,        head = newNode;
14015,        return;
14016,    }
14017,    while(temp->next != NULL) temp = temp->next;
14018,    temp->next = newNode;
14019,    newNode->prev = temp;
14020,}
14021,
14022,void Print() {
14023,    struct Node* temp = head;
14024,"    printf(""Forward: "");"
14025,    while(temp != NULL) {
14026,"        printf(""%d "",temp->data);"
14027,        temp = temp->next;
14028,    }
14029,"    printf(""\n"");"
14030,}
14031,
14032,int main() {
14033,    InsertAtTail(2); Print();
14034,}
14035,struct Node  {
14036,    int data;
14037,    struct Node* next;
14038,    struct Node* prev;
14039,};
14040,"e-acsl-gcc.sh -E ""-Iinclude/"" doubly_linked.c -c"
14041,+ /root/.opam/default/bin/frama-c -remove-unused-specified-functions -machdep gcc_x86_64 -cpp-extra-args= -std=c99 -D_DEFAULT_SOURCE -D__NO_CTYPE -D__FC_MACHDEP_X86_64  -Iinclude/ -no-frama-c-stdlib doubly_linked.c -e-acsl -e-acsl-share=/root/.opam/default/bin/../share/frama-c/e-acsl -then-last -print -ocode a.out.frama.c
14042,[kernel] Parsing doubly_linked.c (with preprocessing)
14043,[kernel] /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h:171: Warning:
14044,  unnamed fields are a C11 extension (use -c11 to avoid this warning)
14045,[variadic] Warning: Unable to locate ACSL predicate valid_read_string which should be in the Frama-C LibC. Correct specifications can't be generated.
14046,[variadic] Warning: Unable to locate global __fc_stdout which should be in the Frama-C LibC. Correct specifications can't be generated.
14047,[e-acsl] beginning translation.
14048,[kernel] Parsing FRAMAC_SHARE/e-acsl/e_acsl.h (with preprocessing)
14049,"[e-acsl] translation done in project ""e-acsl""."
14050,+ gcc -std=c99 -m64 -g -O2 -fno-builtin -fno-merge-constants -Wall -Wno-long-long -Wno-attributes -Wno-nonnull -Wno-undef -Wno-unused -Wno-unused-function -Wno-unused-result -Wno-unused-value -Wno-unused-function -Wno-unused-variable -Wno-unused-but-set-variable -Wno-implicit-function-declaration -Wno-empty-body doubly_linked.c -o a.out
14051,doubly_linked.c:4:10: fatal error: doubly.h: No such file or directory
14052," #include ""doubly.h"""
14053,          ^~~~~~~~~~
14054,compilation terminated.
14055,"curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 11000);"
14056,#include <stdio.h>
14057,
14058,#include <curl/curl.h>
14059,
14060,  /* define this to switch off the use of ssh-agent in this program */
14061,#undef DISABLE_SSH_AGENT
14062,struct FtpFile {
14063,    const char* filename;
14064,    FILE* stream;
14065,};
14066,
14067,"static size_t my_fwrite(void* buffer, size_t size, size_t nmemb,"
14068,    void* stream)
14069,{
14070,    //return size;
14071,    struct FtpFile* out = (struct FtpFile*)stream;
14072,    if (!out->stream) {
14073,        /* open file for writing */
14074,"         fopen_s(&out->stream,out->filename, ""wb"");"
14075,        if (!out->stream)
14076,"            return -1; /* failure, cannot open file to write */"
14077,    }
14078,"    return fwrite(buffer, size, nmemb, out->stream);"
14079,}
14080,
14081,int main(void)
14082,{
14083,
14084,CURL* curl;
14085,    FILE* fp;
14086,    CURLcode res;
14087,
14088,"    char url[] = ""sftp://url"";"
14089,"    char outfilename[FILENAME_MAX] = ""temp.txt"";"
14090,    curl = curl_easy_init();
14091,    if (curl)
14092,    {
14093,"        fopen_s(&fp,outfilename, ""wb"");"
14094,"        curl_easy_setopt(curl, CURLOPT_URL, url);"
14095,"       curl_easy_setopt(curl, CURLOPT_USERNAME, ""username"");"
14096,"       curl_easy_setopt(curl, CURLOPT_PASSWORD, ""mypassword);"
14097,        
14098,"        //curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 11000);"
14099,"        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);"
14100,"        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);"
14101,"         curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);"
14102,        res = curl_easy_perform(curl);
14103,        if (res == CURLE_OK)
14104,"            printf(""Download Successfull\n"");"
14105,        else 
14106,"            printf(""ERROR: %s\n"", curl_easy_strerror(res));"
14107,        curl_easy_cleanup(curl);
14108,        fclose(fp);
14109,    }
14110,    return 0;
14111,cd winbuild
14112,
14113,"nmake /f Makefile.vc mode=dll WITH_SSH=dll WITH_SSH2=dll SSH2_PATH=""C:\MYlibs\libssh2\bin\dll\lib"""
14114,cd bin
14115,
14116,"cmake -G ""Visual Studio 16 2019"" .."
14117,
14118,cmake -A Win32 ..
14119,
14120,mkdir dll
14121,
14122,cmake --build .
14123,
14124,cmake -DCRYPTO_BACKEND=WinCNG -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=./dll --build .
14125,
14126,cmake --build . --target install
14127,"curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);"
14128,*   Trying ipaddress.
14129,* TCP_NODELAY set
14130,* Connected to <myurl> port <myportno>(#0)
14131,* Failure establishing ssh session
14132,* Closing connection 0
14133,ERROR: Failed initialization
14134,my_fwrite
14135,"curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);"
14136,"curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);"
14137,struct FtpFile* out = (struct FtpFile*)stream;
14138,nm
14139,n
14140,R
14141,r
14142,a
14143,the
14144,-
14145,-
14146,read-only
14147,r
14148,R
14149,static const int
14150,const int
14151,n
14152,int counts[256];
14153,struct {char charval; int count; }
14154,qsort()
14155,stdlib.h
14156,qsort
14157,#include <stdlib.h>
14158,#include <stdio.h>
14159,#include <stdbool.h>
14160,
14161,#define NCHARS 256
14162,
14163,"bool character_count(const char* str,"
14164,"             size_t* frequencies,"
14165,             size_t nfrequencies) {
14166,  if (NULL == frequencies)
14167,    return false;
14168,  if (nfrequencies < 256)
14169,    return false;
14170,  for (;*str != '\0'; str++) {
14171,    frequencies[*str]++;
14172,  }
14173,  return true;
14174,}
14175,
14176,typedef struct CharCount_tag {
14177,  char c;
14178,  size_t count;
14179,} CharCount_t;
14180,
14181,"int charcount_compare(const void* cc1, const void* cc2) {"
14182,  CharCount_t* c1 = (CharCount_t*)cc1;
14183,  CharCount_t* c2 = (CharCount_t*)cc2;
14184,  if (c1->count == c2->count)
14185,    return 0;
14186,  else if (c1->count > c2->count)
14187,    return -1;
14188,  else
14189,    return 1;
14190,}
14191,
14192,"int main (int argc, const char* argv[]) {"
14193,  if (argc > 1) {
14194,    size_t frequencies[NCHARS];
14195,    for (size_t i = 0; i < NCHARS; i++) {
14196,      frequencies[i] = 0;
14197,    }
14198,"    if (character_count(argv[1], frequencies, NCHARS)) {"
14199,      CharCount_t cc[NCHARS];
14200,      for (size_t i = 0; i < NCHARS; i++) {
14201,        cc[i].c = (char) i;
14202,        cc[i].count = frequencies[i];
14203,      }
14204,"      qsort(cc, NCHARS, sizeof(cc[0]), charcount_compare);"
14205,      for (size_t i = 0; i < NCHARS; i++) {
14206,"        printf(""%d (%c) %zu\n"", cc[i].c, cc[i].c, cc[i].count);"
14207,      }
14208,    }
14209,  }
14210,  return 0;
14211,}
14212,#include <stdio.h>
14213,#include <stdlib.h>
14214,
14215,char *ASCIItbl =
14216,"    ""NULSOHSTXETXEOTENQACKBELBS HT LF VT FF CR SO SI """
14217,"    ""DLEDC1DC2DC3DC4NAKSYNETBCANEM SUBESCFS GS RS US """
14218,"    ""SP  !  \""  #  $  %  &  '  (  )  *  +  ,  -  .  / """
14219,"    "" 0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ? """
14220,"    "" @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O """
14221,"    "" P  Q  R  S  T  U  V  W  X  Y  Z  [  \\  ]  ^  _ """
14222,"    "" `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o """
14223,"    "" p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~ DEL"";"
14224,
14225,"char *smpl = ""I wish I was\n\twhat I was\nwhen I wished I was\n\twhat I am now.\n"";"
14226,
14227,int main() {
14228,"    printf( ""%s\n"", smpl );"
14229,
14230,    int i;
14231,    size_t cnt[ 128 + 1 ]; // built for 7-bit ASCII
14232,
14233,"    memset( cnt, 0, sizeof cnt );"
14234,
14235,    int maxIND = 0; 
14236,    for( char *cp = smpl; *cp; cp++ ) { // count while tracking most frequent
14237,        cnt[ *cp ]++;
14238,        if( cnt[ maxIND ] < cnt[ *cp ] )
14239,            maxIND = cp - smpl;
14240,    }
14241,#if 1
14242,    // output most frequent while scanning for next most freq
14243,"    printf( ""Descending order of frequency:\n"" );"
14244,    int nxtInd = 128;
14245,    do {
14246,        nxtInd = 128;
14247,        for( i = 0; i < sizeof cnt/sizeof cnt[0]; i++ )
14248,            if( cnt[ i ] == cnt[ maxIND ] )
14249,"                printf( ""%4d %.3s\n"", cnt[ maxIND ], &ASCIItbl[ 3*i ] );"
14250,            else if( cnt[ i ] && cnt[ i ] < cnt[ maxIND ] && cnt[ i ] > cnt[ nxtInd ] )
14251,                nxtInd = i;
14252,    } while( ( maxIND = nxtInd ) != 128 );
14253,
14254,    // simple output of non-zero counts in ascending ASCII order
14255,"    printf( ""Ascending order of ASCII value:\n"" );"
14256,    for( i = 0; i < sizeof cnt/sizeof cnt[0] - 1; i++ )
14257,        if( cnt[ i ]  )
14258,"            printf( ""%4d %.3s\n"", cnt[ i ], &ASCIItbl[ 3*i ] );"
14259,#else
14260,    // Output side-by-side
14261,"    printf( ""frequency       ASCII seqn\n"" );"
14262,"    int idx = 0, nxtInd = 128;"
14263,    do {
14264,        nxtInd = 128;
14265,        for( i = 0; i < sizeof cnt/sizeof cnt[0]; i++ )
14266,            if( cnt[ i ] == cnt[ maxIND ] ) {
14267,"                printf( ""%4d %.3s"", cnt[ maxIND ], &ASCIItbl[ 3*i ] );"
14268,                while( !cnt[++idx] ) ;
14269,"                printf( ""\t%4d %.3s\n"", cnt[ idx ], &ASCIItbl[ 3*idx ] );"
14270,            } else if( cnt[ i ] && cnt[ i ] < cnt[ maxIND ] && cnt[ i ] > cnt[ nxtInd ] )
14271,                nxtInd = i;
14272,    } while( ( maxIND = nxtInd ) != 128 );
14273,#endif
14274,    return 0;
14275,}
14276,I wish I was
14277,        what I was
14278,when I wished I was
14279,        what I am now.
14280,
14281,Descending order of frequency:
14282,  12 SP
14283,   9  w
14284,   6  I
14285,   6  a
14286,   5  h
14287,   5  s
14288,   4 LF
14289,   2 HT
14290,   2  e
14291,   2  i
14292,   2  n
14293,   2  t
14294,   1  .
14295,   1  d
14296,   1  m
14297,   1  o
14298,Ascending order of ASCII value:
14299,   2 HT
14300,   4 LF
14301,  12 SP
14302,   1  .
14303,   6  I
14304,   6  a
14305,   1  d
14306,   2  e
14307,   5  h
14308,   2  i
14309,   1  m
14310,   2  n
14311,   1  o
14312,   5  s
14313,   2  t
14314,   9  w
14315,"void countchar(const char * str, int &charcount[256])"
14316,{
14317,    for (x = 0; x < strlen(str); c++)
14318,    {
14319,        if (isalpha(str[x])) // optional
14320,          charcount[(int)str[x])]++;
14321,    }
14322,}
14323,"void swap(int* f, int* l)"
14324,{
14325,    int temp = *f;
14326,    *f = *l;
14327,    *l = temp;
14328,}
14329,
14330,void sortcount(int &charcount[256])
14331,{
14332,"    int i, j, min_idx;"
14333,    for (i = 0; i < 256; i++) {
14334,        min_idx = i;
14335,        for (j = i + 1; j < 256; j++)
14336,            if (charcount[j] < charcount[min_idx])
14337,                min_idx = j;
14338,"        swap(&charcount[min_idx], &charcount[i]);"
14339,    }
14340,}
14341,&
14342,#if OS == Linux
14343,  /* Linux-specific instructions */
14344,  ...
14345,#else
14346,  #if OS == Darwin
14347,    /* Mac OSX-specific instructions */
14348,    ...
14349,  #else
14350,    /* Program code for other OS */
14351,    ...
14352,  #endif
14353,#endif
14354,#define OS Linux;
14355,OS
14356,OS
14357,OS
14358,gcc
14359,clang
14360,-D
14361,gcc -DOS=Linux
14362,OS
14363,Linux
14364,#if OS == Linux
14365,OS
14366,Linux
14367,#if
14368,==
14369,#if OS == Linux
14370,Linux
14371,OS
14372,operating_systems.h
14373,#define Linux 1
14374,#define Darwin 2
14375,#define Windows 3
14376,#define OS 1
14377,#define OS (7 - 6)
14378,#define OS Linux
14379,#if OS == Linux
14380,Linux
14381,Darwin
14382,OS
14383,Linux
14384,Darwin
14385,OS == Linux
14386,OS == Darwin
14387,__linux__
14388,__APPLE__
14389,cpp -dM /dev/null
14390,#if defined(__APPLE__)
14391,// macOS or iOS code
14392,#elif defined(__unix__)
14393,// code for Unix-like systems
14394,#  if defined(__linux__)
14395,  // additional code for Linux
14396,#  endif
14397,#elif defined(_WIN32) || defined(_WIN64)
14398,// code for Windows
14399,#else
14400,"#error ""Unknown operating system"""
14401,#endif
14402,-DMACRO_NAME
14403,-DMACRO_NAME=expansion
14404,gcc -DPROTOCOL_VERSION=3
14405,#if PROTOCOL_VERSION == 1
14406,"#error ""Protocol version 1 is no longer supported."""
14407,#elif PROTOCOL_VERSION == 2
14408,// code for version 2
14409,#elif PROTOCOL_VERSION == 3
14410,// code for version 3
14411,#else
14412,"#error ""An unsupported protocol version was requrested"""
14413,#endif
14414,C202
14415,C141
14416,main.c(13): error C202: 'i': undefined identifier
14417,"main.c(17): error C141: syntax error near 'int', expected 'sizeof'"
14418,#include <stdio.h>
14419,#include <string.h>
14420,#include <stdlib.h>
14421,
14422,
14423,
14424,
14425,int main(){
14426,"         char *s = ""Hello""; "
14427,   int n = strlen(s);
14428,
14429,
14430,for (int i = 0; i <= n; i++)
14431,{
14432,    // convert each char to
14433,    // ASCII value
14434,     int val =  (int)(s[i]);
14435,
14436,    // Convert ASCII value to binary
14437,    char* bin;
14438,    while (val > 0)
14439,    {
14440,        if(val % 2) 
14441,                bin[i]  =1; 
14442,             else   
14443,                bin[i] = 0;
14444,        val /= 2;
14445,    }
14446,    bin =  strrev(bin);
14447,
14448,   
14449,}
14450,    
14451,    return bin;
14452,i
14453,for
14454,int i;
14455,bin
14456,int i;
14457,char bin[100]
14458,strrev
14459,☁
14460,u'\u2601'
14461,u'\u2601\ufe0f'
14462,\ufe0f
14463,FE0F
14464,FE0E
14465,FE0E
14466,FE0F
14467,U+FE0F
14468,U+FE0E
14469,U+FE0F
14470,U+FE0E
14471,U+FE0F
14472,&#x2601;
14473,execvp
14474,"int split(char * str, const char * token , char *** arr)"
14475,{
14476,    int c = 1;
14477,"    char * ptr = strtok(str , token);"
14478,    (*arr)[0] = malloc(1024);
14479,"    strcpy((*arr)[0], ""-c"");"
14480,    while (ptr != NULL) 
14481,    {
14482,        (*arr)[c] = malloc(1024);
14483,"        strcpy((*arr)[c], ptr);"
14484,        c++;
14485,"        *arr = realloc(*arr, sizeof(char*)*(c+1));"
14486,"        ptr = strtok(NULL, token);"
14487,    }
14488,    (*arr)[c] = NULL;
14489,    return c;
14490,}
14491,
14492,int  run(char * args[])
14493,{
14494,    int link[2];
14495,    pid_t pid;
14496,    char foo[4096];
14497,    if (pipe(link)==-1)
14498,        return -1;
14499,    if ((pid = fork()) == -1)
14500,        return -1;
14501,    if(pid == 0){
14502,"        dup2 (link[1], STDOUT_FILENO);"
14503,        close(link[0]);
14504,        close(link[1]);
14505,"        execvp(""/bin/bash"", args);"
14506,    } else {
14507,        close(link[1]);
14508,"        int nbytes = read(link[0], foo, sizeof(foo));"
14509,"        printf(""Output: (%.*s)\n"", nbytes, foo);"
14510,        wait(NULL);
14511,  }
14512,  return 0;
14513,}
14514,
14515,int main()
14516,{
14517,    char * tmp = malloc(1024);
14518,    /* list of pointers */
14519,    char ** arr = malloc(16);
14520,    /* buffer to hold user input */
14521,    char input[1024];
14522,"    scanf(""%[^\n]"", input);"
14523,"    //printf(""%s\n"",input);"
14524,"    int x = split(input, "" "", &arr);"
14525,    for (int i=0; i<x;i++)
14526,    {
14527,"        printf(""%s "",arr[i]);"
14528,    }
14529,
14530,    run(arr);
14531,
14532,"    char * arr2[] = {getenv(""SHELL""), ""-c"" ,""ls"",""-la"", NULL};"
14533,    run(arr2);
14534,}
14535,split
14536,-c
14537,NULL
14538,run
14539,/bin/bash
14540,ls -la
14541,/usr/bin/ls: /usr/bin/ls: cannot execute binary file
14542,-c ls -la Output: ()
14543,run
14544,"execvp(""/bin/bash"""
14545,ls
14546,the command with /bin/bash
14547,ls
14548,ls
14549,ls
14550,"execvp(args[0], args);"
14551,malloc(16);
14552,realloc
14553,/bin/bash
14554,"getenv(""SHELL"")"
14555,run
14556,getenv
14557,split
14558,run
14559,"int split(char * str, const char * token , char *** arr)"
14560,{
14561,    int c = 2;
14562,"    char * ptr = strtok(str , token);"
14563,    (*arr)[0] = malloc(1024);
14564,    /* added this as the first element in the array */
14565,"    strcpy((*arr)[0], getenv(""SHELL"")); "
14566,    (*arr)[1] = malloc(1024);
14567,    /* added this as the second element in the array */
14568,"    strcpy((*arr)[1], ""-c"");            "
14569,
14570,    while (ptr != NULL) 
14571,    {
14572,        (*arr)[c] = malloc(1024);
14573,"        strcpy((*arr)[c], ptr);"
14574,        c++;
14575,"        *arr = realloc(*arr, sizeof(char*)*(c+1));"
14576,"        ptr = strtok(NULL, token);"
14577,    }
14578,    (*arr)[c] = NULL;
14579,    return c;
14580,}
14581,
14582,
14583,int  run(char * args[])
14584,{
14585,    int link[2];
14586,    pid_t pid;
14587,    char foo[4096];
14588,    if (pipe(link)==-1)
14589,        return -1;
14590,    if ((pid = fork()) == -1)
14591,        return -1;
14592,    if(pid == 0){
14593,"        dup2 (link[1], STDOUT_FILENO);"
14594,        close(link[0]);
14595,        close(link[1]);
14596,        /* /bin/bash to args[0] */
14597,"        execvp(args[0], args);"
14598,    } else {
14599,        close(link[1]);
14600,"        int nbytes = read(link[0], foo, sizeof(foo));"
14601,"        printf(""Output: (%.*s)\n"", nbytes, foo);"
14602,        wait(NULL);
14603,  }
14604,  return 0;
14605,}
14606,run llvm-objdump on each symbol
14607,-S
14608,struct test {
14609,   
14610,    unsigned int x;
14611,    long int y : 33;
14612,    unsigned int z;   
14613,};
14614,sizeof(struct test)
14615,sizeof
14616,sizeof
14617,static_assert
14618,long
14619,long long
14620,#include <stdio.h>                                                                    
14621,                                                                                      
14622,typedef struct s_test {                                                               
14623,                                                                                      
14624,    unsigned int x;                                                                   
14625,    long int y : 33;                                                                  
14626,    unsigned int z;                                                                   
14627,} test;                                                                               
14628,                                                                                      
14629,int main() {                                                                          
14630,"  printf(""Unsigned int size : %d\n"", sizeof(unsigned int));                           "
14631,"  printf(""Long int size : %d\n"", sizeof(long int));                                   "
14632,"  printf(""Total size : %d\n"", sizeof(test));                                          "
14633,} 
14634,OUTPUT :
14635,Unsigned int size : 4
14636,Long int size : 8
14637,Total size : 24
14638,typedef struct s_test {                                                               
14639,  long int y : 33;                                                                    
14640,  unsigned int x;                                                                     
14641,  unsigned int z;                                                                     
14642,} test;
14643,OUTPUT :
14644,Unsigned int size : 4
14645,Long int size : 8
14646,Total size : 16
14647,static_assert
14648,malloc
14649,realloc
14650,char
14651,char
14652,strlen
14653,strcpy
14654,char *
14655,malloc
14656,"char *s; // You need to allocate memory to this later, at runtime. "
14657,"char *s = ""Hello World""; // This is a read-only string. You cannot change this later."
14658,"char c[10]; // Define a buffer of max 10 chars. If last char is \0, it's a c string."
14659,/opt/libexpat-2.4.8
14660,gcc -I/optlibexpat-2.4.8/include -L/opt/libexpat-2.4.8/lib -lexpat -o myorogram myprogram.c
14661,gcc (Debian 10.2.1-6) 10.2.1 20210110
14662,/usr/bin/ld: /tmp/[...].o: in function [...] undefined reference to `XML_ParserCreate'
14663,/opt/libexpat-2.4.8/lib/libexpat.a
14664,$ nm /opt/libexpat-2.4.8/lib/libexpat.a | grep XML_ParserCreate
14665,00000000000037a0 T XML_ParserCreate
14666,0000000000003790 T XML_ParserCreate_MM
14667,00000000000037b0 T XML_ParserCreateNS
14668,ld
14669,-I
14670,-L
14671,-l
14672,-L
14673,-l
14674,"""aabbcc"" --> ""abc""."
14675,#define _CRT_SECURE_NO_WARNINGS
14676,#include <stdio.h>
14677,
14678,"int remove_doubles(const char* filein, const char* fileout) {"
14679,    if (!filein || !fileout) {
14680,        return 0;
14681,    }
14682,"    FILE* f = fopen(filein, ""r"");"
14683,    if (f == NULL) {
14684,        return 0;
14685,    }
14686,"    FILE* g = fopen(fileout, ""w"");"
14687,    if (g == NULL) {
14688,        return 0;
14689,    }
14690,    while (1) {
14691,        int c = fgetc(f);
14692,        if (c == EOF) {
14693,            break;
14694,        }
14695,        int d = fgetc(f);
14696,        if (c != d) {
14697,"            fprintf(g, ""%c"", d);"
14698,        }
14699,    }
14700,
14701,    fclose(f);
14702,    fclose(g);
14703,    return 1;
14704,}
14705,
14706,int main(void) {
14707,"    char filein[] = ""test.txt"";"
14708,"    char fileout[] = ""out_test.txt"";"
14709,"    int c = remove_doubles(filein, fileout);"
14710,
14711,    return 0;
14712,}
14713," ""e,wrd ewrdÿ"". "
14714,
14715,"the input text was: ""hello, world! heyyyyyyyyyyyy worlllllddddddd"". "
14716,c
14717,d
14718,d
14719,EOF
14720,// ...
14721,"    int c, d = EOF; // init `d` to some ""non""-character"
14722,
14723,    while ((c = fgetc(f)) != EOF) {
14724,        if (c != d) {    // not same as the previous?
14725,"            fputc(c, g); // ok, print it"
14726,            d = c;       // and assign c to d
14727,        }
14728,    }
14729,// ...
14730,d
14731,#include <stdio.h>
14732,
14733,void main() {
14734,    int a;
14735,"    float b, c, d;"
14736,    a = 750;
14737,    b = a / 350;
14738,    c = 750;
14739,    d = c / 350;
14740,"    printf(""%.2f %.2f"", b, d);"
14741,    // output: 2.00 2.14
14742,}
14743,float
14744,float
14745,a
14746,350
14747,int
14748,int i = 2.0;
14749,double d = 1;
14750,"b, c, d"
14751,float
14752,/
14753,float
14754,/
14755,#include <stdio.h>
14756,
14757,int main() {
14758,    int a;
14759,"    float b, c, d;"
14760,    a = 750;
14761,    b = a / 350.0f;
14762,    c = 750;
14763,    d = c / 350;
14764,"    printf(""%.2f %.2f"", b, d);"
14765,    // output: 2.14 2.14
14766,    return 0;
14767,}
14768,int main() {
14769,    int a;
14770,"    float b, c, d;"
14771,    a = 750;
14772,    b = a / (float)350;
14773,    c = 750;
14774,    d = c / (float)350;
14775,"    printf(""%.2f %.2f"", b, d);"
14776,    // output: 2.14 2.14
14777,}
14778, int main() {
14779,        int a;
14780,"        float b, c, d;"
14781,        a = 750;
14782,"        b = a / 350.0; //if you use 'a / 350' here, "
14783,"                       //then it is a division of integers, "
14784,                       //so the result will be an integer
14785,        c = 750;
14786,        d = c / 350;
14787,"        printf(""%.2f %.2f"", b, d);"
14788,        // output: 2.14 2.14
14789,    }
14790,b = (float) a / 350;
14791,float
14792,350.0
14793,double
14794,double
14795,float
14796,350.0f
14797,float
14798,float
14799,double
14800,b = a / 350.0;
14801,/
14802,a/b
14803,(a/b)*b + a%b
14804,a
14805,a/b
14806,a%b
14807,b = a / 350.0f;
14808,0xfffffffffffffff/15
14809,int/int
14810,#include <stdlib.h>
14811,#include <stdio.h>
14812,
14813,__attribute__((noinline))
14814,"int *get_indecies(int *padding, int pad_size, int size, int alias_type);"
14815,
14816,"int *get_indecies(int *padding, int pad_size, int size, int alias_type){"
14817,    int *indecies = (int *)malloc(size*sizeof(int));
14818,"    asm(""dsb sy\n\t"");"
14819,    return indecies;
14820,}
14821,.....
14822, 1f0:   d5033f9f        dsb     sy
14823," 1f4:   aa1f03e1        mov     x1, xzr"
14824,......
14825,"clang verification.c get_indecies.o -I ""/home/[name]/gem5/include""  -L ""/home/[name]/gem5/util/m5/build/arm64/out"" -lm5 -lc -O0 -static -target aarch64-linux-gnu -o verfication-base-m5"
14826, aarch64-linux-gnu-objdump verification-base-m5 -S > assembly.s
14827,"clang -S get_indecies.c -target aarch64-linux-gnu, and checked get_indecies.s"
14828,"clang verification.c get_indecies.o -I ""/home/[name]/gem5/include""  -L ""/home/[name]/gem5/util/m5/build/arm64/out"" -lm5 -lc -O0 -static -target aarch64-linux-gnu -o verfication-base-m5 "
14829,verification.c
14830,get_indecies
14831,verification.c
14832,verification.o
14833,verfication-base-m5
14834,"clang verification.c get_indecies.o -I ""/home/[name]/gem5/include""  -L ""/home/[name]/gem5/util/m5/build/arm64/out"" -lm5 -lc -O0 -static -target aarch64-linux-gnu -o verfication-base-m5"
14835,#include <stdio.h>
14836,#include <math.h>
14837,
14838,"//""the function"""
14839,
14840,"int calculate_new_vertex_for_trangle(int center_x, int center_y,int x_at_0,int y_at_0,int angle)"
14841,{
14842,"    double radius = sqrt(pow(x_at_0-center_x,2)+pow(y_at_0-center_y,2));"
14843,
14844,    float angle_to_radian = ((22.0/7.0)/180)*angle;
14845,
14846,    // googled formula 
14847,    float new_x = center_x + radius*cos(angle_to_radian);
14848,    float new_y = center_y + radius*sin(angle_to_radian);
14849,
14850,"    printf(""x : %f, y : %f \nradius : %f\n"",  new_x, new_y,radius);"
14851,
14852,    return 0;
14853,}
14854,M_PI
14855,float new_x = center_x + radius*cos(angle_to_radian);
14856,float new_y = center_y + radius*sin(angle_to_radian);
14857,"(px,py)"
14858,"float angle_ini = atan2(px-center_x, py-center_y);"
14859,float new_x = center_x + radius*cos(angle_to_radian + angle_ini);
14860,float new_y = center_y + radius*sin(angle_to_radian + angle_ini);
14861,float angle_to_radian = (3.14159265358979/180)*angle;
14862,float sinA = sin(angle_to_radian);
14863,float cosA = cos(angle_to_radian);
14864,float new_x = center_x + (px-center_x)*cosA - (py-center_y)*sinA;
14865,float new_y = center_y + (px-center_x)*sinA + (py-center_y)*cosA;
14866,px*cosA
14867,(px-center_x)*cosA
14868,#include <stdio.h>
14869,#include <math.h>
14870,
14871,int main()
14872,{
14873,
14874,    // Center on circle
14875,    float center_x = 0.0;
14876,    float center_y = 0.0;
14877,    
14878,    // Point on circle
14879,    float point_x = 1.0;
14880,    float point_y = 1.0;
14881,    
14882,    // Rotation angle
14883,    float rotation_deg = 180;
14884,    float rotation_rad = rotation_deg * M_PI / 180.0;
14885,    
14886,    // Rotation matrix
14887,    float a = cos(rotation_rad);
14888,    float b = -sin(rotation_rad);
14889,    float c = sin(rotation_rad);
14890,    float d = cos(rotation_rad);
14891,    
14892,    // Matrix multiplication
14893,    float dx = point_x - center_x;
14894,    float dy = point_y - center_y;
14895,    float new_x = a * dx + b * dy;
14896,    float new_y = c * dx + d * dy;
14897,    
14898,    // Add center point
14899,    new_x += center_x;
14900,    new_y += center_y;
14901,    
14902,"    printf(""old_point = %.2f|%.2f\n"", point_x, point_y);"
14903,"    printf(""new_point = %.2f|%.2f\n"", new_x, new_y);"
14904,    
14905,}
14906,       #include <stdio.h>
14907,        int main() {
14908,            /*function declaration*/
14909,    
14910,        double invalidInput(double);
14911,        int loop_obeTask;
14912,        double  obe_Task[3];
14913,        double checkInput ;
14914,        for(loop_obeTask = 1 ; loop_obeTask < 4 ; loop_obeTask++)
14915,        {
14916,"            printf(""OBE%d : "", loop_obeTask);"
14917,"            scanf(""%lf"",&obe_Task[loop_obeTask]);"
14918,        
14919,            checkInput = invalidInput(obe_Task[loop_obeTask]);
14920,            if(checkInput = 1)
14921,            {
14922,"                  printf(""INVALID INPUT \n"" );"
14923,                  break;
14924,            }
14925,        }
14926,           return 0;
14927,        }
14928,    double invalidInput(double inputGrade)
14929,    {
14930,        double indicator;
14931,    
14932,        if(inputGrade > 100)
14933,        {
14934,            indicator = 1;
14935,        }
14936,        else{
14937,            indicator = 0;
14938,        }
14939,        return indicator;
14940,    }
14941,invalidInput()
14942,double
14943,for(loop_obeTask = 1; loop_obeTask < 4; loop_obeTask++)
14944,double  obe_Task[3]
14945,if(checkInput = 1)
14946,==
14947,double
14948,invalidInput()
14949,int
14950,for
14951,for (index = 0; index < MAX; index++)
14952,MAX
14953,if
14954,checkInput
14955,1
14956,=
14957,==
14958,main
14959,struct x { int x; } x;
14960,struct y { int x; } *p = &x;
14961,
14962,$ gcc t0.c -std=c11 -pedantic -Wall -Wextra
14963,warning: initialization of 'struct y *' from incompatible pointer type 'struct x *' [-Wincompatible-pointer-types]
14964,
14965,$ clang t0.c -std=c11 -pedantic -Wall -Wextra
14966,warning: incompatible pointer types initializing 'struct y *' with an expression of type 'struct x *' [-Wincompatible-pointer-types]
14967,
14968,$ icc t0.c -std=c11 -pedantic -Wall -Wextra
14969,"warning #144: a value of type ""struct x *"" cannot be used to initialize an entity of type ""struct y *"""
14970,
14971,$ cl t0.c /std:c11
14972,warning C4133: 'initializing': incompatible types - from 'x *' to 'y *'
14973,$ cat foo.c
14974,struct struc1 {
14975,    int x;
14976,};
14977,
14978,int foo(struct struc1 *s)
14979,{
14980,    return s->x;
14981,}
14982,
14983,$ cat main.c
14984,struct struc {
14985,    float x;
14986,};
14987,
14988,int foo(struct struc *s);
14989,
14990,int main(void)
14991,{
14992,    return foo(&(struct struc){1.2f});
14993,}
14994,
14995,$ gcc foo.c main.c -std=c11 -pedantic -Wall -Wextra
14996,<nothing>
14997,otherwise-identical struct types with different tag names are “compatible” in C
14998,struct x {
14999,   int i;
15000,   char *s;
15001,};
15002,"#include ""h1.h"""
15003,void foo1(struct x *s)
15004,{
15005,    ++s->i;
15006,}
15007,"#include ""h1.h"""
15008,void foo2(struct x *s)
15009,{
15010,    --s->i;
15011,}
15012,struct x
15013,struct S
15014,struct S
15015,struct x
15016,struct y
15017,struct { int x; int y; } point;
15018,struct
15019,"struct { int x; int y; } point = {2,1};"
15020,extern struct { int x; int y; };
15021,struct x { int x; }
15022,struct y { int x; }
15023,x = y = 0
15024,"mov [x], 1"
15025,"mov r2, [y]"
15026,"mov [y], 1"
15027,"mov r1, [x]"
15028,r1 = r2 = 0
15029,"release(mov [x], 1)"
15030,"mov r2, [y]"
15031,"mov [y], 1"
15032,"acquire(mov r1, [x])"
15033,"acquire(mov r1, [x])"
15034,"release(mov [x], 1)"
15035,"acquire(mov r1, [x])"
15036,"mov [y], 1"
15037,"acquire(mov r1, [x])"
15038,memory_order_seq_cst
15039,mfence
15040,lock
15041,xchg
15042,lock
15043,memory_order_seq_cst
15044,"lock add [rsp], 0"
15045,xchg
15046,mfence
15047,"x.store(value, seq_cst)"
15048,"mov eax, value"
15049,"xchg [x], eax"
15050,\n
15051,\r\n
15052,\r\n
15053,\r\n
15054,\n
15055,fgetc
15056,fseek
15057,'\x1A'
15058,'\x1A'
15059,fread
15060,fwrite
15061,fprintf
15062,fscanf
15063,fprintf
15064,fscanf
15065,fread
15066,fwrite
15067,fseek
15068,ftell
15069,ftell()
15070,fseek
15071,ftell
15072,void create_list(LIST *p){
15073,    int x;
15074,"    printf(""enter no of elements to enter\n"");"
15075,"    scanf(""%d"", &x);"
15076,"    printf(""creating a list of size %d\n"", x);"
15077,    p->head =NULL;
15078,    p->last=NULL;
15079,"    printf(""initialised list\n"");"
15080,    
15081,    for(int i =0; i<x; i++){
15082,        ins(p);
15083,    }
15084,    display(p);
15085,}
15086, 
15087,int main(){
15088,
15089,"    LIST* list1, *list2;"
15090,    create_list(list1);
15091,    create_list(list2);
15092,    return 0;
15093,}
15094,"LIST* list1, *list2;"
15095,LIST
15096,main
15097,"LIST list1, list2;"
15098,create_list(&list1);
15099,create_list(&list2);
15100,LIST
15101,create_list
15102,float reLU(float Input) {
15103,    float result = 0;
15104,    if (Input > 0)
15105,    {
15106,        result = Input;
15107,    }
15108,    if (Input < 0)
15109,    {
15110,        result = 0.01 * Input;   //tunable parameter
15111,    }
15112,    return result;
15113,}
15114,
15115,float dxReLU(float reLUvalue) {
15116,    float res = 0;
15117,    if (reLUvalue > 0)
15118,    {
15119,        res = 1;
15120,    }
15121,    if (reLUvalue < 0)
15122,    {
15123,        res = 0.01;    //tunable parameter
15124,    }
15125,    return res;
15126,}
15127,    for (int i = 0; i < 10; i++)
15128,    {
15129,        delta_o[i] = ((float)((float)Out_Lay[i] - (float)Corr_Ans[k][i]));
15130,    }
15131,
15132,    for (int i = 0; i < 10; i++)
15133,    {
15134,        for (int j = 0; j < NumberOfNeuronsH2; j++)
15135,        {
15136,            HL2_wght[i][j] += -learn_rate * (delta_o[i] * H_Lay2[j]);
15137,        }
15138,        HL2_wght_bias[i] += -learn_rate * delta_o[i];
15139,    }
15140,"    //NormalizerWeights(HL2_wght, 10, NumberOfNeuronsH2);"
15141,"    //NormalizerBiases(HL2_wght_bias, 10);"
15142,    // Updating HL1 weights
15143,    for (int i = 0; i < NumberOfNeuronsH2; i++)
15144,    {
15145,        for (int j = 0; j < 10; j++)
15146,        {
15147,            delta_h2[i] += HL2_wght[j][i] * delta_o[j] * (dxReLU(H_Lay2[i]));
15148,        }
15149,    }
15150,
15151,    for (int i = 0; i < NumberOfNeuronsH2; i++)
15152,    {
15153,        for (int j = 0; j < NumberOfNeuronsH1; j++)
15154,        {
15155,            HL1_wght[i][j] += -learn_rate * (delta_h2[i] * H_Lay1[j]);
15156,        }
15157,        HL1_wght_bias[i] += -learn_rate * delta_h2[i];
15158,    }
15159,        
15160,    for (int i = 0; i < NumberOfNeuronsH0; i++)
15161,    {
15162,        for (int j = 0; j < 784; j++)
15163,        {
15164,            H_Lay0[i] += In_Lay[j] * In_wght[i][j];
15165,        }
15166,        H_Lay0[i] = reLU(H_Lay0[i] + In_wght_bias[i]);
15167,    }
15168,float RandomFloat() {
15169,    float randomized = (float)((float)(rand() % 50) / 100);
15170,    if (randomized < (0.25))
15171,    {
15172,        randomized = randomized * -1;
15173,    }
15174,    return randomized;
15175,}
15176,
15177,"    float** HL0_wght = Allocate2DArrayOfFloats(NumberOfNeuronsH1, NumberOfNeuronsH0);"
15178,    for (int i = 0; i < NumberOfNeuronsH1; i++)
15179,    {
15180,        for (int j = 0; j < NumberOfNeuronsH0; j++)
15181,        {
15182,            HL0_wght[i][j] = RandomFloat() * (float)SQrt((float)6 / (float)NumberOfNeuronsH0);
15183,        }
15184,    }
15185,    float* HL0_wght_bias = (float*)malloc(sizeof(float) * NumberOfNeuronsH1);
15186,    for (int i = 0; i < NumberOfNeuronsH1; i++)
15187,    {
15188,        HL0_wght_bias[i] = RandomFloat() * (float)SQrt((float)6 / (float)NumberOfNeuronsH0);
15189,    }
15190,#include <stdio.h>
15191,#include <stdint.h>
15192,#include <stdbool.h>
15193,#include <stdlib.h>
15194,
15195,int main(void)
15196,{
15197,    uint64_t *ptr = malloc(sizeof(uint64_t));
15198,"    scanf(""%llu"",&ptr);"
15199,"    printf(""%llu\n"", *ptr);"
15200,    free(ptr);
15201,}
15202,mod_5_working.c:9:14: error: unknown conversion type character 'l' in format [-Werror=format=]
15203,"     scanf(""%llu"",&ptr);"
15204,              ^
15205,mod_5_working.c:9:11: error: too many arguments for format [-Werror=format-extra-args]
15206,"     scanf(""%llu"",&ptr);"
15207,%u
15208,%llu
15209,uint64_t
15210,#include <inttypes.h>
15211,#include <stdint.h>
15212,"""%"" SCNu64"
15213,uint64_t
15214,uint64_t
15215,uint64_t
15216,"scanf(""%llu"",&ptr);"
15217,uint64_t
15218,unsigned long long
15219,unsigned long
15220,uint64_t
15221,SCNu64
15222,PRIu64
15223,#include <stdio.h>
15224,#include <stdint.h>
15225,#include <inttypes.h>
15226,#include <stdlib.h>
15227,
15228,int main(void)
15229,{
15230,    uint64_t *ptr = malloc(sizeof(uint64_t));
15231,"    scanf(""%""SCNu64, ptr);"
15232,"    printf(""%""PRIu64""\n"", *ptr);"
15233,    free(ptr);
15234,}
15235,#include <stdint.h>
15236,inttypes.h
15237,stdint.h
15238,inttypes.h
15239,scanf
15240,scanf
15241,&
15242,malloc
15243,uint64_t *ptr = malloc(sizeof(uint64_t));
15244,if (!ptr)
15245,    return -1; /* Maybe handle it better */
15246,
15247,"scanf(""%"" SCNu64, ptr);"
15248,"printf(""%"" PRIu64 ""\n"", *ptr);"
15249,
15250,free(ptr);
15251,SCNu64
15252,PRIu64
15253,<inttypes.h>
15254,uint64_t
15255,long unsigned int
15256,unsigned long long
15257,long unsigned int
15258,#include <stdio.h>
15259,#include <inttypes.h> /* Format conversions for exact-width types */
15260,
15261,"scanf(""%"" SCNu64, ptr);  // No &."
15262,"printf(""%"" PRIu64 ""\n"", *ptr);"
15263,PRNu64
15264,PRIu64
15265,stdin
15266,fread()
15267,#include <stdio.h>
15268,#include <stdlib.h>
15269,#include <string.h>
15270,
15271,"int main(int argc, char *argv[])"
15272,{
15273,    if (argc != 2) {
15274,"        fprintf(stderr, ""argument err"");"
15275,        return -1;
15276,    }
15277,   
15278,"    FILE *in  = fopen(argv[1], ""w"");"
15279,
15280,    if (in == NULL) {
15281,"        fprintf(stderr, ""failed to open file"");"
15282,        return -1;
15283,    }
15284,   
15285,    char buffer[20];
15286,  
15287,    size_t ret;
15288,
15289,"    while ((ret = fread(buffer, 1, 20, stdin)) > 0) {"
15290,"           if (fwrite(buffer, 1, ret, in) != ret) {"
15291,               if (ferror(in) != 0) {
15292,"                    perror(""write err:"");"
15293,               } 
15294,           }
15295,    }
15296,    
15297,    return 0;
15298,}
15299,break
15300,return
15301,CTRL
15302,D
15303,in
15304,stdin
15305,break
15306,return
15307,EOF
15308,int
15309,char
15310,EOF
15311,read()
15312,EOF
15313,fread
15314,fwrite
15315,fread()
15316,stdio.h
15317,EOF
15318,fread()
15319,fread()
15320,fread()
15321,EOF
15322,fread()
15323,fwrite()
15324,struct
15325,"    while ((ret = fread(buffer, 1, 20, stdin)) >= 0) {"
15326,"           if (fwrite(buffer, 1, ret, in) != ret) {"
15327,               if (ferror(in) != 0) {
15328,"                    perror(""write err:"");"
15329,               } 
15330,           }
15331,    }
15332,    /* here you can have upto 19 bytes in the buffer that cannot
15333,"     * be read with that record length, but you can read individually"
15334,     * with fgetc() calls. */
15335,fread()
15336,int c;
15337,while ((c = fgetc(in)) != EOF)
15338,"    fputc(c, out);"
15339,read(2)
15340,read()
15341,fputc()
15342,write()
15343,size_t fread()
15344,EOF
15345,#include <stdio.h>
15346,#include <stdbool.h>
15347,
15348,"int main(int argc, char * argv[]) {"
15349,"    printf(""\nPlug the telephone via USB..."");"
15350,    char * model;
15351,    char * name;
15352,    while (1) {
15353,        if (THERE IS A TELEPHONE PLUGGED) { break; }
15354,    }
15355,    model = STORE THE DEVICE MODEL
15356,    name = STORE THE DEVICE NAME
15357,"    printf(""\nModel: %s\nName: %s"", model, name); "
15358,}
15359,while (1) { if (condition) { break; } }
15360,while (!condition) {}
15361,"function calc (x, y)"
15362,    return (x^2 * y)
15363,end
15364,
15365,"pcall(calc,10,20)"
15366,#include<stdio.h>
15367,#include<stdlib.h>
15368,#include<math.h>
15369,#include<ctype.h>
15370,#include<string.h>
15371,#include<stdbool.h>
15372,
15373,"void tukar(int a, int b){"
15374,    int temp;
15375,    temp = a;
15376,    a=b;
15377,    b=temp;
15378,    
15379,}
15380,
15381,int main(){
15382,
15383,"    int j,i=1,z=1,k,l, temp ;"
15384,"    char a,b;"
15385,"    int c,d;"
15386,    
15387,    
15388,"    scanf(""%d"", &j);"
15389,    int A[2][j];
15390,    
15391,    for(i=0;i<2;i++){
15392,        for(z=1;z<=j;z++){
15393,"            scanf(""%d"", &A[i][z]);"
15394,        }
15395,    }
15396,    
15397,"    scanf(""%d"", &k);"
15398, 
15399,    
15400,    for(l=0; l<k;l++){
15401,"        scanf("" %c"", &a);"
15402,"        scanf(""%d"", &c);"
15403,"        scanf("" %c"", &b);"
15404,"        scanf(""%d"", &d);"
15405,    
15406,     
15407,        int p = a-'A';
15408,        int q = b - 'A';
15409,        
15410,"        tukar(A[p][c], A[q][d]);"
15411,"        printf(""%d %d"", A[p][c], A[q][d]);"
15412,     }
15413,    
15414,"    int aa,bb;"
15415,    
15416,    for(aa=0; aa<2; aa++){
15417,        for(bb=1; bb<=j;bb++){
15418,"            printf(""%d "", A[aa][bb]);"
15419,        }
15420,"        printf(""\n"");"
15421,    }
15422,}
15423,for(z=1;z<=j;z++)
15424,"printf(""You are %d years old"", age);"
15425,"printf(""You are %d years old"", age);"
15426,printf
15427,%d
15428,"printf( ""%s %d %s\n"", ""You are"", age, ""years old"" );"
15429,printf
15430,#include <stdio.h>
15431,#include <stdlib.h>
15432,
15433,struct student
15434,{
15435,    char *name;
15436,    int age;
15437,    int site[2][1] ;
15438,};
15439,void printstruct(void);
15440,"struct student Jerry = {""Jerry"",16,{3,4}};"
15441,"struct student Jimmy = {""Jimmy"",15,{2,2}};"
15442,struct student *ptrJerry = &Jerry;              //address of Jerry
15443,struct student *ptrJimmy = &Jimmy;              //address of Jimmy
15444,int main(void)
15445,{
15446,    printstruct();
15447,    
15448,"    system(""pause"");"
15449,    return 0;
15450,}
15451,
15452,void printstruct(void)
15453,{
15454,"    printf(""JimmyAge:%s \n"",(*ptrJimmy).age);"
15455,"    printf(""Jerrysite:Row %d Col %d \n"",((*ptrJerry).site)[0][0],((*ptrJerry).site)[1][0]);"
15456,
15457,}
15458,age
15459,#include <stdio.h>
15460,#include <string.h>
15461,#include <stdlib.h>
15462,
15463,#define SIZE 10
15464,
15465,"void input_string (char** pptr_one, char** pptr_two)"
15466,{
15467,    char buffer[SIZE];
15468,"    printf(""\nInput: "");"
15469,"    char* x = fgets(buffer, SIZE, stdin);"
15470,    
15471,    //Copying the original fgets result address:
15472,    *pptr_one = x;
15473,    //Copying its contents to another variable:
15474,    *pptr_two = malloc(SIZE);
15475,"    strcpy(*pptr_two, x);"
15476,}
15477,
15478,"int main (int argc, char **argv)"
15479,{
15480,    char* ptr_one;
15481,    char* ptr_two;
15482,"    input_string(&ptr_one, &ptr_two);"
15483,
15484,"    printf(""\nptr_one is pointing to: <%s>\n"", ptr_one);"
15485,"    printf(""ptr_two is pointing to: <%s>\n"", ptr_two);"
15486,
15487,    return 0;
15488,}
15489,fgets()
15490,goto
15491,char buffer[SIZE]
15492,input_string()
15493,buffer
15494,buffer
15495,buffer
15496,malloc()
15497,char *buffer = malloc(sizeof(char) * SIZE)
15498,buffer
15499,static
15500,static char buffer[SIZE];
15501,*pptr_one
15502,buffer
15503,input_string
15504,fgets
15505,buffer
15506,x
15507,*pptr_one
15508,fgets
15509,(char *)1
15510,"void input_string (char** pptr_one, char** pptr_two)"
15511,{
15512,    char buffer[SIZE];
15513,"    printf(""\nInput: "");"
15514,"    char* x = fgets(buffer, SIZE, stdin);"
15515,    // missing test for NULL return from fgets()
15516,
15517,    /*** DO NOT DO THIS.
15518,     * DO NOT TAKE THE ADDRESS OF A LOCAL VARIABLE FOR USE AFTER FUNCTION EXITS!
15519,"     * When successful, fgets will return the address of 'buffer' so x points to buffer."
15520,    //Copying the original fgets result address:
15521,    *pptr_one = x;
15522,    *****/
15523,
15524,    //Copying its contents to another variable:
15525,    *pptr_two = malloc(SIZE);
15526,    // should check that malloc succeeded
15527,"    strcpy(*pptr_two, x);"
15528,    // Aren't you glad that fgets() guarantees buffer will be a null terminated string?
15529,
15530,    // Be sure caller free's the allocated piece of heap storage!
15531,}
15532,    static char buffer[SIZE];
15533,"    printf(""\nInput: "");"
15534,doesn't stay the same once the ... [execution of] the function in which fgets is being invoked.
15535,input_string()
15536,main()
15537,input_string()
15538,"void input_string( char *buf, size_t len ) {"
15539,"    fgets(buffer, len, stdin);"
15540,}
15541,
15542,int main() {
15543,    char buffer[ SIZE ];
15544,"    input_string( buffer, sizeof buffer );"
15545,"    printf( ""Got '%s' from stdin\n"", buffer );"
15546,}
15547,input_string()
15548,static
15549,:-)
15550,#include <cs50.h>
15551,#include <string.h>
15552,#include <ctype.h>
15553,#include <stdio.h>
15554,
15555,"const string alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";"
15556,
15557,"int main(int argc, string argv[])"
15558,{
15559,    int len = 26;
15560,     if (argc != 2){
15561,"        printf(""Usage ./substitution key\n"");"
15562,        return 1;
15563,    }
15564,    else if(len != 26){
15565,"        printf(""Must have 26 letters\n"");"
15566,        return 1;
15567,    }
15568,    else {
15569,        for(int i = 0; i < len; i++){
15570,            if(!isalpha(argv[1][i])){
15571,"                printf(""Must not contain a digit\n"");"
15572,                return 1;
15573,            }
15574,        }
15575,    }
15576,    for(int i = 0; i < len-1; i++)
15577,    {
15578,        if(argv[1][i]==argv[1][i+1]){
15579,"             printf(""Must not have repeated characters\n"");"
15580,             return 1;
15581,        }
15582,    }
15583,
15584,    string key = argv[1];
15585,"    string plainText = get_string(""Plain Text: "");"
15586,
15587,    char cipherText[len + 1];
15588,
15589,      for (int i = 0; i < len; i++)
15590,        {
15591,            // Check if uppercase and if so use standard  alphabet/key
15592,            if (isupper(plainText[i]) != 0)
15593,            {
15594,                for (int j = 0; j < 26; j++)
15595,                {
15596,                    if (plainText[i] == toupper(alphabet[j]))
15597,                    {
15598,                        cipherText[i] = toupper(argv[1][j]);
15599,                        break;
15600,                    }
15601,                }
15602,            }
15603,            else if (islower(plainText[i]) != 0)
15604,            {
15605,                for (int j = 0; j < 26; j++)
15606,                {
15607,                    if (plainText[i] == tolower(alphabet[j]))
15608,                    {
15609,                        cipherText[i] = tolower(argv[1][j]);
15610,                        break;
15611,                    }
15612,                }
15613,            }
15614,            else
15615,            {
15616,                cipherText[i] = plainText[i];
15617,            }
15618,        }
15619,
15620,         // Add null char to make it a string
15621,        cipherText[len] = '\0';
15622,        // Print result and exit
15623,"        printf(""ciphertext: %s\n"", cipherText);"
15624,        return 0;
15625,}
15626,len
15627,for(int i = 0; i < len-1; i++) { if(argv[1][i]==argv[1][i+1]){
15628,if( )
15629,return
15630,exit( );
15631,else
15632,if( )
15633,#include <stdlib.h>
15634,
15635,"int main(int argc, char *argv[]) "
15636,{
15637,    short int day;
15638,    short int month;
15639,    short int year;
15640,    
15641,"    printf(""Type data day(dd_mm_yyyy)\n"");"
15642,    
15643,"    scanf(""%hd%hd%hd"",&day,&month,&year);"
15644,    
15645,    switch(day > 31 || month > 12)
15646,    {
15647,"        case 0 : printf(""Valid""); "
15648,                 break;
15649,"        default: printf(""Invalid"");"
15650,    }
15651,    
15652,}
15653,(day > 31 || year > 12)
15654,(day > 31 || year > 12)
15655,day > 31 || month > 12
15656,short int day = 4;
15657,short int month = 5;
15658,short int year = 6;
15659,
15660,switch (day > 31 || year > 12)
15661,{
15662,case 0:
15663,"    printf(""Valid"");"
15664,    break;
15665,default:
15666,"    printf(""Invalid"");"
15667,    break;
15668,}
15669,Valid
15670,0
15671,1
15672,(day > 31 || year > 12)
15673,"printf(""%d\n"", day > 31 || year > 12);"
15674,if (day > 31 || year > 12)
15675,   // take action if date is wrong
15676,else
15677,   // take action if date is correct
15678,day > 31 || year > 12
15679,typedef struct
15680,{
15681,  unsigned char day;  //1 Byte
15682,  unsigned char month; //1 Byte
15683,  unsigned int year;  //4 Bytes
15684,  unsigned char hours; //1 Byte
15685,  unsigned char minutes; //1 Byte
15686,} Time; //4 Bytes are probably used for padding
15687,unsigned int
15688,unsigned short
15689,year
15690,year
15691,unsigned int
15692,char
15693,int
15694,unsigned char day;  //1 Byte
15695,unsigned char month; //1 Byte
15696,// 2 byte padding!
15697,unsigned int year;  //4 Bytes
15698,unsigned char hours; //1 Byte
15699,unsigned char minutes; //1 Byte
15700,// 2 byte padding!
15701,int
15702,year
15703,unsigned int year;  //4 Bytes
15704,unsigned char day;  //1 Byte
15705,unsigned char month; //1 Byte
15706,unsigned char hours; //1 Byte
15707,unsigned char minutes; //1 Byte
15708,sizeof(Time) == 12
15709,sizeof(unsigned int) == 4
15710,typedef struct
15711,{
15712,  unsigned char day;  //1 Byte
15713,  unsigned char month; //1 Byte
15714,// 2 bytes padding to align the `unsigned int`
15715,  unsigned int year;  //4 Bytes
15716,  unsigned char hours; //1 Byte
15717,  unsigned char minutes; //1 Byte
15718,// 2 bytes padding
15719,} Time; 
15720,year
15721,typedef struct
15722,{
15723,  unsigned int year;  //4 Bytes
15724,  unsigned char day;  //1 Byte
15725,  unsigned char month; //1 Byte
15726,  unsigned char hours; //1 Byte
15727,  unsigned char minutes; //1 Byte
15728,} Time; 
15729,char
15730,int
15731,char
15732,struct
15733,struct my_struct {
15734,    double        time_as_double;  // normally 8 byte alignment
15735,    char         *timezone;        // 8 byte alignment in 64bit architectures.
15736,    int           year;            // 4 byte alignment
15737,"    unsigned char month,           // one byte alignment"
15738,"                  mday,            // one byte alignment"
15739,"                  hour,            // one byte alignment"
15740,"                  min,             // one byte alignment"
15741,                  sec;             // one byte alignment
15742,    // seven more bytes of alignment to comply with 8 byte alignment for the
15743,    // full structure (to allow it to form arrays)
15744,};
15745,#include <stdio.h>
15746,
15747,struct my_struct {
15748,    double        time_as_double;  // normally 8 byte alignment
15749,    char         *timezone;        // 8 byte alignment in 64bit architectures.
15750,    int           year;            // 4 byte alignment
15751,"    unsigned char month,           // one byte alignment"
15752,"                  mday,            // one byte alignment"
15753,"                  hour,            // one byte alignment"
15754,"                  min,             // one byte alignment"
15755,                  sec;             // one byte alignment
15756,    // seven more bytes of alignment to comply with 8 byte alignment for the
15757,    // full structure (to allow it to form arrays)
15758,};
15759,
15760,int main()
15761,{
15762,"    printf(""sizeof (struct my_struct) == %zu\n"", sizeof (struct my_struct));"
15763,}
15764,$ a.out
15765,sizeof (struct my_struct) == 32
15766,$ _
15767,include <stdbool.h>
15768,#include <math.h>
15769,bool is_prime(unsigned int num) {
15770,    bool result = false;
15771,    for (unsigned int i = 2; i <= sqrt(num); i++) {
15772,        if (num % i == 0) {
15773,            result = false; 
15774,        }
15775,        else {
15776,            result = true; 
15777,            
15778,        }
15779,    }
15780,    return result; 
15781,}
15782,
15783,
15784,bool is_ugly(unsigned int num) {
15785,    bool result = false; 
15786,    for (unsigned int i = 1; i <= num; i++) {
15787,        if (num % i == 0) {
15788,            if (is_prime(i)) {
15789,                if (i != 2 || i != 3 || i != 5) {
15790,                    result = false; 
15791,                    break; 
15792,                }
15793,                else {
15794,                    result = true; 
15795,                    break; 
15796,                }
15797,            }
15798,        }
15799,    }
15800,    return result; 
15801,}
15802,
15803,
15804,int main(void) {
15805,
15806,    bool result = is_ugly(30); // it must return true;  
15807,    return 0; 
15808,}
15809,i != 2 || i != 3 || i != 5
15810,i != 2 && i != 3 && i != 5
15811,result = true
15812,result=true;
15813,false
15814,is_prime
15815,bool is_ugly( unsigned int n ) 
15816,{
15817,    if ( n != 0 ) 
15818,    {
15819,"        n = max_divide( n, 2 );"
15820,"        n = max_divide( n, 3 );"
15821,"        n = max_divide( n, 5 );"
15822,    }
15823,
15824,    return n == 1'
15825,} 
15826,"unsigned int max_divide( unsigned int n, unsigned int divisor ) "
15827,{
15828,    if ( n != 0 ) 
15829,    {
15830,        while ( n % divisor == 0 ) 
15831,        {
15832,            n /= divisor;
15833,        }
15834,    }
15835,
15836,    return n;
15837,}
15838,#include <stdio.h>
15839,#include <stdlib.h>
15840,#include <string.h>
15841,
15842,#define N 10
15843,
15844,"void initWords(char *w1, char *w2, char *w3) {"
15845,"    printf(""Enter first word:\n"");"
15846,"    scanf(""%10s"", w1);"
15847,"    printf(""Enter second word:\n"");"
15848,"    scanf(""%10s"", w2);"
15849,"    printf(""Enter third word:\n"");"
15850,"    scanf(""%10s"", w3);"
15851,   
15852,}
15853,"char* concatWords(char *w1, char *w2, char *w3) {"
15854,    int len = strlen(w1) + strlen(w2) + strlen(w3);
15855,    w1 = (char*)malloc(sizeof(char) * len);
15856,"    strcat(w1, w2);"
15857,"    strcat(w1, w3);"
15858,    return w1;
15859,}
15860,
15861,void printReversedWord(char *word) {
15862,    int len = strlen(word);
15863,    for (int i = len - 1; i >=0; i--) {
15864,"        printf(""%c"", word);"
15865,    } 
15866,}
15867,
15868,int main()
15869,{
15870,    char word1[N+1];
15871,    char word2[N+1];
15872,    char word3[N+1];
15873,    char* longWord;
15874,"    initWords(word1, word2, word3);"
15875,"    longWord = concatWords(word1, word2, word3);"
15876,    printReversedWord(longWord);
15877,    free(longWord);
15878,    return 0;
15879,}
15880,strcat
15881,malloc
15882,calloc
15883,strcat
15884,strcpy
15885,w1[0] = '\0';
15886,malloc
15887,strcat
15888,strcat()
15889,strcpy()
15890,strcat()
15891,strlen()
15892,sizeof(char)
15893,len + 1
15894,w1
15895,w1
15896,"char *concatWords(char *w1, char *w2, char *w3) {"
15897,    size_t w1len = strlen(w1);
15898,    size_t w2len = strlen(w2);
15899,    size_t w3len = strlen(w3);
15900,
15901,    // the final result will be stored in memory pointed out by `res`:
15902,    char *res = malloc(w1len + w2len + w3len + 1);  // +1 for null terminator
15903,    if (res) {
15904,        // copy the three strings where they belong:
15905,"        memcpy(res, w1, w1len);"
15906,"        memcpy(res + w1len, w2, w2len);"
15907,"        memcpy(res + w1len + w2len, w3, w3len + 1); // +1 for null terminator"
15908,    }
15909,    return res;
15910,}
15911,printReversedWord
15912,word
15913,void printReversedWord(char *word) {
15914,    for (size_t i = strlen(word); i-- > 0;) {
15915,"        printf(""%c"", word[i]);                // <- here"
15916,    }
15917,}
15918,const
15919,w1 = (char*)malloc(sizeof(char) * len);
15920,"char * concatWords( const char *w1, const char *w2, const char *w3 ) "
15921,{
15922,    size_t len = strlen( w1 ) + strlen( w2 ) + strlen( w3 );
15923,    char *result = malloc( len  + 1 );
15924,
15925,    if ( result != NULL )
15926,    {
15927,"        strcpy( result, w1 );"
15928,"        strcat( result, w2 );"
15929,"        strcat( result, w3 );"
15930,    }
15931,
15932,    return result;
15933,}
15934,printReversedWord
15935,"printf(""%c"", word);"
15936,"printf(""%c"", word[i]);"
15937,void printReversedWord( const char *word ) 
15938,{
15939,    size_t len = strlen( word );
15940,
15941,    while ( len != 0 )
15942,    {
15943,        putchar( word[--len] );
15944,    }
15945,
15946,    putchar( '\n' );
15947,}
15948,"initWords( word1, word2, word3 );"
15949,
15950,"longWord = concatWords(word1, word2, word3);"
15951,
15952,if ( longWord != NULL ) printReversedWord(longWord);
15953,
15954,free( longWord );
15955,"char* concatWords(char *w1, char *w2, char *w3) {"
15956,    int len = strlen(w1) + strlen(w2) + strlen(w3);
15957,    w1 = (char*)malloc(sizeof(char) * len);
15958,"    strcat(w1, w2);"
15959,"    strcat(w1, w3);"
15960,    return w1;
15961,}
15962,"char* concatWords(const char* w1, const char* w2, const char* w3) {"
15963,    int len = strlen(w1) + strlen(w2) + strlen(w3);
15964,"    char* all = calloc(len + 1, sizeof(char));"
15965,"    strcat(all, w1);"
15966,"    strcat(all, w2);"
15967,"    strcat(all, w3);"
15968,    return all;
15969,}
15970,"char* concatWords(char *w1, char *w2, char *w3) {"
15971,    int len = strlen(w1) + strlen(w2) + strlen(w3);
15972,    w1 = (char*)malloc(sizeof(char) * len);
15973,"    strcat(w1, w2);"
15974,"    strcat(w1, w3);"
15975,    return w1;
15976,}
15977,w1
15978,w2
15979,w3
15980,w1
15981,w1 = (char*)malloc(sizeof(char) * len);
15982,w1
15983,w1
15984,+1
15985,w1
15986,w2
15987,w3
15988,(char *)
15989,char[]
15990,"w1 = realloc(w1, len+1);"
15991,concatWords()
15992,"char* concatWords(const char * const w1,"
15993,"                  const char * const w2,"
15994,                  const char * const w3) {
15995,    int len = strlen(w1) + strlen(w2) + strlen(w3) + 1; // Note the +1!
15996,    new_w = (char*)malloc(sizeof(char) * len);
15997,"    strcpy(new_w, w1);"
15998,"    strcat(new_w, w2);"
15999,"    strcat(new_w, w3);"
16000,    return new_w;
16001,}
16002,w1
16003,w2
16004,w3
16005,const
16006,const
16007,printReversedWord(char *word)
16008,word
16009,printf()
16010,"""%c"""
16011,i
16012,word
16013,word
16014,void printReversedWord(const char * const word) {
16015,    int len = strlen(word);
16016,    for (int i = len - 1; i >=0; i--) {
16017,"        printf(""%c"", word[i]);"
16018,    }
16019,"    printf(""\n""); // Don't forget the newline!"
16020,}
16021,[i]
16022,printf()
16023,char
16024,word
16025,#define N 10
16026,"void initWords(char *w1, char *w2, char *w3) {"
16027,"    printf(""Enter first word:\n"");"
16028,"    scanf(""%10s"", w1);"
16029,"    printf(""Enter second word:\n"");"
16030,"    scanf(""%10s"", w2);"
16031,"    printf(""Enter third word:\n"");"
16032,"    scanf(""%10s"", w3);"
16033,   
16034,}
16035,10
16036,scanf()
16037,"char* concatWords(char *w1, char *w2, char *w3) {"
16038,    char *p = (char*)malloc( (3*N+1) * sizeof *p );
16039,    if( p )
16040,"        sprintf( p, ""%s%s%s"", w1, w2, w3 );"
16041,
16042,    return p;
16043,}
16044,myFilter -params myParamFile myInputFile
16045,stdin
16046,argc
16047,argv
16048,main
16049,argc
16050,argv
16051,"typedef bool (*predicate)(void *data, void const *value);"
16052,
16053,"/** Copy to out the elements e of in having wanted(data, e) true, "
16054, *  returning the number of elements copied.
16055," *  Indexes 0 [inclusive] to n [exclusive] better be valid for in,"
16056, *  and out big enough. */
16057,"index filter_(predicate wanted, void *data, "
16058,"              void const *in, void *out, size_t n, size_t const element_size) {"
16059,    char const *cin = (char const *)in;
16060,    char *cout = (char *)out;
16061,"    for (index i = 0, o = 0 ; ; i++, cin += element_size) {"
16062,        if (n <= i)
16063,            return o;
16064,"        if (wanted(data, cin)) {"
16065,"            memcpy(cout, cin, element_size);"
16066,            out += element_size;
16067,        }
16068,    }
16069,/* return -1;  // not reached */
16070,}
16071,
16072,#define element_count(array) (sizeof (array)/sizeof (array)[0])
16073,"#define filter_array(wanted, in, out) filter(wanted, in, out, element_count(in))"
16074,"#define filter(wanted, in, out, n) filter_(wanted, in, out, n, sizeof *(in))"
16075,
16076,/* example predicate: */
16077,"bool greater(void *data, void *value) {"
16078,    return *(int*)value > *(int*)data;
16079,}
16080,char const *in = (char *)in;
16081,predicate
16082,int_predicate
16083,int_predicate
16084,#include <stdio.h>
16085,#include <pcap.h>
16086,
16087,"int main(int argc, char *argv[])"
16088,{
16089,    char errbuf[PCAP_ERRBUF_SIZE];
16090,
16091,    pcap_t *handle;
16092,"    handle = pcap_open_live(NULL, BUFSIZ, 1, 1000, errbuf);"
16093,    if (handle == NULL) {
16094,"        fprintf(stderr, ""Couldn't open devic: %s\n"", errbuf);"
16095,        return(2);
16096,    }
16097,
16098,    struct pcap_pkthdr header;
16099,    const u_char *packet;
16100,"    packet = pcap_next(handle, &header);"
16101,    /* Print its length */
16102,"    printf(""Jacked a packet with length of [%d]\n"", header.len);"
16103,    /* And close the session */
16104,    pcap_close(handle);
16105,
16106,    return(0);
16107,}
16108,wget https://github.com/the-tcpdump-group/libpcap/archive/libpcap-1.9.1.tar.gz
16109,tar zxf libpcap-1.9.1.tar.gz
16110,cd libpcap-libpcap-1.9.1
16111,CROSS_COMPILE=arm-linux-gnueabihf- CC=${CROSS_COMPILE}gcc ./configure --host=arm-linux-gnueabihf --prefix=$(pwd)/libpcap-1.9.1-arm-linux-gnueabihf
16112,CROSS_COMPILE=arm-linux-gnueabihf- CC=${CROSS_COMPILE}gcc make install
16113, arm-linux-gnueabihf-gcc program_pcap.c -lpcap -L./libpcap-libpcap-1.9.1/libpcap-1.9.1-arm-linux-gnueabihf/lib
16114,./libpcap-libpcap-1.9.1/libpcap-1.9.1-arm-linux-gnueabihf/lib/libpcap.so: file not recognized: file format not recognized
16115,collect2: error: ld returned 1 exit status
16116,LD=${CROSS_COMPILE}gcc
16117,./configure
16118,readelf
16119,file ./libpcap-libpcap-1.9.1/libpcap-1.9.1-arm-linux-gnueabihf/lib/libpcap.so
16120,int result;
16121,
16122,result = 125/100;
16123,result = 43/100;
16124,"""I just throw the dam fraction part in the trash and move on with life"""
16125,(a / b) * b + a % b == a
16126,a % b
16127,a
16128,a % b
16129,a
16130,b
16131,reliable integer division
16132,*-*
16133,expr1 / expr2
16134,expr1 % expr2
16135,expr1
16136,expr2
16137,-5 / 2 = -2
16138, 5 / 2 =  2
16139,filtered = (k - 1) * filtered + value + carry; carry = filtered % factor; filtered /= factor
16140,value
16141,k
16142,carry
16143,div
16144,factor
16145,filtered += (filter+(factor div 2)) div factor
16146,INT_MAX-(factor div 2)
16147,int integerDivisionResultPositive= 125/100;//= 1
16148,double flooringResultPositive= floor(125.0/100.0);//=1.0
16149,int integerDivisionResultNegative= -125/100;//=-1
16150,double flooringResultNegative= floor(-125.0/100.0);//=-2.0
16151,5 / 2 = 2
16152,5.0 / 2 or 5 / 2.0 or 5.0 /2.0 = 2.5
16153,(torch) mymachine:zvm myusername$ make && make check
16154,gcc -ansi -g -Wall -fPIC    -c -o cgfref.o cgfref.c
16155,gcc -ansi -g -Wall -fPIC    -c -o cggestal.o cggestal.c
16156,gcc -ansi -g -Wall -fPIC    -c -o cgmisc.o cgmisc.c
16157,gcc -ansi -g -Wall -fPIC    -c -o cgstream.o cgstream.c
16158,gcc -ansi -g -Wall -fPIC    -c -o cgstyle.o cgstyle.c
16159,gcc -ansi -g -Wall -fPIC    -c -o cgwindow.o cgwindow.c
16160,gcc -ansi -g -Wall -fPIC    -c -o cgschan.o cgschan.c
16161,gcc -ansi -g -Wall -fPIC    -c -o cgdate.o cgdate.c
16162,gcc -ansi -g -Wall -fPIC    -c -o cgunicod.o cgunicod.c
16163,gcc -ansi -g -Wall -fPIC    -c -o main.o main.c
16164,gcc -ansi -g -Wall -fPIC    -c -o gi_dispa.o gi_dispa.c
16165,gcc -ansi -g -Wall -fPIC    -c -o gi_blorb.o gi_blorb.c
16166,gcc -ansi -g -Wall -fPIC    -c -o gi_debug.o gi_debug.c
16167,gcc -ansi -g -Wall -fPIC    -c -o cgblorb.o cgblorb.c
16168,gcc -ansi -g -Wall -fPIC    -c -o glkstart.o glkstart.c
16169,gcc -shared -o libcheapglk.so cgfref.o cggestal.o cgmisc.o cgstream.o cgstyle.o cgwindow.o cgschan.o cgdate.o cgunicod.o main.o gi_dispa.o gi_blorb.o gi_debug.o cgblorb.o glkstart.o
16170,.................EEEEEEEEE
16171,======================================================================
16172,ERROR: testGestaltCharInputProvidesValidInformation (tests.glk_tests.CheapGlkTests)
16173,----------------------------------------------------------------------
16174,Traceback (most recent call last):
16175,"  File ""/Users/myusername/zvm/tests/glk_tests.py"", line 141, in setUp"
16176,    self.glkLib = glk_test_program.CheapGlkLibrary()
16177,"  File ""/Users/myusername/zvm/tests/glk_test_program.py"", line 26, in __init__"
16178,"    glk.GlkLib.__init__(self, lib_name)"
16179,"  File ""/Users/myusername/zvm/zvm/glk.py"", line 299, in __init__"
16180,    self._dll = ctypes.CDLL(lib_name)
16181,"  File ""/Users/myusername/opt/anaconda3/envs/torch/lib/python3.9/ctypes/__init__.py"", line 374, in __init__"
16182,"    self._handle = _dlopen(self._name, mode)"
16183,"OSError: dlopen(cheapglk/libcheapglk, 6): image not found"
16184,
16185,... (more similar errors)
16186,all:
16187,    @(cd cheapglk && make)
16188,
16189,clean:
16190,    @(cd cheapglk && make clean)
16191,
16192,check:
16193,    @python3 run_tests.py
16194,glk.py
16195,"    def __init__(self, lib_name):"
16196,"        """"""Instantiates the instance, binding it to the given shared"
16197,"        library (which is referenced by name)."""""""
16198,
16199,        self._dll = ctypes.CDLL(lib_name)
16200,libcheapglk.a
16201,ar rcs libcheapglk.a ...
16202,gcc --version
16203,Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/c++/4.2.1
16204,Apple clang version 12.0.0 (clang-1200.0.32.29)
16205,Target: x86_64-apple-darwin19.6.0
16206,Thread model: posix
16207,InstalledDir: /Library/Developer/CommandLineTools/usr/bin
16208,char* ptr;
16209,"strcpy(ptr, ""hello world""); // crash here!"
16210,char* ptr;
16211,"scanf(""%s"", ptr); // crash here!"
16212,{
16213,  int data = 0;
16214,  int* ptr = &data;
16215,  ...
16216,}
16217,int* ptr = malloc(sizeof(int));
16218,/*** examples of incorrect use of pointers ***/
16219,
16220,// 1.
16221,int* bad;
16222,*bad = 42;
16223,
16224,// 2.
16225,char* bad;
16226,"strcpy(bad, ""hello"");"
16227,/*** examples of correct use of pointers ***/
16228,
16229,// 1.
16230,int var;
16231,int* good = &var;
16232,*good = 42;
16233,
16234,// 2.
16235,char* good = malloc(5 + 1); // allocates memory for 5 characters *and*  the null terminator
16236,"strcpy(good, ""hello"");"
16237,NULL
16238,int* p1 = NULL; // pointer to nowhere
16239,"int* p2;        // uninitialized pointer, pointer to ""anywhere"", cannot be used yet"
16240,p2
16241,strcpy
16242,"char * strcpy ( char * destination, const char * source );"
16243,char* ptr = malloc(32);  
16244,"strcpy(ptr, ""hello world"");"
16245,char str[32];  
16246,"strcpy(str, ""hello world"");"
16247,"""%[^\t\n]s"""
16248,"""%[^ \t\n]s"""
16249,char *ptr = malloc(32);
16250,"scanf(""%31[^\n]"", ptr);"
16251,scanf()
16252,malloc()
16253,char ptr[5];
16254,"strcpy(ptr, 'hello'); // crash here!"
16255,"//            ^     ^   because of ' instead of """
16256,'h'
16257,"""h"""
16258,'h'
16259,\0
16260,int
16261,sizeof('h')
16262,sizeof(int)
16263,sizeof(char)
16264,1
16265,char h = 'h';
16266,"printf(""Size: %zu\n"", sizeof(h));     // Size: 1"
16267,"printf(""Size: %zu\n"", sizeof('h'));   // likely output: Size: 4"
16268,char* ptr
16269,malloc()
16270,calloc()
16271,dynamic memory allocation
16272,char* ptr;
16273,ptr = malloc(50); // allocate space for 50 characters.
16274,"strcpy(ptr, ""hello world"");"
16275,*ptr
16276,*ptr
16277,free()
16278,free(ptr);  // deallocating memory.
16279,realloc()
16280,"char *tmp = realloc(ptr, 100); // allocate space for 100 characters."
16281,if (! tmp) {
16282,"    // reallocation failed, ptr not freed"
16283,"    perror(""Resize failed"");"
16284,    exit(1);       
16285,}
16286,else {
16287,"    // reallocation succeeded, old ptr freed"
16288,    ptr = tmp;
16289,}
16290,malloc
16291,strlen
16292,strcpy
16293,strdup
16294,<string.h>
16295,free
16296,char* ptr;
16297,"ptr = strdup(""hello world"");"
16298,ptr[0] = 'H';
16299,puts(ptr);
16300,free(ptr);
16301,strdup
16302,read()
16303,read()
16304,write()
16305," int *findPeak(float *pArray, int length, int window, int *pCount) {"
16306,"     int i, j ,count = 0, toPositive = 0, toNegative = 0;"
16307,     float peak;
16308,     int *pPeakBuffer;
16309,"     bool firstZeroCross = false, toPositivePeak = false;"
16310,     int *peakBuffer = (int*)malloc(1*sizeof(int));
16311,    
16312,     for (i = 0; i < length; i += window) {
16313,         if (count == 0) {
16314,             peak = 0.0;
16315,             for (j = i; j < window; j++) {
16316,                 if (peak < pArray[j]) {
16317,                     peak = pArray[j];
16318,                     peakBuffer[count] = j;
16319,                 }          
16320,             }
16321,"             printf(""Peak = %d\n\r"", peakBuffer[count]);"
16322,             count++;
16323,         }
16324,         else {
16325,             peak = 0.0;
16326,"             peakBuffer = (int*)realloc(peakBuffer, 1*sizeof(int)); "
16327,             for (j = i; j < i+window; j++) {
16328,                 if (peak < pArray[j]) {
16329,                     peak = pArray[j];
16330,                     peakBuffer[count] = j;             
16331,                 }          
16332,             }
16333,"             printf(""Peak = %d\n\r"", peakBuffer[count]);"
16334,             count++;
16335,         }
16336,     }
16337,     *pCount = count;
16338,"     printf(""count = %d\n\r"", count);"
16339,     for (i = 0; i < count; i++)
16340,"         printf(""%d ,"", peakBuffer[i]);"
16341,"     printf(""\n\r"");"
16342,     return peakBuffer;
16343, }
16344,"realloc(peakBuffer, 1*sizeof(int))"
16345,realloc
16346,realloc
16347,NULL
16348,malloc
16349,realloc
16350,peakBuffer
16351,count
16352,peakBuffer[0]
16353,peakBuffer[1]
16354,peakBuffer[2]
16355,"int *findPeak( float *pArray, int length, int window, int *pCount ) {"
16356,"    int i, count = 0;"
16357,    int *pPeaks = NULL; // ALWAYS initiase pointers
16358,
16359,    for( i = 0; i < length; i += window ) {
16360,        int peak = i; // assume peak is the first one in this window
16361,
16362,        // scan window finding highest peak
16363,        // Notice that 'j' starts with index of beginning of window
16364,        // Notice limit to not run beyond length
16365,        for( int j = i; j < i + window && j < length; j++ )
16366,            if( pArray[ j ] > pArray[ peak ] ) // compare two floats values
16367,                peak = j; // remember higher peak
16368,
16369,        // get room to store this array index
16370,"        int *tmp = (int*)realloc( pPeaks, (count + 1) * sizeof *tmp );"
16371,        if( tmp == NULL ) {
16372,            /* deal with failure */
16373,            exit( EXIT_FAILURE );
16374,        }
16375,        pPeaks = tmp; // did not fail
16376,
16377,        pPeaks[ count++ ] = peak; // index relative to entire array
16378,    }
16379,
16380,    // Pointless because this version will find one peak in each window
16381,    // Could be calculated by dividing length by window
16382,    *pCount = count;
16383,"    printf( ""count = %d\n"", *pCount );"
16384,
16385,    for( i = 0; i < count; i++ )
16386,"        printf( ""%d, "", pPeaks[ i ] );"
16387,    putchar( '\n' );
16388,
16389,    return pPeaks;
16390,}
16391,#include <stdio.h>
16392,#include <string.h>
16393,
16394,int main(){
16395,"    char s[] = ""S\0C5AB"";"
16396,"    printf(""%s"", s);"
16397,"    printf(""%d"", sizeof(s)); // 7"
16398,"    printf(""  -- %d"", strlen(s)); // 1"
16399,}
16400,\0
16401,sizeof
16402,strlen
16403,\0
16404,int main(){
16405,"    char s[] = ""S\065AB"";"
16406,"    printf(""%s   "", s); // S5AB"
16407,"    printf(""--- %d"", sizeof(s)); // 5"
16408,"    printf(""  -- %d"", strlen(s)); // 4"
16409,}
16410,'\0'
16411,strlen
16412,"char s[] = ""S\0C5AB"";"
16413,"char s[] = { 'S', 0, 'C', '5', 'A', 'B', '\0' }; // 0 == '\0'. They are the same"
16414,"char s[] = ""S\065AB"";"
16415,"char s[] = { 'S', '5', 'A', 'B', '\0' }; // \065 ==> '5'"
16416,#include <stdio.h>
16417,main()
16418,{
16419,"    printf(""hello, world\n"");"
16420,}
16421,PATH
16422,"#include ""intstk.h"""
16423,#include <stdio.h>
16424,void intstk_init(intstk_t *s){
16425,    s->topstk = -1;
16426,    s->stack_array[STK_CAPACITY];
16427,}
16428,
16429,int intstk_nonempty(intstk_t *s){
16430,    if(s->topstk < 0){
16431,        return 0;
16432,    }else{
16433,        return 1;
16434,    }
16435,}
16436,
16437,int intstk_nonfull(intstk_t *s){
16438,    if(s->topstk >= STK_CAPACITY){
16439,        return 0;
16440,    }else{
16441,        return 1;
16442,    }
16443,}
16444,
16445,"void intstk_push(intstk_t *s, int value){"
16446,    s->topstk++;
16447,    s->stack_array[s->topstk] = value;
16448,}
16449,
16450,int intstk_pop(intstk_t *s){
16451,    s->topstk--;
16452,    return s->stack_array[s->topstk + 1];
16453,}
16454,
16455,void intstk_print(intstk_t *s){
16456,"    printf(""========== \n"");"
16457,    for(int i = s->topstk; i >= 0; i--){
16458,"        printf(""%d\n"",s->stack_array[i]);"
16459,    }
16460,"    printf(""==========\n"");"
16461,}
16462,#ifndef INTSTK_H
16463,#define INTSTK_H
16464,
16465,/* Defines the API for the limited-capacity integer stack */
16466,
16467,#define STK_CAPACITY 40
16468,
16469,typedef struct intstk_t {
16470,  /* STUDENTS: YOUR CODE HERE */
16471,  /* You need room to store STK_CAPACITY ints */
16472,  /* And you need to keep track of the top of the stack */
16473,  int stack_array[STK_CAPACITY];
16474,  int topstk;
16475,  
16476,} intstk_t;
16477,
16478,/************* Interface to the stack abstraction *************/
16479,/********* DO NOT CHANGE ANYTHING BELOW THIS LINE *************/
16480,
16481,"/* This must be called BEFORE calling ANY of the other functions,"
16482, * else their behavior is undefined
16483," * -- i.e., the program may do anything."
16484, * PRECONDITION: s is the address of a stack_t instance.
16485, * POSTCONDITION: ready for use
16486, */
16487,void intstk_init(intstk_t *s);
16488,
16489,
16490,/* Can pop() be safely called on the given stack?
16491," * I.e., is anything on this stack?"
16492, * PRECONDITION: s is the address of an initialized intstk_t instance.
16493, * POSTCONDITION: returns nonzero iff there is something on the stack.
16494, */
16495,int intstk_nonempty(intstk_t *s);
16496,
16497,
16498,/* Can push() be safely called on the given stack?
16499," * I.e., are there fewer than STACK_CAPACITY items on the stack?"
16500, * PRECONDITION: s is the address of an initialized intstk_t instance.
16501, * POSTCONDITION: returns nonzero iff another element can be pushed.
16502, */
16503,int intstk_nonfull(intstk_t *s);
16504,
16505,
16506,"/* Push a value of type ""int"" onto the given stack."
16507, * PRECONDITION: s is the address of an initialized intstk_t instance.
16508, *               s has fewer than STACK_CAPACITY items on it.
16509, * POSTCONDITION: value is the next value returned by pop() unless push()
16510, *               is called again
16511, */
16512,"void intstk_push(intstk_t *s, int value);"
16513,
16514,
16515,/* Remove the most recently push()ed value from this stack and return it.
16516, * PRECONDITION: s is the address of an initialized intstk_t instance AND
16517," *         s is nonempty, i.e., push() has been called more times than pop()."
16518, * POSTCONDITION: the top element has been removed and returned.
16519, */
16520,int intstk_pop(intstk_t *s);
16521,
16522,
16523,
16524,"/* Print the contents of the stack, one element per line starting at top;"
16525," * contents preceded and followed by ""=========="" on a line by itself."
16526, * PRECONDITION: s was initialized by calling intstk_init()
16527, * POSTCONDITION: contents of s have been printed in the order they would be
16528," *          returned by intstk_pop(), one per line."
16529, */
16530,void intstk_print(intstk_t *s); 
16531,
16532,#endif
16533,first.c
16534,intstk.h
16535,cc first.c -c
16536,s->stack_array[STK_CAPACITY];
16537,intstk_init(( )
16538,make
16539,Paulo;07352059067 (CPF)
16540,Joana;83307001000100 (CNPJ)
16541,"fscanf(fpointer, ""..."", nome, identificacao);"
16542,fscanf
16543,"'a', '(', '🍌'"
16544,0
16545,1
16546,2
16547,"'a'=0, '('=1, '🍌'=2"
16548,"'a'=2, '('=0, '🍌'=1"
16549,std::unordered_map
16550,etl::unordered_map
16551,unordered_map
16552,gperf
16553,FONT [97]
16554,FONT ['a']
16555,N * sizeof(table_element)
16556,N
16557,switch
16558,gperf
16559,switch
16560,const
16561,65536 * 16
16562,max_key * 16
16563,static char *strings[] = {
16564,"    ""word1"", ""word2"", ""hello"", ""world"", NULL, /* to end the array */"
16565,};
16566,
16567,int word_number(const char *word)
16568,{
16569,    for(int i = 0; strings[i] != NULL; i++) {
16570,"        if (strcmp(strings[i], word) == 0)"
16571,            return i;
16572,    }
16573,    return -1;  /* not found */
16574,}
16575,bsearch()
16576,static char *strings[] = { /* this time sorted */
16577,"    ""Hello"","
16578,"    ""rella"", /* this and the next are merged into positions on the same literal below"
16579,              * This can be controlled with a compiler option. */
16580,"    ""umbrella"","
16581,"    ""world"""
16582,};
16583,const int strings_len = 4;
16584,"int string_cmp(const void *_s1, const void *_s2)"
16585,{
16586,"    const char *s1 = _s1, *s2 = _s2;"
16587,"    return strcmp(s1, s2);"
16588,}
16589,
16590,int word_number(const char *word)
16591,{
16592,"    char *result = bsearch(strings, 4, sizeof *strings, string_cmp);"
16593,    return result ? result - strings : -1;
16594,}
16595,super_long_integer char2number(const unsigned char *s)
16596,{
16597,    super_long_integer result = 0;
16598,    int c;
16599,    while ((c = *s++) != 0) {
16600,        result *= 256;
16601,        result += c;
16602,    } 
16603,    return result;
16604,}
16605,"void writeHeader(FILE* file, struct Header* header){"
16606,"    char space[] = "" "";"
16607,"    char newLine[] = ""\n"";"
16608,
16609,"    fwrite(&header->magicNum[0], sizeof(char), 1, file);"
16610,"    fwrite(&header->magicNum[1], sizeof(char), 1, file);"
16611,"    fwrite(newLine, sizeof(char), 1, file);"
16612,
16613,"    fwrite(&(header->width), sizeof(int), 1, file);"
16614,"    fwrite(space, sizeof(char), 1, file);"
16615,"    fwrite(&header->height, sizeof(int), 1, file);"
16616,"    fwrite(newLine, sizeof(char), 1, file);"
16617,
16618,"    fwrite(&header->maxColor, sizeof(int), 1, file);"
16619,"    fwrite(newLine, sizeof(char), 1, file);"
16620,"    fwrite(space, sizeof(char), 1, file);"
16621,}
16622,fwrite()
16623,fprintf()
16624,(ch = character; sp = space)
16625,          ch ch ch --integer-- ch  --integer-- ch --intege
16626,          P  6  \n |width:5--| sp  |height:4-| \n |maxCol:
16627,00000000  50 36 0a 05 00 00 00 20  04 00 00 00 0a 03 00 00  |P6..... ........|
16628,00000010  00 0a 20                                          |.. |
16629,          3| \n sp
16630,          r- ch ch
16631,          ch ch ch ch ch ch ch ch  ch ch
16632,          P  6  \n 5  sp 4  \n 3   \n sp
16633,00000000  50 36 0a 35 20 34 0a 33  0a 20                    |P6.5 4.3. |
16634,#include <stdio.h>
16635,#include <string.h>
16636,
16637,"#define OUTFILE ""file.ppm"""
16638,
16639,struct Header {
16640,    char magicNum[3];
16641,    int width;
16642,    int height;
16643,    int maxColor;
16644,};
16645,
16646,"void writeHeader(FILE* file, struct Header* header)"
16647,{
16648,"    fprintf(file, ""%s\n"", header->magicNum);"
16649,"    fprintf(file, ""%d %d\n"", header->width, header->height);"
16650,"    fprintf(file, ""%d\n"", header->maxColor);"
16651,}
16652,
16653,int main()
16654,{
16655,    struct Header header;
16656,    FILE *fp;
16657,
16658,"    strcpy(header.magicNum, ""P6"");"
16659,    header.width = 1920;
16660,    header.height = 1080;
16661,    header.maxColor = 255;
16662,
16663,"    fp = fopen(OUTFILE, ""w"");"
16664,    if (fp == NULL) {
16665,        perror(OUTFILE);
16666,        exit(1);
16667,    }
16668,"    writeHeader(fp, &header);"
16669,
16670,    // write the ppm data to the file
16671,
16672,    return 0;
16673,}
16674,#include <stdio.h>
16675,
16676,// function to read a line
16677,"void read_line(char *line, int max_len) {"
16678,    int i = 0;
16679,    char c;
16680,    while ((c = getchar() != EOF) && i < max_len) {
16681,        line[i] = c;
16682,        i++;
16683,    }
16684,    line[i] = '\0';
16685,
16686,}
16687,
16688,int main()
16689,{
16690,    char line[100];
16691,"    read_line(line, 100);"
16692,"    printf(""%s\n"", line);"
16693,
16694,}
16695,'\n'
16696,read_line()
16697,"void read_line(char *line, int max_len) {"
16698,    int i = 0;
16699,
16700,    // EOF is an int... Need an int
16701,    // char c;
16702,    int c;
16703,
16704,    // misplaced parenthesis
16705,    //while ( (c = getchar() != EOF) && i < max_len) {
16706,
16707,    // What happens when user types too much?
16708,    // 'i' will be beyond the array end.
16709,    // while ( ( c = getchar() ) != EOF && i < max_len) {
16710,
16711,"    // Detect enter of NL (""return"") (rearranged somewhat)"
16712,    // while ( ( c = getchar() ) != EOF && i < max_len - 1) {
16713,
16714,    while ( ( c = getchar() ) != '\n' && c != EOF && i < max_len - 1) {
16715,        line[i] = c;
16716,        i++;
16717,    }
16718,    line[i] = '\0';
16719,}
16720,char line[ 100 + 1 ];
16721,"read_line( line, 100 );"
16722,fp
16723,&
16724,fp
16725,  #include <stdio.h>
16726,  #include <string.h>
16727,   
16728,  #define MAXLINES 5000
16729,  char *lineptr [MAXLINES];
16730,   
16731,"  int readlines(char *lineptr[], int nlines);"
16732,"  void writelines(char *lineptr[], int nlines);"
16733,   
16734,"  void my_qsort(void *lineptr[], int left, int right, int (*comp)(void *, void *));"
16735,"  int numcmp(char *, char *);"
16736,"  int reva(char *, char *);"
16737,"  int revn(char *, char *);"
16738,  
16739,  
16740,"  int main(int argc, char **argv) {"
16741,  
16742,          int nlines;
16743,          int numeric = 0;
16744,"          int (*fp)(void*, void*) = &strcmp;"
16745,  
16746,          if(argc > 1) {
16747,                  for(int i = argc; i > 1; i--) {
16748,"                          if(strcmp(argv[i-1], ""-n"") == 0)"
16749,                                  fp = &numcmp;
16750,"                          else if(strcmp(argv[i-1], ""-r"") == 0)"
16751,                                  fp = reva;
16752,"                          else if(strcmp(argv[i-1], ""-rn"") == 0 || strcmp(argv[i-1], ""-nr"") == 0)"
16753,                                  fp = revn;
16754,                          else {
16755,"                                  printf(""error: invalid modifier [%s]\n"", argv[i-1]);"
16756,                                  return -1;
16757,                          }
16758,                  }
16759,          }
16760,"          if((nlines = readlines(lineptr, MAXLINES)) >= 0) {"
16761,"                  my_qsort((void **) lineptr, 0, nlines-1, fp);"
16762,"                  writelines(lineptr, nlines);"
16763,                  return 0;
16764,          } else {
16765,"                  printf(""input too big to sort\n"");"
16766,                  return 1;
16767,          }
16768,  }
16769,  
16770,  
16771,"  void my_qsort(void *v[], int left, int right, int (*comp)(void *, void *)) {"
16772,  
16773,"          int i, last;"
16774,"          void swap(void *[], int, int);"
16775,  
16776,          if (left >= right)
16777,                  return;
16778,"          swap(v, left, (left+right)/2);"
16779,          last = left;
16780,          for(i = left+1; i <= right; i++)
16781,"                  if((*comp)(v[i], v[left]) < 0)"
16782,"                          swap(v, ++last, i);"
16783,"          swap(v, left, last);"
16784,"          my_qsort(v, left, last-1, comp);"
16785,"          my_qsort(v, last+1, right, comp);"
16786,  
16787,  }
16788,  
16789,  
16790,  #include <stdlib.h>
16791,  
16792,"  int numcmp(char *s1, char *s2) {"
16793,  
16794,"          double v1, v2;"
16795,  
16796,          v1 = atof(s1);
16797,          v2 = atof(s2);
16798,          if(v1 < v2)
16799,                  return -1;
16800,          else if(v1 > v2)
16801,                  return 1;
16802,          else
16803,                  return 0;
16804,  }
16805,  
16806,  
16807,"  int reva(char *s1,char *s2) {"
16808,"          return -strcmp(s1, s2);"
16809,  }
16810,  
16811,  
16812,"  int revn(char *s1, char *s2) {"
16813,"          return -numcmp(s1, s2);"
16814,  }
16815,  
16816,"  void swap(void *v[], int i, int j) {"
16817,  
16818,          void *temp;
16819,  
16820,          temp = v[i];
16821,          v[i] = v[j];
16822,          v[j] = temp;
16823,  }
16824,#include <stddef.h>
16825,#include <stdio.h>
16826,#include <string.h>
16827,
16828,"#include ""get_line.h"""
16829,
16830,#define MAXLEN 1000 // max length of any input line
16831,char *alloc(int);
16832,
16833,// readlines: read input lines
16834,"int readlines(char *lineptr[], int maxlines) {"
16835,
16836,"        int len, nlines;"
16837,        char line[MAXLEN];
16838,        char lines[maxlines*MAXLEN];
16839,        char *plines = lines;
16840,
16841,        nlines = 0;
16842,"        while((len = get_line(line, MAXLEN)) > 0)"
16843,                if(nlines >= maxlines)
16844,                        return -1;
16845,                else {
16846,                        line[len-1] = '\0'; // delete newline
16847,"                        strcpy(plines, line);"
16848,                        lineptr[nlines++] = plines;
16849,                        plines += len;
16850,                }
16851,        return nlines;
16852,}
16853,
16854,
16855,// writelines: write output lines
16856,"void writelines(char *lineptr[], int nlines) {"
16857,
16858,        int i;
16859,
16860,        for(i = 0; i < nlines; i++)
16861,"                printf(""%s\n"", lineptr[i]);"
16862,}
16863,#include <stdio.h>
16864,"#include ""get_line.h"""
16865,
16866,//getline: get line into line[]; return length
16867,"int get_line(char line[], int lim) {"
16868,
16869,"        int c, i;"
16870,
16871,        i = 0;
16872,        while(--lim > 0 && (c = getchar()) != EOF && c != '\n') {
16873,                line[i++] = c;
16874,        }
16875,        if(c == '\n') {
16876,                line[i++] = c;
16877,        }
16878,        line[i] = '\0';
16879,
16880,        return i;
16881,}
16882,"initialization of 'int (*)(void *, void *)' from incompatible pointer type 'int (*)(const char *, const char *) [-Wincompatible-pointer-types]"
16883,"assignment to 'int (*)(void *, void *)' from incompatible pointer type 'int (*)(char *, char *)' [-Wincompatible-pointer-types]"
16884,"initialization of ‘int (*)(void *, void *)’ from incompatible pointer type ‘int (*)(const char *, const char *)’ [-Werror=incompatible-pointer-types]"
16885,"int (*fp)(void *, void *) = &strcmp;"
16886,const void *
16887,&
16888,readlines
16889,"dlistint_t *add_dnodeint_end(dlistint_t **head, const int n)"
16890,{
16891,"     dlistint_t *head_ref, *new;"
16892,
16893,     new = malloc(sizeof(dlistint_t);
16894,     if (!new)
16895,          return (NULL);
16896,
16897,     new->n = n;
16898,     new->next = NULL;
16899,     new->prev = NULL;
16900,
16901,     if (!(*head))
16902,     {
16903,          *head = new;
16904,          return (new);
16905,     }
16906,
16907,     head_ref = *head;
16908,     while (head_ref)
16909,     {
16910,          if (!head_ref->next)
16911,          {
16912,               head_ref->next = new;
16913,               new->prev = head_ref;
16914,               /* I need clarity here */
16915,               head_ref = head_ref->next;
16916,          }
16917,          head_ref = head_ref->next;
16918,     }
16919,     return (new);
16920,}
16921,if
16922,while
16923,head_ref = head_ref->next;
16924,while
16925,break;
16926,head_ref = head_ref->next;
16927,if
16928,new->prev = head-ref;
16929,new->prev = head_ref;
16930,head_ref
16931,/* I need clarity here */
16932,return new;
16933,head_ref
16934,head_ref = head_ref->next
16935,if
16936,head_ref
16937,current
16938,"dlistint_t *add_dnodeint_end(dlistint_t **head, const int n)"
16939,{
16940,"     dlistint_t *current, *new;"
16941,
16942,     new = malloc(sizeof(dlistint_t)); // missing parenthesis
16943,     if (!new)
16944,          return NULL;
16945,
16946,     new->n = n;
16947,     new->next = NULL;
16948,     new->prev = NULL;
16949,
16950,     current = *head;
16951,     if (current == NULL)
16952,     {
16953,          *head = new;
16954,          return new;
16955,     }
16956,
16957,     while (current->next != NULL)  // Exit loop when at tail
16958,     {
16959,          current = current->next;
16960,     }
16961,     current->next = new;
16962,     new->prev = current;
16963,     return new;
16964,}
16965,hid_init
16966,hid_open
16967,hid_init
16968,#include <iostream>
16969,#include <thread>
16970,#include <hidapi/hidapi.h>
16971,
16972,"int main(int argc, char** argv) {"
16973,    hid_init();
16974,
16975,    std::thread thread([] { // line 8
16976,"        std::cout << ""thread start"" << std::endl;"
16977,
16978,"        hid_device* device = hid_open(0x45e, 0xb22, nullptr);"
16979,
16980,"        std::cout << ((device) ? ""device was not null"" : ""device was null"") << std::endl;"
16981,
16982,        hid_close(device);
16983,
16984,"        std::cout << ""thread finished"" << std::endl;"
16985,    }); // line 18
16986,
16987,    thread.join(); // line 20
16988,
16989,"    std::cout << hid_exit() << ""\n"";"
16990,}
16991,david@david-desktop:~/C/hidapi_test$ valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./untitled 
16992,"==65904== Memcheck, a memory error detector"
16993,"==65904== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."
16994,==65904== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
16995,==65904== Command: ./untitled
16996,==65904== 
16997,thread start
16998,device was null
16999,thread finished
17000,0
17001,==65904== 
17002,==65904== HEAP SUMMARY:
17003,==65904==     in use at exit: 60 bytes in 1 blocks
17004,"==65904==   total heap usage: 2,765 allocs, 2,764 frees, 690,526 bytes allocated"
17005,==65904== 
17006,==65904== 60 bytes in 1 blocks are definitely lost in loss record 1 of 1
17007,==65904==    at 0x484DA83: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
17008,==65904==    by 0x10B167: utf8_to_wchar_t (in /home/david/C/hidapi_test/untitled)
17009,==65904==    by 0x10C75B: hid_open (in /home/david/C/hidapi_test/untitled)
17010,==65904==    by 0x10A854: main::{lambda()#1}::operator()() const (main.cpp:11)
17011,"==65904==    by 0x10AD07: void std::__invoke_impl<void, main::{lambda()#1}>(std::__invoke_other, main::{lambda()#1}&&) (invoke.h:61)"
17012,==65904==    by 0x10ACCA: std::__invoke_result<main::{lambda()#1}>::type std::__invoke<main::{lambda()#1}>(main::{lambda()#1}&&) (invoke.h:96)
17013,==65904==    by 0x10AC77: void std::thread::_Invoker<std::tuple<main::{lambda()#1}> >::_M_invoke<0ul>(std::_Index_tuple<0ul>) (std_thread.h:253)
17014,==65904==    by 0x10AC4B: std::thread::_Invoker<std::tuple<main::{lambda()#1}> >::operator()() (std_thread.h:260)
17015,==65904==    by 0x10AC2F: std::thread::_State_impl<std::thread::_Invoker<std::tuple<main::{lambda()#1}> > >::_M_run() (std_thread.h:211)
17016,==65904==    by 0x4CE32C2: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30)
17017,==65904==    by 0x4EC7B42: start_thread (pthread_create.c:442)
17018,==65904==    by 0x4F58BB3: clone (clone.S:100)
17019,==65904== 
17020,==65904== LEAK SUMMARY:
17021,==65904==    definitely lost: 60 bytes in 1 blocks
17022,==65904==    indirectly lost: 0 bytes in 0 blocks
17023,==65904==      possibly lost: 0 bytes in 0 blocks
17024,==65904==    still reachable: 0 bytes in 0 blocks
17025,==65904==         suppressed: 0 bytes in 0 blocks
17026,==65904== 
17027,"==65904== For lists of detected and suppressed errors, rerun with: -s"
17028,==65904== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
17029,        /** @brief Initialize the HIDAPI library.
17030,
17031,            This function initializes the HIDAPI library. Calling it is not
17032,"            strictly necessary, as it will be called automatically by"
17033,            hid_enumerate() and any of the hid_open_*() functions if it is
17034,            needed.  This function should be called at the beginning of
17035,"            execution however, if there is a chance of HIDAPI handles"
17036,            being opened by different threads simultaneously.
17037,
17038,            @ingroup API
17039,
17040,            @returns
17041,                This function returns 0 on success and -1 on error.
17042,        */
17043,        int HID_API_EXPORT HID_API_CALL hid_init(void);
17044,/* USER CODE BEGIN PTD */
17045,#define NOJI_DEFAULT_ID 102
17046,
17047,/* USER CODE END PTD */
17048,/* USER CODE BEGIN 0 */
17049,uint8_t currentID = NOJI_DEFAULT_ID;
17050,CAN_TxHeaderTypeDef txHeader;
17051,CAN_RxHeaderTypeDef rxHeader;
17052,uint8_t txData[8];
17053,uint8_t rxData[8];
17054,uint32_t txMailbox;
17055,int dataCheck = 0;
17056,
17057,void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *Nhcan)
17058,{
17059,    static uint32_t count = 0;
17060,    count++;
17061,"    memset((void *) &rxHeader, 0, sizeof(CAN_RxHeaderTypeDef));"
17062,"    memset((void *) rxData, 0, 8);"
17063,"    HAL_CAN_GetRxMessage(Nhcan, CAN_RX_FIFO0, &rxHeader, rxData);"
17064,    if (rxHeader.DLC == 2)
17065,    {
17066,        dataCheck = 1;
17067,    }
17068,}
17069,/* USER CODE END 0 */
17070,  /* USER CODE BEGIN 2 */
17071,  HAL_StatusTypeDef status = HAL_OK;
17072,  CAN_FilterTypeDef canFilter;
17073,"  memset((void *) &canFilter, 0, sizeof(CAN_FilterTypeDef));"
17074,  canFilter.FilterActivation = CAN_FILTER_ENABLE;
17075,  canFilter.FilterBank = 10;
17076,  canFilter.FilterFIFOAssignment = CAN_RX_FIFO0;
17077,  canFilter.FilterIdHigh = currentID << 5;
17078,  canFilter.FilterMaskIdHigh = 0xFFE0;
17079,  canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
17080,  canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
17081,  canFilter.SlaveStartFilterBank = 18;
17082,"  status = HAL_CAN_ConfigFilter(&hcan1, &canFilter);"
17083,  status |= HAL_CAN_Start(&hcan1);
17084,"  status |= HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);"
17085,"  memset((void *) &txHeader, 0, sizeof(CAN_TxHeaderTypeDef));"
17086,  txHeader.IDE = CAN_ID_STD;
17087,  txHeader.RTR = CAN_RTR_DATA;
17088,  txHeader.StdId = currentID;   // 0x66
17089,  txHeader.DLC = 2;
17090,  txHeader.TransmitGlobalTime = DISABLE;
17091,"  memset((void *) txData, 0, 8);"
17092,  txData[0] = 0xD7;
17093,  txData[1] = 0xC3;
17094,"  status |= HAL_CAN_AddTxMessage(&hcan1, &txHeader, txData, &txMailbox);"
17095,  /* USER CODE END 2 */
17096,const double _NAN = 0.0/0.0;
17097,"""error C2124: divide or mod by zero"""
17098,NAN
17099,nan()
17100,char *
17101,"nan(""1"")"
17102,"nan(""0x800000"")"
17103,man 3 nan
17104,<math.h>
17105,NAN
17106,NAN
17107,float
17108,float
17109,double
17110,#if defined NAN
17111,NAN
17112,HUGE_VAL
17113,#include <float.h>
17114,#include <math.h>
17115,#include <stdio.h>
17116,
17117,static const double qnan = HUGE_VAL - HUGE_VAL;
17118,
17119,int main(void) {
17120,"    printf(""qnan = %g (%a) isnan(qnan) = %d\n"", qnan, qnan, isnan(qnan));"
17121,    return 0;
17122,}
17123,HUGE_VAL
17124,HUGE_VAL - HUGE_VAL
17125,assert(mynan != 0)
17126,"void check_pixel(int height, int width, int x, int y, RGBTRIPLE *store, "
17127,RGBTRIPLE *image)
17128,{
17129,    float sumRed = 0;
17130,    float sumGreen = 0;
17131,    float sumBlue = 0;
17132,
17133,"    //printf(""%p\n"", &image->rgbtRed);"
17134,
17135,
17136,    int pixel_count = 0;
17137,
17138,    for (int i = x - 1; i < x + 2; i++)
17139,    {
17140,        for (int j = y - 1; j < y + 2; j++)
17141,        {
17142,            if (i < 0 || i >= height || j < 0 || j >= width)
17143,            {
17144,                ;
17145,            }
17146,            else
17147,            {
17148,                sumRed += store->rgbtRed;
17149,                sumGreen += store->rgbtGreen;
17150,                sumBlue += store->rgbtBlue;
17151,                pixel_count++;
17152,            }
17153,        }
17154,    }
17155,
17156,    *image->rgbtRed = round(sumRed / pixel_count);
17157,    *image->rgbtGreen = round(sumGreen / pixel_count);
17158,    *image->rgbtBlue = round(sumBlue / pixel_count);
17159,
17160,    return;
17161,}
17162,
17163,
17164,// Blur image
17165,"void blur(int height, int width, RGBTRIPLE image[height][width])"
17166,{
17167,
17168,    RGBTRIPLE store[height][width];
17169,
17170,    for (int i = 0; i < height; i++)
17171,    {
17172,        for (int j = 0; j < width; j++)
17173,        {
17174,            store[i][j] = image[i][j];
17175,        }
17176,    }
17177,
17178,    //iterate through the height of the image
17179,    for (int x = 0; x < height; x++)
17180,    {
17181,        //iterate through the width of the image
17182,        for (int y = 0; y < width; y++)
17183,        {
17184,           
17185,"            check_pixel(height, width, x, y, &store[x][y], &image[x][y]);"
17186,
17187,        
17188,        }
17189,    }
17190,    return;
17191,}
17192,*image->rgbtRed = ....
17193,image->rgbtRed = ...; image->rgbtGreen = ... ; image->rgbtBlue = ... 
17194,< x + 2
17195,>=
17196,for (int i = x - 1; i <= x + 1; i++)
17197,if( )
17198,check_pixel
17199,i
17200,j
17201,i
17202,if
17203,for (int i = x - 1; i < x + 2; i++) { if ((i < 0) || (i >= height)) continue; for (int j = y - 1; j < y + 2; j++)
17204,j
17205,*image->rgbtRed = round(sumRed / pixel_count);
17206,*image->rgbtGreen = round(sumGreen / pixel_count);
17207,*image->rgbtBlue = round(sumBlue / pixel_count);
17208,image->rgbtRed = round(sumRed / pixel_count); 
17209,image->rgbtGreen = round(sumGreen / pixel_count);
17210,image->rgbtBlue = round(sumBlue / pixel_count);
17211,*image->x
17212,*(*image).x
17213,image
17214,struct
17215,*
17216,->
17217,struct
17218,cl
17219,cl
17220,cl
17221,/SUBSYSTEM:WINDOWS
17222,"/D""subsystem,windows"""
17223,/Dmwindows
17224,/Dsubsystem=gui
17225,-
17226,#ifdef _WIN32
17227,AllocConsole();
17228,"ShowWindow(GetConsoleWindow(), SW_HIDE);"
17229,#endif
17230,#include <gtk/gtk.h>
17231,
17232,"static void activate (GtkApplication * app, gpointer user_data)"
17233,{
17234,  GtkWidget * window;
17235,
17236,  window = gtk_application_window_new (app);
17237,"  gtk_window_set_title (GTK_WINDOW (window), ""Hello internet from Gtk Windows!"");"
17238,"  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);"
17239,  gtk_widget_show_all (window);
17240,}
17241,
17242,"int main (int argc, char ** argv)"
17243,{
17244,  GtkApplication * app;
17245,  int status;
17246,
17247,"  app = gtk_application_new (""org.gtk.example"", G_APPLICATION_FLAGS_NONE);"
17248,"  g_signal_connect (app, ""activate"", G_CALLBACK (activate), NULL);"
17249,"  status = g_application_run (G_APPLICATION (app), argc, argv);"
17250,  g_object_unref (app);
17251,
17252,  return status;
17253,}
17254,cl
17255,cl
17256,/SUBSYSTEM:WINDOWS
17257,#include <gtk/gtk.h>
17258,
17259,"static void activate (GtkApplication * app, gpointer user_data)"
17260,{
17261,  GtkWidget * window;
17262,
17263,  window = gtk_application_window_new (app);
17264,"  gtk_window_set_title (GTK_WINDOW (window), ""Hello internet from Gtk Windows!"");"
17265,"  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);"
17266,  gtk_widget_show_all (window);
17267,}
17268,
17269,#ifdef _WIN32
17270,"int WinMain (void * hInstance, void * hPrevInstance, char ** argv, int nCmdShow)"
17271,#else
17272,"int main (int argc, char ** argv)"
17273,#endif
17274,{
17275,  GtkApplication * app;
17276,  int status;
17277,
17278,"  app = gtk_application_new (""org.gtk.example"", G_APPLICATION_FLAGS_NONE);"
17279,"  g_signal_connect (app, ""activate"", G_CALLBACK (activate), NULL);"
17280,"  status = g_application_run (G_APPLICATION (app), 0, argv);"
17281,  g_object_unref (app);
17282,
17283,  return status;
17284,}
17285,argc
17286,g_application_run()
17287,"WinMain(HINSTANCE *, HINSTANCE *, char *, int) "
17288,/SUBSYSTEM:WINDOWS
17289,main
17290,#include <windows.h>
17291,void*
17292,HINSTANCE *
17293,"int WinMain (void * hInstance, void * hPrevInstance, char ** pCmdLine, int nCmdShow)"
17294,g_application_run()
17295,/SUBSYSTEM
17296,Windows
17297,main
17298,WinMain
17299,"WinMain(HINSTANCE *, HINSTANCE *, char *, int)"
17300,WinMain
17301,*
17302,HINSTANCE
17303,"int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow);"
17304,Windows.h
17305,hInstance
17306,hPrevInstance
17307,void *
17308,#include <ctype.h>
17309,#include <cs50.h>
17310,#include <stdio.h>
17311,#include <string.h>
17312,
17313,// Points assigned to each letter of the alphabet
17314,"int POINTS[] = {1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10};"
17315,
17316,int compute_score(string word);
17317,
17318,int main(void)
17319,{
17320,    // Get input words from both players
17321,"    string word1 = get_string(""Player 1: "");"
17322,"    string word2 = get_string(""Player 2: "");"
17323,
17324,    // Score both words
17325,    int score1 = compute_score(word1);
17326,    int score2 = compute_score(word2);
17327,
17328,    if (score1 > score2)
17329,    {
17330,"        printf(""Player 1 Wins!\n"");"
17331,    }
17332,    if (score1 < score2)
17333,    {
17334,"        printf(""Player 2 Wins!\n"");"
17335,    }
17336,    else
17337,    {
17338,"        printf(""Tie!\n"");"
17339,    }
17340,}
17341,
17342,int compute_score(string word)
17343,{
17344,    int score = 0;
17345,    int n = strlen(word);
17346,    for (int i = 0; i < n; i++)
17347,    {
17348,       //if letter is uppercase
17349,       if (isupper (word[i]))
17350,       {
17351,            POINTS[i] = word[i] - 65;
17352,            score += POINTS[i];
17353,       }
17354,       //if letter is lowercase
17355,       if (islower(word[i]))
17356,       {
17357,            POINTS[i] = word[i] - 97;
17358,            score += POINTS[i];
17359,       }
17360,        //if character is not a letter
17361,       else
17362,       {
17363,            i += 1;
17364,       }
17365,    }
17366,     return score;
17367,}
17368,i += 1;
17369,i
17370,for
17371,if (islower(word[i]))
17372,else if (islower(word[i]))
17373,else
17374,else
17375,i
17376,if/else
17377,main
17378,if
17379,if/else
17380,else if
17381,POINTS
17382,score += POINTS[ word[i] - 'A' ];
17383,int index = word[i] - 'A'; score += POINTS[index];
17384,'A'
17385,'a'
17386,compute_score
17387,POINTS
17388,        POINTS[i] = word[i] - 65;
17389,        POINTS[i] = word[i] - 97;
17390,const
17391,// Points assigned to each letter of the alphabet
17392,"const int POINTS[] = {1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10};"
17393,compute_score
17394,i
17395,        score += POINTS[i];
17396,   else
17397,   {
17398,        i += 1;
17399,   }
17400,int compute_score( string word )
17401,{
17402,    // Points assigned to each letter of the alphabet
17403,"    static const int POINTS[] = {1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10};"
17404,    const size_t N = sizeof( POINTS ) / sizeof( *POINTS );
17405,
17406,    int score = 0;
17407,
17408,    for ( ; *word; ++word )
17409,    {
17410,       //if letter is uppercase
17411,       if ( isupper( ( unsigned char )*word ) )
17412,       {
17413,            size_t i = *word - 'A';
17414,
17415,            if ( i < N ) score += POINTS[i];
17416,       }
17417,       //if letter is lowercase
17418,       else if ( islower( ( unsigned char )*word ) )
17419,       {
17420,            size_t i = *word - 'a';
17421,
17422,            if ( i < N ) score += POINTS[i];
17423,       }
17424,    }
17425,
17426,    return score;
17427,}
17428,if (score1 > score2)
17429,{
17430,"    printf(""Player 1 Wins!\n"");"
17431,}
17432,else if (score1 < score2)
17433,{
17434,"    printf(""Player 2 Wins!\n"");"
17435,}
17436,else
17437,{
17438,"    printf(""Tie!\n"");"
17439,}
17440,#include <stdio.h>
17441,#include <pthread.h>
17442,#include <unistd.h>
17443,#include <stdlib.h>
17444,#include <time.h>
17445,#include <sys/time.h>
17446,pthread_mutex_t lock;
17447,
17448,#define M 200
17449,#define N 300
17450,#define P 400
17451,#define X 2 // Number of Threads
17452,"#define RED ""\x1b[31m"""
17453,"#define GREEN ""\x1b[32m"""
17454,
17455,"int A[M][N], B[N][P], C[M][P], D[M][P];"
17456,
17457,int row = 0;
17458,
17459,void *matrixMulti(void *arg)
17460,{
17461,    pthread_mutex_lock(&lock);
17462,    int i = row++;
17463,
17464,    for (int j = 0; j < P; j++)
17465,    {
17466,        C[i][j] = 0;
17467,        for (int k = 0; k < N; k++)
17468,        {
17469,            C[i][j] += A[i][k] * B[k][j];
17470,        }
17471,    }
17472,
17473,    
17474,    pthread_exit(NULL);
17475,    pthread_mutex_unlock(&lock);
17476,}
17477,
17478,void matrixMultiplicationWithoutThreading();
17479,void matrixMultiplicationWithThreading();
17480,void verifyIfBothMatrixAreSame();
17481,int main()
17482,{
17483,"    int m, n, p;"
17484,"    // A: m*n Matrix, B: n*p Matrix"
17485,    for (int i = 0; i < M; i++)
17486,        for (int j = 0; j < N; j++)
17487,            A[i][j] = rand() % 10;
17488,"    // scanf(""%d"", &A[i][j]);"
17489,    for (int i = 0; i < N; i++)
17490,        for (int j = 0; j < P; j++)
17491,            B[i][j] = rand() % 10;
17492,"    // scanf(""%d"", &B[i][j]);"
17493,    
17494,"    struct timeval start, end;"
17495,"    gettimeofday(&start, NULL);"
17496,    matrixMultiplicationWithoutThreading();
17497,"    gettimeofday(&end, NULL);"
17498,    double time = (end.tv_sec - start.tv_sec) * 1e6;
17499,    time = (time + end.tv_usec - start.tv_usec) * 1e-6;
17500,"    printf(""The time taken by simple matrix calculation without threding is %0.6f\n"", time);"
17501,
17502,"    struct timeval start_th, end_th;"
17503,"    gettimeofday(&start_th, NULL);"
17504,    matrixMultiplicationWithThreading();
17505,"    gettimeofday(&end_th, NULL);"
17506,    time = (end_th.tv_sec - start_th.tv_sec) * 1e6;
17507,    time = (time + end_th.tv_usec - start_th.tv_usec) * 1e-6;
17508,"    printf(""The time taken by using the Threading Method with %d threads is %0.6f\n"", X, time);"
17509,
17510,    verifyIfBothMatrixAreSame();
17511,}
17512,
17513,void matrixMultiplicationWithThreading()
17514,{
17515,    pthread_t threads[X];
17516,    for (int i = 0; i < X; i++)
17517,    {
17518,        threads[i] = (pthread_t)-1;
17519,    }
17520,
17521,    // Computation Started:
17522,    for (int i = 0; i < M; i++)
17523,    {
17524,
17525,        // At any moment only X threads at max are working
17526,        if (threads[i] == (pthread_t)-1)
17527,"            pthread_create(&threads[i % X], NULL, matrixMulti, NULL);"
17528,        else
17529,        {
17530,"            pthread_join(threads[i % X], NULL);"
17531,"            pthread_create(&threads[i % X], NULL, matrixMulti, NULL);"
17532,        }
17533,    }
17534,    for (int i = 0; i < X; i++)
17535,"        pthread_join(threads[i], NULL);"
17536,    // Computation Done:
17537,}
17538,
17539,void matrixMultiplicationWithoutThreading()
17540,{
17541,    // Computation Started:
17542,    for (int i = 0; i < M; i++)
17543,        for (int j = 0; j < P; j++)
17544,        {
17545,            D[i][j] = 0;
17546,            for (int k = 0; k < N; k++)
17547,                D[i][j] += A[i][k] * B[k][j];
17548,        }
17549,    // Computation Done:
17550,}
17551,void verifyIfBothMatrixAreSame()
17552,{
17553,    for (int i = 0; i < M; i++)
17554,        for (int j = 0; j < P; j++)
17555,        {
17556,            if (C[i][j] != D[i][j])
17557,            {
17558,"                printf(RED ""\nMatrix's are not equal something wrong with the computation\n"");"
17559,                return;
17560,            }
17561,        }
17562,"    printf(GREEN ""\nBoth Matrixes are equal thus verifying the computation\n"");"
17563,}
17564,"pthread_create(&threads[i % X], NULL, matrixMulti, NULL)"
17565,#include <stdio.h>
17566,#include <pthread.h>
17567,#include <unistd.h>
17568,#include <stdlib.h>
17569,#include <time.h>
17570,#include <sys/time.h>
17571,#include <math.h>
17572,
17573,#define M 2
17574,#define N 2
17575,#define P 2
17576,#define X 40 // Number of Threads
17577,"#define RED ""\x1b[31m"""
17578,"#define GREEN ""\x1b[32m"""
17579,
17580,int t = 0; // Computation done by the first usedXFullthreads
17581,int usedXFull = 0;
17582,
17583,"int A[M][N], B[N][P], C[M][P], D[M][P];"
17584,
17585,int row = 0;
17586,
17587,void *matrixMulti(void *arg)
17588,{
17589,    int* l = (int *)arg;
17590,    int n = *l;
17591,"    int i = 0, j = 0, k = 0, comp = 0;"
17592,    if (n <= usedXFull)
17593,    {
17594,        i = n * t / (N * P);
17595,        j = (n * t - N * P * i) / N;
17596,        k = n * t - N * P * i - N * j;
17597,        if (n == usedXFull)
17598,            comp = M * N * P - usedXFull * t;
17599,        else
17600,            comp = t;
17601,    }
17602,    while (comp)
17603,    {
17604,        if (i == M)
17605,"            printf(RED ""Some fault in the code\n\n"");"
17606,        C[i][j] += A[i][k] * B[k][j];
17607,        comp--;
17608,        k++;
17609,        if (k == N)
17610,        {
17611,            j++;
17612,            if (j == P)
17613,            {
17614,                i++;
17615,                j = 0;
17616,            }
17617,            k = 0;
17618,        }
17619,    }
17620,
17621,    return NULL;
17622,}
17623,
17624,void matrixMultiplicationWithoutThreading();
17625,void matrixMultiplicationWithThreading();
17626,void verifyIfBothMatrixAreSame();
17627,int main()
17628,{
17629,"    int m, n, p;"
17630,"    // A: m*n Matrix, B: n*p Matrix"
17631,    for (int i = 0; i < M; i++)
17632,        for (int j = 0; j < N; j++)
17633,            A[i][j] = rand() % 10;
17634,"    // scanf(""%d"", &A[i][j]);"
17635,    for (int i = 0; i < N; i++)
17636,        for (int j = 0; j < P; j++)
17637,            B[i][j] = rand() % 10;
17638,"    // scanf(""%d"", &B[i][j]);"
17639,    for (int i = 0; i < M; i++)
17640,        for (int j = 0; j < P; j++)
17641,            C[i][j] = 0;
17642,
17643,"    struct timeval start, end;"
17644,"    gettimeofday(&start, NULL);"
17645,    matrixMultiplicationWithoutThreading();
17646,"    gettimeofday(&end, NULL);"
17647,    double time = (end.tv_sec - start.tv_sec) * 1e6;
17648,    time = (time + end.tv_usec - start.tv_usec) * 1e-6;
17649,"    printf(""The time taken by simple matrix calculation without threding is %0.6f\n"", time);"
17650,
17651,"    struct timeval start_th, end_th;"
17652,"    gettimeofday(&start_th, NULL);"
17653,    matrixMultiplicationWithThreading();
17654,"    gettimeofday(&end_th, NULL);"
17655,    time = (end_th.tv_sec - start_th.tv_sec) * 1e6;
17656,    time = (time + end_th.tv_usec - start_th.tv_usec) * 1e-6;
17657,"    printf(""The time taken by using the Threading Method with %d threads is %0.6f\n"", X, time);"
17658,
17659,    verifyIfBothMatrixAreSame();
17660,}
17661,
17662,void matrixMultiplicationWithThreading()
17663,{
17664,    int totalComp = M * N * P; // Total Computation
17665,    if ((double)totalComp / (double)X - (totalComp / X) > 0.5)
17666,        t = ceil((double)totalComp / (double)X);
17667,    else
17668,        t = floor((double)totalComp / (double)X);
17669,    if (t == 0)
17670,"        t++; // Takes care of the condition when if total number of comutation is less than the total threads, very unlikely"
17671,    usedXFull = totalComp / t;
17672,    int computationByLastUsedThread = totalComp - t * usedXFull;
17673,    int computationIndex[X];
17674,
17675,    pthread_t threads[X];
17676,
17677,    // Computation Started:
17678,    for (int i = 0; i < X; i++)
17679,    {
17680,            computationIndex[i] = i;
17681,"        int rc = pthread_create(&threads[i], NULL, matrixMulti, (void *)&computationIndex[i]);"
17682,        if (rc)
17683,        {
17684,"            printf(RED ""ERROR; return code from pthread_create() is %d\n"", rc);"
17685,            exit(-1);
17686,        }
17687,    }
17688,    for (int i = 0; i < X; i++)
17689,"        pthread_join(threads[i], NULL);"
17690,    // Computation Done:
17691,}
17692,
17693,void matrixMultiplicationWithoutThreading()
17694,{
17695,    // Computation Started:
17696,    for (int i = 0; i < M; i++)
17697,        for (int j = 0; j < P; j++)
17698,        {
17699,            D[i][j] = 0;
17700,            for (int k = 0; k < N; k++)
17701,                D[i][j] += A[i][k] * B[k][j];
17702,        }
17703,    // Computation Done:
17704,}
17705,void verifyIfBothMatrixAreSame()
17706,{
17707,    for (int i = 0; i < M; i++)
17708,        for (int j = 0; j < P; j++)
17709,        {
17710,            if (C[i][j] != D[i][j])
17711,            {
17712,"                printf(RED ""\nMatrix's are not equal something wrong with the computation\n"");"
17713,                return;
17714,            }
17715,        }
17716,"    printf(GREEN ""\nBoth Matrixes are equal thus verifying the computation\n"");"
17717,}
17718,pthread_t threads[X];
17719,threads[i]
17720,i
17721,for (int i = 0; i < M; i++)
17722,M
17723,pthread_exit(NULL)
17724,row
17725,i
17726,lock
17727,pthread_mutex_init
17728,pthread_exit
17729,matrixMulti
17730,threads[i]
17731,arg
17732,"[x, y] means all numbers from x to y including both x and y."
17733,"[x, y) means all numbers from x to y excluding y."
17734,"(x, y] means all numbers from x to y excluding x."
17735,"(x, y) means all numbers from x to y excluding both x and y."
17736,Sample Input:
17737,3 5
17738,Expected Output:
17739,0 1 2 3 4
17740,1 2 3 4 5
17741,2 3 4 5 6
17742,Explanation:
17743,"outerIterator=0, innerIterator=0 → 0+0 = 0"
17744,"outerIterator=0, innerIterator=1 → 0+1 = 1"
17745,"outerIterator=0, innerIterator=2 → 0+2 = 2"
17746,"outerIterator=0, innerIterator=3 → 0+3 = 3"
17747,"outerIterator=0, innerIterator=4 → 0+4 = 4"
17748,"outerIterator=1, innerIterator=0 → 1+0 = 1"
17749,"outerIterator=1, innerIterator=1 → 1+1 = 2"
17750,"outerIterator=1, innerIterator=2 → 1+2 = 3"
17751,"outerIterator=1, innerIterator=3 → 1+3 = 4"
17752,"outerIterator=1, innerIterator=4 → 1+4 = 5"
17753,"outerIterator=2, innerIterator=0 → 2+0 = 2"
17754,"outerIterator=2, innerIterator=1 → 2+1 = 3"
17755,"outerIterator=2, innerIterator=2 → 2+2 = 4"
17756,"outerIterator=2, innerIterator=3 → 2+3 = 5"
17757,"outerIterator=2, innerIterator=4 → 2+4 = 6//"
17758,i
17759,i + inner
17760,i
17761,for(out = 0; out < outerNumber; out++){
17762,  for(in = 0; in < innerNumber; in++){
17763,"    printf(""%d "",out + in);"
17764,  }
17765,"  printf(""\n"");"
17766,}
17767,for (i = 0 ; i<3 ; i++){
17768,
17769,    for (x = 0; x<5; x++){
17770,
17771,        printf i+x;
17772,    }
17773,
17774,}
17775,#include <stdio.h>
17776,#include <stdlib.h>
17777,
17778,int main()
17779,{
17780,"    int num, i;"
17781,
17782,"    printf(""Enter a Number: "");"
17783,"    scanf(""%d"", &num);"
17784,
17785,    for (i = 1; i <= num; i++);
17786,"    printf(""%d"", i);"
17787,
17788,    return 0;
17789,}
17790,for
17791,;
17792,for (i = 1; i <= num; i++);
17793,                          ^
17794,i
17795,if
17796,while
17797,-E
17798,-I
17799,-I
17800,e-acsl-gcc.sh
17801,-I
17802,-D
17803,-I dir
17804,-Idir
17805,e-acsl-gcc.sh
17806,-Idir
17807,"e-acsl-gcc.sh -E ""-Isrc/include -I..."" main.c"
17808,#include <stdio.h>
17809,int main(){
17810,"    int a=1,b=1;"
17811,    
17812,    while(a<=3)
17813,    {
17814,        b=1;
17815,        while(b<=3)
17816,        {   
17817,            if(a==2&&b==2)
17818,            continue;
17819,"            printf(""%d%d\n"",a,b);"
17820,            b++;
17821,        }
17822,    a++;
17823,    }
17824, return 0;
17825,}
17826,for
17827,continue
17828,b
17829,if (a==2&&b==2)
17830,continue
17831,while
17832,a
17833,b
17834,++b;
17835,if (a == 2 && b == 2){
17836,    continue;
17837,}
17838,while(b<=3){   
17839,  if(a == 2 && b == 2){
17840,    ++b;
17841,    continue;
17842,  }
17843,  printf(...);
17844,  ++b;
17845,}
17846,//array of string 
17847,#include<stdio.h>
17848,#include<stdlib.h>
17849,void main(){
17850,    char **strarray;
17851,    int arraylengh=10;
17852,    strarray = malloc(sizeof(char *) * arraylengh);
17853,"    strarray[4]=""ddddd"";"
17854,"    printf(""%s "", strarray[4]);"
17855,
17856,}
17857,malloc
17858,fsanitize=undefined
17859,strarray
17860,char*
17861,malloc
17862,strarray[4]
17863,printf
17864,"char *p = ""ddddd""; printf(""%s "", p);"
17865,"printf(""%s "", ""ddddd"");"
17866,int arraylengh=10;
17867,strarray = malloc(sizeof(char *) * arraylengh);
17868,char *
17869,"strarray[4]=""ddddd"";"
17870,"""ddddd"""
17871,strarray
17872,          +---------+
17873,strarray: |    *    |
17874,          +----|----+
17875,               |
17876,               |
17877,               v
17878,          +---------+
17879,          |  ?????  |
17880,          +---------+
17881,          |  ?????  |
17882,          +---------+
17883,          |  ?????  |
17884,          +---------+
17885,          |  ?????  |
17886,          +---------+        +---+---+---+---+---+----+
17887,          |    *-----------> | d | d | d | d | d | \0 |
17888,          +---------+        +---+---+---+---+---+----+
17889,          |  ?????  |
17890,          +---------+
17891,          |  ?????  |
17892,          +---------+
17893,          |  ?????  |
17894,          +---------+
17895,          |  ?????  |
17896,          +---------+
17897,          |  ?????  |
17898,          +---------+
17899,malloc
17900,strarray
17901,"""ddddd"""
17902,?????
17903,"""ddddd"""
17904,"strarray[4] = ""ddddd"";"
17905,"""ddddd"""
17906,strarray[4]
17907,"""ddddd"""
17908,"""ddddd"""
17909,"strarray[4]=""ddddd"""
17910,"""ddddd"""
17911,"char *str = ""ddddd"";"
17912,strarray[4] = str;
17913,"printf(""%p %p\n"", strarray[4], str);"
17914,"""ddddd"""
17915,"printf(""%p %p\n"", strarray[4], str);"
17916,"printf(""%p %p\n"", (void*)strarray[4], (void*)str);"
17917,strarray = malloc(sizeof(char *) * arraylengh);
17918,char *
17919,strarray -> ptr1 | ptr2 | ptr3 | ptr4...
17920,strarray[4]
17921,strarray[0]
17922,strarray[9]
17923,"strarray[4]=""ddddd"
17924,char *
17925,"char *a_string = ""ddddd"";"
17926,strarray[4]
17927,"""ddddd"""
17928,"""ddddd"""
17929,"FILE *input_file = fopen(argv[1], ""r"");"
17930,"FILE *output_file = fopen(argv[2], ""w"");"
17931,struct song {
17932,  int id;
17933,  int disc_id;
17934,  int length;
17935,  int rating;
17936,};
17937,typedef struct song Song;
17938,
17939,struct disc {
17940,  int id;
17941,  Song* songs;
17942,  int song_count;
17943,};
17944,typedef struct disc Disc;
17945,
17946,struct playlist_body {
17947,  int song_id;
17948,  int disc_id;
17949,  struct playlist* previous;
17950,  struct playlist* next;
17951,};
17952,typedef struct playlist_body Playlist;
17953,
17954,struct playlist_header {
17955,  int id;
17956,  int song_count;
17957,  Playlist* body;
17958,};
17959,typedef struct playlist_header Header;
17960,N_DISCS
17961,N_PLAYLISTS
17962,"Disc** all_discs = calloc(N_DISCS, sizeof(Disc*));"
17963,"Header** all_headers = calloc(N_PLAYLISTS, sizeof(Header*));"
17964,DISC_COUNTER
17965,"int capacity, length, rating;"
17966,"fscanf(input_file, ""%d"", &capacity);"
17967,
17968,all_discs[DISC_COUNTER] = malloc(sizeof(Disc));
17969,*all_discs[DISC_COUNTER] = (Disc){
17970,"  .id = DISC_COUNTER,"
17971,"  .songs = calloc(capacity, sizeof(Song)),"
17972,  .song_counter = capacity
17973,};
17974,
17975,for(int id = 0; id < capacity; id += 1){
17976,"  fscanf(input_file, ""%d %d"", &length, &rating);"
17977,
17978,  all_discs[DISC_COUNTER]->songs[id] = (Song){
17979,"    .id = id,"
17980,"    .disc_id = DISC_COUNTER,"
17981,"    .length = length,"
17982,    .rating = rating
17983,  };
17984,"  fprintf(output, ""SONG ADDED %i %i\n"", id, DISC_COUNTER);"
17985,"  printf(""SONG ADDED %i %i\n"", id, DISC_COUNTER);"
17986,};
17987,DISC_COUNTER += 1
17988,"SONG ADDED songID discID"""
17989,SONG ADDED 0 9
17990,SONG
17991,scanf
17992,if (temp->next != NULL){
17993,"        if (strcmp(temp->next->parola, ""\0"") != 0 && strcmp(parola, ""\0"") != 0){"
17994,"            while (strcmp(parola, temp->next->parola) != 0){"
17995,                if(temp->next != NULL){
17996,"                    if (strcmp(temp->next->parola, ""\0"") != 0 && strcmp(parola, ""\0"") != 0){"
17997,                        temp = temp->next;
17998,                    } else {break;}
17999,                } else {break;}
18000,            }
18001,        }
18002,    }
18003,temp->next->parola
18004,temp->next
18005,temp->next
18006,while
18007,temp = temp->next
18008,"strcmp(parola, temp->next->parola)"
18009,temp->next
18010,while
18011,if
18012,temp = temp->next
18013,temp = temp->next
18014,"strcmp(parola, temp->next->parola"
18015,temp->next != NULL
18016,if (temp->next != NULL){
18017,"    if (strcmp(temp->next->parola, ""\0"") != 0 && strcmp(parola, ""\0"") != 0){"
18018,"        while (strcmp(parola, temp->next->parola) != 0){"
18019,"                    if (strcmp(temp->next->parola, ""\0"") != 0 && strcmp(parola, ""\0"") != 0){"
18020,                        temp = temp->next;
18021,                if(temp->next != NULL){
18022,                    } else {break;}
18023,                } else {break;}
18024,            }
18025,        }
18026,}
18027,properties[0].cb;
18028,#include <stdio.h>
18029,#include <stdbool.h>
18030,
18031,struct property {
18032,    const char* key;
18033,    void (*cb)(void);
18034,    bool last_status;
18035,};
18036,
18037,
18038,void is_property1_true(void){
18039,"    printf(""PROP 1 True\n"");"
18040,}
18041,
18042,void is_property2_true(void){
18043,"    printf(""PROP 2 True\n"");"
18044,}
18045,
18046,struct property properties[2] = {
18047,"    {""KEY1"", is_property1_true, true},"
18048,"    {""KEY2"", is_property2_true, false},"
18049,    
18050,};
18051,
18052,int main()
18053,{
18054,"    properties[0].cb; //Does not print ""PROP 1 True"""
18055,    return 0;
18056,}
18057,properties[0].cb();
18058,"void englishToMatte(char englishSentence[], char matteSentence[])"
18059,{
18060,    char** word = splitIntoWords(englishSentence);
18061,    char *p;
18062,"    int vowels[] = {'a', 'e', 'i', 'o', 'u'};"
18063,    int i;
18064,    char** it;
18065,    char dest[100];
18066,
18067,    for(it=word; it && *it; ++it){
18068,        for(i = 0; i < 5; i++){
18069,"            if((p = strchr(*it, vowels[i])) != NULL){"
18070,                *p = 'i';
18071,                break;
18072,            }
18073,        }
18074,"        strcat(dest, *it);"
18075,"        strcat(dest, "" "");"
18076,        free(*it);
18077,    }
18078,    /*puts(dest);*/ /*for debugging*/
18079,"    strcpy(matteSentence, dest); "
18080,
18081,    free(word);
18082,}
18083,char**
18084,it
18085,*it
18086,for(int i=0; (*it)[i]!=0; i++){ ... }
18087,char *myString=*it;
18088,myString
18089,*it
18090,#include <stdio.h>
18091,#include <stdlib.h>
18092,#include <string.h>
18093,
18094,"char *smpl = ""Quick brown foxes jump over flower yellow & Unicorns"";"
18095,"char *wordSep = "" "";"
18096,
18097,int main() {
18098,    int len = strlen( smpl );
18099,"    printf( ""Orginal string: '%s' (%d chars)\n"", smpl, len );"
18100,    
18101,"    // Count the words in the ""sentence"""
18102,    char *pBuf = strdup( smpl );
18103,    int nWord = 0;
18104,"    for( char *cp = pBuf; (cp = strtok( cp, wordSep ) ) != NULL; cp = NULL )"
18105,        nWord++;
18106,"    printf( ""%d \""words\""\n"", nWord );"
18107,"    strcpy( pBuf, smpl); // reload"
18108,
18109,    // create output buffer large enough for expansion.
18110,"    char *oBuf = (char*)calloc( len + nWord*4 + 1, sizeof(char) );"
18111,    // calloc NEVER returns null pointer
18112,
18113,    char *at = oBuf;
18114,"    for( char *pWord = pBuf; (pWord = strtok( pWord, wordSep ) ) != NULL; pWord = NULL ) {"
18115,        char *init = pWord; // beginning of word
18116,"        char *vwl1 = strpbrk( init, ""AEIOUaeiou"" ); // first vowel of word"
18117,
18118,        if( vwl1 == NULL ) { // all consonants!
18119,"            at += sprintf( at, ""%s "", init );"
18120,            continue;
18121,        }
18122,"        if( vwl1 == init ) { // eg: ""Unicorn"""
18123,"            *at++ = ""iI""[ isupper( *vwl1 ) ]; // 'i' matching the case"
18124,"            at += sprintf( at, ""%s-ee "", init + 1 );"
18125,            continue;
18126,        }
18127,"        *at++ = ""iI""[ isupper( *vwl1 ) ]; // 'i' matching the case"
18128,        *vwl1 = '\0';
18129,"        at += sprintf( at, ""%s-%see "", vwl1 + 1, init );"
18130,    }
18131,
18132,    puts( oBuf );
18133,    free( oBuf );
18134,    free( pBuf );
18135,
18136,    return 0;
18137,}
18138,Orginal string: 'Quick brown foxes jump over flower yellow & Unicorns' (52 chars)
18139,"9 ""words"""
18140,iick-Qee iwn-bree ixes-fee imp-jee iver-ee iwer-flee illow-yee & Inicorns-ee
18141,for(it=word; it && *it; ++it){
18142,    myString=*it;
18143,    for(int i=0; (*it)[i]!=0; i++){
18144,        if(myString[i]=='a' ||myString[i]=='e' ||myString[i]=='i' ||myString[i]=='o' ||myString[i]=='u'){
18145,            myString[i] = 'i';
18146,            break;
18147,        }
18148,    }
18149,"    strcat(dest, *it);"
18150,"    strcat(dest, "" "");"
18151,    free(*it);
18152,}
18153,(*it)[i]!=0
18154,myString[i]
18155,"strcat(dest, myString);"
18156,free(myString);
18157,dest
18158,strcat
18159,int Q1 = {'193'};
18160,int Ans1;
18161,"scanf(""%d"", &Ans1);"
18162,if (Ans1 = Q1){
18163,"    printf(""Correct!"");"
18164,}
18165,else {
18166,"    printf(""WRONG!"");"
18167,}
18168,=
18169,==
18170,193
18171,{'193'}
18172,int Q1 = 193;
18173,"int Q1[] = {193, 913};"
18174,Ans1 == Q1[0]
18175,#include <stdio.h>
18176,#include <string.h>
18177,#include <stdlib.h>
18178,
18179,"static void sort_a(void *array, unsigned n);"
18180,"static int cmpr(const void *a, const void *b);"
18181,
18182,int main(void)
18183,{
18184,"    static const char filename[] = ""input.txt"";"
18185,"    static const char filename_out[] = ""output.txt"";"
18186,
18187,    int i = 0;
18188,    int j = 0;
18189,"    FILE *file = fopen(filename, ""r"");"
18190,"    FILE *file_write = fopen(filename_out, ""w"");"
18191,
18192,    char line[16];
18193,    char *line_array[1000001]; //works sub 1 Million
18194,
18195,    if (file != NULL){
18196,"        while (fgets(line, sizeof line, file) != NULL) {"
18197,            // Trim the newline character
18198,"            line[strcspn(line, ""\n"")] = '\0';"
18199,
18200,            // Stop processing if line_array is full
18201,            if (i < sizeof line_array / sizeof *line_array) {
18202,                line_array[i++] = strdup(line);
18203,            }
18204,            else {
18205,                break;
18206,            }
18207,        }
18208,        fclose(file);
18209,
18210,"        sort_a(line_array, i);"
18211,
18212,        for (j = 0; j < i; j++) {
18213,"            fprintf(file_write, ""%s\n"", line_array[j]);"
18214,        }
18215,        fclose(file_write);
18216,
18217,        // Clean up memory
18218,        for (j = 0; j < i; j++) {
18219,            free(line_array[j]);
18220,        }
18221,    }
18222,    else {
18223,        perror(filename);
18224,    }
18225,    return 0;
18226,}
18227,
18228,"int cmpr(const void *a, const void *b) {"
18229,"    return (strcmp(*(char **)a, *(char **)b));"
18230,}
18231,
18232,"void sort_a(void *array, unsigned n) {"
18233,"    qsort(array, n, sizeof(const char *), cmpr);"
18234,}
18235,malloc()
18236,malloc()
18237,static
18238,malloc
18239,malloc()
18240,char **line_array;
18241,line_array = malloc(cur_max_lines * sizeof *line_array);
18242,realloc
18243,realloc
18244,typedef struct xfs_ifork {
18245,   int         if_bytes;   /* bytes in if_u1 */
18246,   int         if_real_bytes;  /* bytes allocated in if_u1 */
18247,   struct xfs_btree_block  *if_broot;  /* file's incore btree root */
18248,   short           if_broot_bytes; /* bytes allocated for root */
18249,   unsigned char       if_flags;   /* per-fork flags */
18250,   union {
18251,       xfs_bmbt_rec_host_t *if_extents;/* linear map file exts */
18252,       xfs_ext_irec_t  *if_ext_irec;   /* irec map file exts */
18253,       char        *if_data;   /* inline file data */
18254,   } if_u1;
18255,   union {
18256,       xfs_bmbt_rec_host_t if_inline_ext[XFS_INLINE_EXTS];
18257,                       /* very small file extents */
18258,       char        if_inline_data[XFS_INLINE_DATA];
18259,                       /* very small file data */
18260,       xfs_dev_t   if_rdev;    /* dev number if special */
18261,       uuid_t      if_uuid;    /* mount point value */
18262,   } if_u2;
18263,} xfs_ifork_t;
18264,if_flags
18265,#include<stdio.h>
18266,int main() {
18267,
18268,    char shape;
18269,    double area;
18270,    const double PI = 3.1415;
18271,
18272,"    printf(""Enter 'c' for circle, 'r' for rectangle or 't' for triangle to find the area :"");"
18273,"    scanf(""%c"", &shape);"
18274,
18275,    switch (shape) {
18276,        case 'c':
18277,"            printf(""Enter the radius of the circle :"");"
18278,            int rad;
18279,"            scanf(""%d"", &rad);"
18280,
18281,            area = PI * rad * rad;
18282,            break;
18283,
18284,        case 'r':
18285,"            printf(""Enter width and height of the rectangle :"");"
18286,"            int width, height;"
18287,"            scanf(""%d %d"", &width, &height);"
18288,
18289,            area = width * height;
18290,            break;
18291,
18292,        case 't':
18293,"            printf(""Enter the length of base and perpendicular height of the triangle :"");"
18294,"            int base, p_height;"
18295,"            scanf(""%d %d"", &base, &p_height);"
18296,
18297,            area = 0.5 * base * p_height;
18298,            break;
18299,
18300,        default:
18301,"            printf(""Invalid input.. Try again!!\n"");"
18302,            return 0;
18303,    }
18304,
18305,"    printf(""The area :%.2lf"", area);"
18306,    return 0;
18307,
18308,}
18309,printf
18310,\n
18311,1
18312,21
18313,321
18314,for (int i = 0 ; i <= num; i++) {
18315,      int temp = i;
18316,      for (int j = 0; j < i; j++){
18317,"            printf(""%d"", temp);"
18318,            temp--;
18319,      }
18320,"      printf(""\n"");"
18321,}
18322,"fputs(""1\n21\n321\n"", stdout)"
18323,"char *t = ""987654321""; for( char *s = t + 8; ...; s--) puts(s);"
18324,321
18325,321
18326,10
18327,1
18328,10
18329,int main()
18330,{
18331,    int num = 3;
18332,    char buffer[100] = {0};
18333,    char temp_buffer[200] = {0};
18334,
18335,    for (int i = 1 ; i <= num; i++) {
18336,"        sprintf(temp_buffer, ""%d%s"", i, buffer);"
18337,"        printf(""%s\n"", temp_buffer);"
18338,"        strcpy(buffer, temp_buffer);"
18339,    }
18340,    
18341,    return 0;
18342,}
18343,for(int i=0; i<n; i++)
18344,for
18345,for
18346,for
18347,n
18348,3
18349,for
18350,0
18351,10
18352,cols < (rows+1)
18353,rows+1
18354,(rows+1) - cols
18355,
18356,Ui08 *pointerSomething;
18357,Ui64 localVariable;
18358,
18359,pointerSomething=&addressOfSomething;
18360,localVariable = *(Ui64*)(pointerSomething);
18361,thread begin //
18362,
18363,Ui08 *pointerSomething;
18364,Ui64 localVariable;
18365,
18366,case 3: 
18367,
18368,   pointerSomething=&addressOfSomething;
18369,   localVariable = *(Ui64*)(pointerSomething);
18370,
18371,break;
18372,
18373,thread end //
18374,localVariable = *(Ui64*)(pointerSomething);
18375,thread begin //
18376,
18377,Ui08 *pointerSomething;
18378,Ui64 localVariable;
18379,
18380,case 3: 
18381,
18382,   pointerSomething=&addressOfSomething;
18383,"   memcpy( &localVariable, pointerSomething, sizeof(localVariable) );"
18384,
18385,break;
18386,
18387,thread end //
18388,sizeof localVariable
18389,pointerSomething
18390,addressOfSomething
18391,Ui64
18392,memcpy
18393,LDRD
18394,LDRD
18395,case 3: 
18396,
18397,   if((uint32_t)pointerSomething & 3)
18398,   {
18399,       __BKPT();
18400,   }
18401,   localVariable = *(Ui64*)(pointerSomething);
18402,child process
18403,fork
18404,thread
18405,#include <errno.h>
18406,#include <signal.h>
18407,#include <stdio.h>
18408,#include <stdlib.h>
18409,#include <sys/types.h>
18410,#include <sys/wait.h>
18411,#include <unistd.h>
18412,
18413,volatile sig_atomic_t runChild = 0;
18414,
18415,
18416,"static void handler(int signum, siginfo_t *sinfo, void *unused){"
18417,
18418,    if (signum == SIGUSR1) {
18419,"        printf(""SIGUSR1 received\n"");"
18420,        runChild = 1;
18421,    }
18422,}
18423,
18424,"int main(int argc, char *argv[]) {"
18425,
18426,"    char *newArgv[] = {""myecho"", ""hello"", ""world"", NULL};"
18427,"    char *newEnviron[] = { ""MY_NAME=jcarlosweb"", NULL };"
18428,
18429,    struct sigaction sa;
18430,    sa.sa_flags =0;
18431,    sigemptyset(&sa.sa_mask);
18432,
18433,    sa.sa_sigaction = handler;
18434,"    if (sigaction(SIGUSR1, &sa, NULL) == -1) {"
18435,"        perror(""sigaction"");"
18436,        exit(EXIT_FAILURE);
18437,    }
18438,
18439,    pid_t pid = fork();
18440,
18441,    if (pid == -1) {
18442,"        perror(""fork"");"
18443,        exit(EXIT_FAILURE);
18444,    }
18445,
18446,    if (pid == 0) {
18447,        while (!runChild) {
18448,            usleep(200);
18449,        }
18450,        runChild = 0;
18451,"        execve(""./process-pipe-fork/execve/myecho"", newArgv, newEnviron);"
18452,        /* The execve function returns only if an error occurs. */
18453,"        perror(""An error occurred in execve"");"
18454,        abort();
18455,    }
18456,    
18457,    // continue execution of parent process without waiting for child process to finish
18458,"    waitpid(-1, NULL, WNOHANG);"
18459,
18460,"    printf(""Run myecho:\n"");"
18461,"    kill(pid,SIGUSR1);"
18462,
18463,    sleep(3);
18464,
18465,"    printf(""Run myecho:\n"");"
18466,"    kill(pid,SIGUSR1);"
18467,
18468,"    printf(""Done\n"");"
18469,
18470,    exit(EXIT_SUCCESS);
18471,}
18472,execve
18473,myecho
18474,exec
18475,"waitpid(-1, NULL, WNOHANG);"
18476,waitpid
18477,waitpid
18478,WNOHANG
18479,#include <err.h>
18480,#include <errno.h>
18481,#include <unistd.h>
18482,int main(void) {
18483,    char ch;
18484,    int fd[2];
18485,    pid_t pid;
18486,    ssize_t ret;
18487,
18488,    pipe(fd); /* to block on */
18489,
18490,    pid = fork();
18491,    if (pid < 0) {
18492,"        err(1, ""fork failed"");"
18493,    } else if (pid == 0) { /* child */
18494,        close(fd[1]);
18495,"        warnx(""child  %d start"", getpid());"
18496,        /* block until parent goes away */
18497,"        ret = read(fd[0], &ch, 1);"
18498,"        warnx(""child  %d is go"", getpid());"
18499,        close(fd[0]);
18500,        /* child now does things here ... */
18501,    } else { /* parent */
18502,        sleep(3);
18503,        close(fd[0]);
18504,        close(fd[1]);
18505,        /* parent does more things here ... */
18506,    }
18507,    return 0;
18508,}
18509,write
18510,fd[1]
18511,close
18512,volatile
18513,man semop
18514,man shmop
18515,man mmap
18516,pthread_create(3)
18517,pthread_mutex(3)
18518,semop(2)
18519,mmap(2)
18520,pipe(2)
18521,fork()
18522,output.txt
18523,#include <sys/types.h>
18524,#include <sys/wait.h>
18525,#include <stdio.h>
18526,#include <stdlib.h>
18527,#include <unistd.h>
18528,
18529,int main()
18530,{
18531,    int fd[2];
18532,
18533,"    /* we need to get the pipe before fork() so we have it in both,"
18534,     * parent and child. */
18535,    int res = pipe(fd);
18536,    if (res < 0) {
18537,"        perror(""pipe"");"
18538,        exit(1);
18539,    }
18540,
18541,    int child_pid = fork();
18542,
18543,    if (child_pid < 0) {
18544,"        perror(""fork"");"
18545,        exit(1);
18546,    }
18547,    /* both processes get here. */
18548,    if (child_pid == 0) { /* we are the child only */
18549,        close(fd[1]); /* we are not using the writing end */
18550,"        FILE *out = fopen(""output.txt"", ""a+"");"
18551,"        FILE *f   = fdopen(fd[0], ""r"");"
18552,        int   c;
18553,        while ((c = fgetc(f)) != EOF) {
18554,            /* print an hex representation of char */
18555,"            fprintf(out, ""<%02x>"", c);"
18556,        }
18557,        /* let's close both */
18558,        fclose(out); fclose(f);
18559,"        /* remember the child gets 0 from fork, so it needs to"
18560,         * call getpid() syscall to get its pid. */
18561,"        printf(""Child (pid=%d) exiting.\n"", getpid());"
18562,        exit(0);
18563,        /* NOTREACHED */
18564,    } else {
18565,        close(fd[0]); /* we don't use the reading end */
18566,        /* we are writing on the writing side of the pipe */
18567,"        FILE *out = fdopen(fd[1], ""w"");"
18568,        int c;
18569,        while ((c = fgetc(stdin)) != EOF) {
18570,            /* make a copy for the child */
18571,"            fputc(c, out);"
18572,            /* and write to stdout */
18573,"            fputc(c, stdout);"
18574,        }
18575,        fclose(out); /* signal the child that there's no more output */
18576,"        fprintf(stderr,"
18577,"                ""Waiting for the child (whose pid should be %d)"""
18578,"                "" to finish\n"","
18579,                child_pid);
18580,        int status;
18581,        pid_t exited_pid = wait(&status);
18582,        if (exited_pid < 0) {
18583,"            perror(""wait"");"
18584,            exit(1);
18585,        }
18586,"        fprintf(stderr,"
18587,"            ""%d exited with status %d\n"","
18588,"            exited_pid, status);"
18589,        exit(0);
18590,        /* NOTREACHED */
18591,    } /* else */
18592,} /* main */
18593,"$ echo ""Hello, world"" | ./a.out"
18594,"Hello, world"
18595,Waiting for the child (whose pid should be 2833) to finish
18596,Child (pid=2833) exiting.
18597,2833 exited with status 0
18598,$ _
18599,output.txt
18600,$ cat output.txt
18601,<48><65><6c><6c><6f><2c><20><77><6f><72><6c><64><0a>$ _
18602,runChild
18603,usleep
18604,execve
18605,pause(2)
18606,usleep(3)
18607,execve
18608,execve
18609,myecho
18610,"kill(pid, SIGUSR1)"
18611,execve
18612,execve
18613,myecho
18614,myecho
18615,_exit()
18616,"kill(pid, SIGUSR1)"
18617,kill
18618,execve
18619,myecho
18620,exec
18621,execve
18622,waitpid
18623,"waitpid(-1, NULL, WNOHANG);"
18624,waitpid
18625,waitpid
18626,waitpid(WNOHANG)
18627,SIGCHLD
18628,waitpid
18629,WNOHANG
18630,usleep
18631,sigwait()
18632,runChild
18633,SIGUSR1
18634,waitpid
18635,waitpid
18636,waitpid
18637,    void FooMethod()
18638,    {
18639,      netconn* tcpListenNetconn;
18640,      netconn* connection;
18641,    
18642,      tcpListenNetconn = netconn_new(NETCONN_TCP);
18643,"      netconn_bind(tcpListenNetconn, IP4_ADDR_ANY, TCP_PORT);"
18644,      netconn_listen(tcpListenNetconn);
18645,"      netconn_accept(tcpListenNetconn, &connection);"
18646,    
18647,      uint8_t buffer = 0x65;
18648,    
18649,      while(1)
18650,      {
18651,"         err_t error = netconn_write(connection , &buffer , 1, NETCONN_COPY);"
18652,         if (error != ERR_OK)
18653,         {
18654,             netconn_close(connection);
18655,             netconn_delete(connection);
18656,             break;
18657,         }
18658,      }
18659,    }
18660,mmap
18661,/proc/pid/pagemap
18662,echo 4 >> /proc/pid/clear_refs
18663,CONFIG_HAVE_ARCH_SOFT_DIRTY
18664,=n
18665,HAVE_ARCH_SOFT_DIRTY
18666,pagemap
18667,kpageflags
18668,SPI1->CR1 |= (1<<2); // to set bit 2 to 1
18669,SPI1->CR1 &= ~(1<<7); // to set bit 7 to 0
18670,SPI1->CR1 &= ~(1<<3);
18671,SPI1->CR1 |=(3<<3)
18672,SPI1->CR1 &= ~(1<<5 | 1<<4 | 1<<3);
18673,SPI1->CR1 &= ~(7<<3);
18674,uint16_t val = SPI1->CR1; val &= ~(15<3); val |= (4<<3); SPI1->CR1 = val;
18675,&= ~(11<<3)
18676,"""we have a binary 7 = 111 and we are performing the negation,"""
18677,uint32_t cr1 = SPI1->CR1; // read ONCE
18678,
18679,"// Now do any bit manipulations you fancy here, without concerns for performance:"
18680,cr1 |= 1<<2;
18681,cr1 &= ~(1<<7); 
18682,
18683,SPI1->CR1 = cr1; // write ONCE
18684,volatile uint32_t SPI1_CR1;
18685,uint32_t cr1 = SPI1_CR1;
18686,cr1 |= 1<<2;
18687,cr1 &= ~(1<<7); 
18688,SPI1_CR1 = cr1;
18689,-O3
18690,"    ldr     r3, [sp, #4]"
18691,"    bic     r3, r3, #128"
18692,"    orr     r3, r3, #4"
18693,"    str     r3, [sp, #4]"
18694,cr1
18695, volatile uint32_t SPI1_CR1;
18696, SPI1_CR1 |= 1<<2;
18697, SPI1_CR1 &= ~(1<<7); 
18698,
18699,
18700,"    ldr     r3, [sp, #4]"
18701,"    orr     r3, r3, #4"
18702,"    str     r3, [sp, #4]"
18703,"    ldr     r3, [sp, #4]"
18704,"    bic     r3, r3, #128"
18705,"    str     r3, [sp, #4]"
18706,1<<2
18707,1<<...
18708,1
18709,int
18710,1u<<...
18711,#define SPICR_SPIE (1u << 7)
18712,#define SPICR_CPOL (1u << 4)
18713,#define SPICR_CPHA (1u << 3)
18714,...
18715,SPICR = SPICR_SPIE | SPICR_CPHA;
18716,#define SPICR_SPIE(val) ((val) << 7)
18717,#define SPICR_CPOL(val) ((val) << 4)
18718,#define SPICR_CPHA(val) ((val) << 3)
18719,...
18720,SPICR = SPICR_SPIE(1) | SPICR_CPOL(0) | SPICR_CPHA(1) ;
18721,#define SPICR_BAUD(val) ((val & 0xF) << 3)
18722,(val << 3) & 0xE8u
18723, #define BITS_543 0x38 // == 0b0...111000
18724, SPI1->CR1 &= ~BITS_543;
18725,:-)
18726,int main() {
18727,"  char* s = ""blah"";"
18728,}
18729,int main() {
18730,  char* s = 0x/*A random address here*/;
18731,  s[0] = 'b';
18732,  s[1] = 'l';
18733,  s[2] = 'a';
18734,  s[3] = 'h';
18735,  s[4] = 0;
18736,"""blah"""
18737,"char* s = ""blah"";"
18738,char
18739,s
18740,#include <datetime.h>
18741,#include <Python.h>
18742,....
18743,"PyObject *first_date = PyDate_FromDate(2022, 08, 31);"
18744,"PyObject *time_delta = PyDelta_FromDSU(2, 0, 0);"
18745,time_delta
18746,first_date
18747,"PyObject* Date = PyDate_FromDate(year, month, day);"
18748,"PyObject* TimeDelta = PyDelta_FromDSU(days, seconds, microseconds);"
18749,
18750,"PyObject* result = PyNumber_Add(Date, TimeDelta);"
18751,"char str[20] = ""Hello stackoverflow!"";"
18752,char copy[20] = str;
18753,struct str {
18754,    char str[20];
18755,};
18756,"struct str a = {""Hello stackoverflow!""};"
18757,struct str b = a;
18758,#include <stdio.h>
18759,
18760,int main() {
18761, int c;
18762, while((c = getchar() != EOF)) {
18763,"  printf(""%d\n"", c);"
18764, }
18765," printf(""%d - at EOF\n"", c);"
18766,}
18767,-1
18768,getchar()
18769,while((c = getchar()) != EOF)
18770,while (c = (getchar()!= EOF))
18771,Int
18772,#define EOF    (-1)
18773,getchar
18774,getchar()
18775,ferror
18776,feof
18777,while((c = getchar())!= EOF)
18778,while((c = getchar() != EOF))
18779,#include <stdio.h>
18780,int main()
18781,{
18782, int c;
18783, while((c = getchar())!= EOF)
18784, {
18785,  if( getchar() == EOF )
18786,    break;
18787,"  printf("" %d\n"", c);"
18788, }
18789,"  printf(""%d %u %x- at EOF\n"", c , c, c);"
18790,}
18791,getchar()
18792,getchar
18793,#include <stdio.h>
18794,
18795,int main() {
18796,    int c;
18797,"    while((c = getchar()) != EOF) { //precedence of != is greater than =, so use braces"
18798,"        printf(""%d\n"", c);"
18799,    }
18800,"    printf(""%d - at EOF\n"", c);"
18801,}
18802,stdio.h
18803,EOF
18804,-1
18805,#include <stdio.h>
18806,
18807,int main() {
18808,    int c;
18809,    while((c = getchar()) != EOF) { 
18810,        putchar(c);
18811,    }    
18812,"    printf(""%d  at EOF\n"", c);"
18813,}
18814,int c;
18815,
18816,while((c = getchar())!= 10)
18817,{
18818,    if( getchar() == EOF )
18819,        break;
18820,
18821,"     printf("" %d\n"", c);"
18822,}
18823,"void write_v(FILE *f, uint8_t n)"
18824,\  /
18825, \/ 
18826, #define _CRT_SECURE_NO_WARNINGS
18827,#include <stdio.h>
18828,#include <stdint.h>
18829,#include <stdlib.h>
18830,
18831,"void write_v(FILE* f, uint8_t n) {"
18832,    if (f == NULL) {
18833,        return; 
18834,    }
18835,    if (n == 0) {
18836,        return; 
18837,    }
18838,    if (n == 1) {
18839,"        fprintf(f, ""%c\n"", '\\ /'); "
18840,    }
18841,    for (size_t i = 0; i < n; i++) {
18842,        // how many times I run this loop
18843,        for (size_t e = n - i; e < n; e++) {
18844,            // external whitespaces 
18845,"            fprintf(f, ""%c"", ' '); "
18846,        }
18847,"        fprintf(f, ""%c"", '\\'); "
18848,        for (size_t j = 1 + i; j < (2 * n - 1 - i); j++) { // internal whitespaces 
18849,"            fprintf(f, ""%c"", ' '); "
18850,        }
18851,"        fprintf(f, ""%c"", '/'); "
18852,"        fprintf(f, ""%c"", '\n');"
18853,    }
18854,
18855,}
18856,
18857,
18858,int main(void) {
18859,"    FILE* f = fopen(""test.txt"", ""w""); "
18860,"    write_v(f, 2); "
18861,
18862,
18863,    return 0; 
18864,}
18865,\  /
18866, \/
18867,fopen
18868,fclose
18869,"P(""\n Enter the max number of characters you are going to enter : "");"
18870,"if(S(""%[^\n]?%d"", &len)==0)"
18871,{
18872,"    P(""\n The default length is 256.\n"");"
18873,    len = 256;
18874,}
18875,
18876,if(len == 0)
18877,{
18878,"    P(""\n Empty string cannot be encrypted."");"
18879,    return 0;
18880,}
18881,%[...]
18882,F
18883,\n
18884,"F(str,len)"
18885,N
18886,"result = F(str,100);  if(result == N || str[0]=='\n')"
18887,F
18888,scanf
18889,%d
18890,scanf
18891,Values  ->  0  1  2  12  43  90  300
18892,Indexes ->  0  1  2  3   4   5   6
18893,300  2  43  12  0  1  90
18894, 6   2  4   3   0  1  5
18895,struct
18896,O(n)
18897,#include <stdio.h>
18898,#include <stdlib.h>
18899,
18900,typedef struct {
18901,    int val;
18902,    int in0;
18903,    int in1;
18904,} pair_t;
18905,
18906,"int cmpVal( const void *a, const void *b ) { return ((pair_t*)a)->val - ((pair_t*)b)->val; }"
18907,"int cmpOrg( const void *a, const void *b ) { return ((pair_t*)a)->in0 - ((pair_t*)b)->in0; }"
18908,
18909,int main() {
18910,    int i;
18911,"    int unsort[] = { 300, 2, 43, 12, 0, 1, 90 };"
18912,    const int n = sizeof unsort/sizeof unsort[0];
18913,
18914,    // Make a copy in unsorted order including orginal sequence.
18915,    pair_t *worken = malloc( n * sizeof *worken );
18916,    for( i = 0; i < n; i++ )
18917,"        worken[i].val = unsort[i], worken[i].in0 = i;"
18918,
18919,    // Sort by value ascending
18920,"    qsort( worken, n, sizeof pair_t, cmpVal );"
18921,
18922,    // Register this sequence with each element
18923,    for( i = 0; i < n; i++ )
18924,        worken[i].in1 = i;
18925,
18926,    // Restore original sequence
18927,"    qsort( worken, n, sizeof pair_t, cmpOrg );"
18928,
18929,    // Copy the indices (of sorted version) to 'persistant' array.
18930,    int sorted[n] = { 0 };
18931,    for( i = 0; i < n; i++ )
18932,        sorted[i] = worken[i].in1;
18933,
18934,    // Toss 'working' buffer.
18935,    free( worken );
18936,
18937,    // List original sequence
18938,    for( i = 0; i < n; i++ )
18939,"        printf( ""%4d"", unsort[ i ] );"
18940,    putchar( '\n' );
18941,
18942,    // List corresponding indices (as if sorted)
18943,    for( i = 0; i < n; i++ )
18944,"        printf( ""%4d"", sorted[ i ] );"
18945,    putchar( '\n' );
18946,
18947,    return 0;
18948,}
18949, 300   2  43  12   0   1  90
18950,   6   2   4   3   0   1   5
18951,"""replace values with indices"""
18952,int
18953,#include <stdio.h>
18954,#include <limits.h>
18955,
18956,"void show( int u[], size_t cnt ) { // Show current array values"
18957,    for( size_t i = 0; i < cnt; i++ )
18958,"        printf( ""%4d"", u[ i ] );"
18959,    putchar( '\n' );
18960,}
18961,
18962,"void oddSort( int u[], size_t cnt ) {"
18963,"    show( u, cnt );"
18964,    // Succesively find and replace highest values with decreasing large int values.
18965,    int peak = INT_MAX;
18966,    for( size_t set = 0; set < cnt; set++ ) {
18967,        int maxID = 0;
18968,        while( u[maxID] >= peak ) maxID++; // find first non-replaced value
18969,        for( size_t i = maxID + 1; i < cnt; i++ )
18970,            if( u[i] < peak && u[i] > u[maxID] )
18971,                maxID = i;
18972,        u[maxID] = peak--;
18973,    }
18974,
18975,"    // transpose down to 0, 1, 2..."
18976,    for( size_t i = 0; i < cnt; i++ )
18977,        u[i] -= peak + 1;
18978,"    show( u, cnt );"
18979,}
18980,
18981,int main() {
18982,    {
18983,"        int u[] = { 300, 2, 43, 12, 0, 1, 90 };"
18984,"        oddSort( u, sizeof u/sizeof u[0] );"
18985,    }
18986,    putchar( '\n' );
18987,    {
18988,        // Test with negatives (coincidentally lowest value in first pos)
18989,"        int u[] = { -256, 300, 2, 43, 12, 0, 1, 90 };"
18990,"        oddSort( u, sizeof u/sizeof u[0] );"
18991,    }
18992,    return 0;
18993,}
18994, 300   2  43  12   0   1  90
18995,   6   2   4   3   0   1   5
18996,
18997,-256 300   2  43  12   0   1  90
18998,   0   7   3   5   4   1   2   6
18999,malloc()
19000,#include <stdlib.h>
19001,void *
19002,#include <malloc.h>
19003,<stdlib.h>
19004,char *malloc()
19005,int
19006,while (1)
19007,{
19008,    word = (char *)malloc(sizeof(char) * wordLength);
19009,
19010,"    readReturn = scanf(""%s"", word);"
19011,    if (readReturn == 0)
19012,        return 0;
19013,    BSTNode new = newBSTNode(word);
19014,"    if (strcmp(word, ""END"") == 0)"
19015,        break;
19016,"    TreeInsert(Tree, new);"
19017,}
19018,     word = (char *)malloc(sizeof(char) * wordLength);    
19019,     while (1)
19020,     {
19021,"        readReturn = scanf(""%s"", word);"
19022,
19023,        if (readReturn == 0)
19024,            return 0;
19025,        BSTNode new = newBSTNode(word);
19026,"        if (strcmp(word, ""END"") == 0)"
19027,            break;
19028,"        TreeInsert(Tree, new);"
19029,     }
19030,newBSTNode
19031,if (readReturn == 0)
19032,if (readReturn != 1)
19033,"""END"""
19034,free
19035, word = (char *)malloc(sizeof(char) * wordLength);    
19036, while (1)
19037, {
19038,"    readReturn = scanf(""%s"", word);"
19039,
19040,    if (readReturn == 0)
19041,        return 0;
19042,    BSTNode new = newBSTNode(word);
19043,"    if (strcmp(word, ""END"") == 0)"
19044,        break;
19045,"    TreeInsert(Tree, new);"
19046, }
19047, word = (char *)malloc(sizeof(char) * wordLength);    
19048,while (1)
19049,{
19050,    word = (char *)malloc(sizeof(char) * wordLength);
19051,
19052,"    readReturn = scanf(""%s"", word);"
19053,    if (readReturn == 0)
19054,        return 0;
19055,    BSTNode new = newBSTNode(word);
19056,"    if (strcmp(word, ""END"") == 0)"
19057,        break;
19058,"    TreeInsert(Tree, new);"
19059,}
19060,free( word );
19061,#include <stdio.h>
19062,int main(){
19063,    char arr[100];
19064,"    printf(""%d"", scanf(""%s"", arr));"
19065,    return 0;
19066,}
19067,1
19068,scanf
19069,"scanf(""%s"", arr)"
19070,"printf(""%d"", scanf(""%s"", arr));"
19071,"int result = scanf(""%s"", arr);"
19072,"printf(""%d"", result);"
19073, #include <stdio.h>
19074,#include <conio.h>
19075,int main()
19076,{
19077,int first=0;
19078,int second=0;
19079,"printf(""Enter first number :"");"
19080,"scanf_s(""%d"",&first);"
19081,"printf(""Enter second number :"");"
19082,"scanf_s(""%d"",&second);"
19083,first++;
19084,int sum=0;
19085,while(first<=second)
19086,{
19087,    if(first%4==0 && first%16==0)
19088,    {
19089,"        printf(""%d  "",first);"
19090,"        printf(""+ "");"
19091,        sum+=first;
19092,    }
19093,    first++;
19094,}
19095,"printf(""  =%d "",sum);"
19096,}
19097,"char *connect = """"; // a connection string used soon"
19098,while(first<=second)
19099,{
19100,    if(first%4==0 && first%16==0)
19101,    {
19102,"        printf( ""%s%d"", connect, first );"
19103,"        connect = "" + ""; // if another value output, this prints first"
19104,        sum += first;
19105,    }
19106,    first++;
19107,}
19108,"printf(""  = %d "",sum);"
19109,#include <stdio.h>
19110,
19111,int main()
19112,{
19113,    for( ;; ) { // infinite loop
19114,        int first;
19115,"        printf( ""Enter first number :"" );"
19116,"        scanf_s( "" %d"", &first );"
19117,
19118,        int second = first - 1;
19119,        while( second <= first ) {
19120,"            printf( ""Enter second number (>%d):"", first );"
19121,"            scanf_s( "" %d"", &second );"
19122,        }
19123,
19124,        int interval = 0; // acts like modulo
19125,        while( interval < 2 ) {
19126,"            printf( ""Enter interval (2+):"" );"
19127,"            scanf_s( "" %d"", &interval );"
19128,        }
19129,
19130,        first += interval - (first % interval);
19131,"        // Or, one alternative start value"
19132,        // first += interval - ( first % interval );
19133,
19134,        int sum = 0;
19135,"        char *connect = """"; // Answering OP problem of printing"
19136,        while( first <= second )
19137,        {
19138,"            printf(""%s%d"", connect, first );"
19139,"            connect = "" + ""; // subsequent numbers prefixed by "" + """
19140,            sum += first;
19141,            first += interval;
19142,        }
19143,
19144,"        printf( "" = %d\n"", sum );"
19145,    }
19146,
19147,    return 0;
19148,}
19149,Enter first number :-170
19150,Enter second number (>-170):90
19151,Enter interval (2+):42
19152,-126 + -84 + -42 + 0 + 42 + 84 = -126
19153,Enter first number :38
19154,Enter second number (>38):300
19155,Enter interval (2+):42
19156,42 + 84 + 126 + 168 + 210 + 252 + 294 = 1176
19157,#include <stdio.h>
19158,
19159,int main(void)
19160,{
19161,    int first=0;
19162,    int second=0;
19163,
19164,"    printf(""Enter first number :"");"
19165,"    scanf(""%d"",&first);"
19166,
19167,"    printf(""Enter second number :"");"
19168,"    scanf(""%d"",&second);"
19169,
19170,    int sum=0;
19171,    int start=0;
19172,    while(first<=second)
19173,    {
19174,        if(first%16==0)
19175,        {
19176,"            if(start) printf(""+ "");"
19177,            start=1;
19178,"            printf(""%d "", first);"
19179,            sum+=first;
19180,        }
19181,        first++;
19182,    }
19183,"    printf(""= %d "",sum);"
19184,
19185,    return 0;
19186,}
19187,"print(""\b\b= %d"",sum);"
19188,char maze[12][12]
19189,'.'
19190,'#'
19191,char *starting_point = &maze[5][0]
19192,"maze_traverse( maze, starting point );"
19193,"void maze_traverse( char maze[][SIZE], char * position);"
19194,maze_traverse
19195,"maze_traverse( maze, position + 1)"
19196,position + 1
19197,maze[5][1]
19198,maze[4][11]
19199,maze[4][11]
19200,position + 1
19201,maze[5][1]
19202,"#pragma location = ""APP_INTERNAL_SEG"""
19203,"void i2c_msp_init(unsigned char DevAddr, USHORT ClkIdDivisor)"
19204,{
19205,    //P5SEL |= 0x06;                            // I2C su USCI_B1: SDA sul pin 5.1 e SCL sul pin 5.2; l'I2C è disponibile sulla USCI_B0 e sulla USCI_B1
19206,    UCB1CTL1 = UCSWRST;                      // si entra nella condizione di SW reset
19207,    UCB1CTL0 = UCMST + UCMODE_3 + UCSYNC;     // I2C Master in synchronous mode
19208,    
19209,"    UCB1CTL1 |= UCSSEL_2;            // UCSSEL_2 per utilizzare SMCLK, UCSWRST per restare nella condizione di SW reset"
19210,    
19211,    // lvMF
19212,    //  UCB1BR0 = I2C_FREQ_100K;                  // fSCL = SMCLK/12 = ~100kHz
19213,    //  UCB1BR1 = 0;
19214,    UCB1BR0 = LOBYTE(ClkIdDivisor);
19215,    UCB1BR1 = HIBYTE(ClkIdDivisor);
19216,    
19217,    UCB1I2CSA = DevAddr;                      // ad UCB1I2CSA assegna l'indirizzo del dispositivo con cui si deve comunicare
19218,        
19219,        P5SEL |= 0x06;                            // I2C su USCI_B1: SDA sul pin 5.1 e SCL sul pin 5.2; l'I2C è disponibile sulla USCI_B0 e sulla USCI_B1
19220,    UCB1CTL1 &= ~UCSWRST;                     // si esce dall condizione di SW reset
19221,    
19222,    // lvMF
19223,    // ATTENZIONE !!!
19224,    // NON SI PUO' RICONFIGURARE IL TIMER-A PERCHE' USATO DALLO STACK KNX
19225,"    //  TACTL = TASSEL_2 + MC_2;                  // SMCLK, contmode"
19226,}
19227,"#pragma location = ""APP_INTERNAL_SEG"""
19228,BOOL i2c_msp_start_tx(void)
19229,{
19230,    int count01;
19231,    int count02;
19232,    
19233,       // while(UCB1STAT & UCBBUSY);
19234,        
19235,    UCB1CTL1 |= (UCTR | UCTXSTT);  // I2C TX start: si trasmette UCB1I2CSA
19236,
19237,    count01 = 0;
19238,    while(UCB1CTL1 & UCTXSTT)
19239,    {
19240,        // si aseptta la fine della tx
19241,        count01++;
19242,        if(count01 > COUNT_MAX)
19243,            return FALSE;
19244,    }
19245,    
19246,    count01 = 0;
19247,    while(UCB1STAT & UCNACKIFG)             // se c'è nack sulla tx si fa repeated start (si invia un nuovo start)
19248,    {
19249,        count01++;
19250,        if(count01 > COUNT_MAX)
19251,            return FALSE;
19252,        
19253,        UCB1CTL1 |= UCTR + UCTXSTT;         // I2C TX start
19254,        
19255,        count02 = 0;
19256,        while(UCB1CTL1 & UCTXSTT)         // si aseptta la fine della tx
19257,        {
19258,            count02++;
19259,            if(count02 > COUNT_MAX)
19260,                return FALSE;
19261,        }
19262,    }
19263,    
19264,    return TRUE;
19265,}
19266,"MAX(X,Y)"
19267,X
19268,Y
19269,x++
19270,x+2
19271,"#define MAX(a, b) ((a) > (b) ? (a) : (b))"
19272,x++
19273,x+2
19274,x++
19275,max
19276,parse
19277,"#define INTMAX(A, B) ({ int _a = (A), _b = (B) ; _a > _b ? _a : _b ; })"
19278,typeof
19279,int
19280,STM32G441
19281,RCC->CR |= RCC_CR_HSEON | RCC_CR_HSION;
19282,
19283,"// Configure PLL (R=143.75, Q=47.92)"
19284,RCC->CR &= ~RCC_CR_PLLON;
19285,while (RCC->CR & RCC_CR_PLLRDY) {
19286,}
19287,RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSE | RCC_PLLCFGR_PLLM_0 | (23 << RCC_PLLCFGR_PLLN_Pos) | RCC_PLLCFGR_PLLQ_1;
19288,RCC->PLLCFGR |= RCC_PLLCFGR_PLLREN | RCC_PLLCFGR_PLLQEN;
19289,RCC->CR |= RCC_CR_PLLON;
19290,
19291,"// Select PLL as main clock, AHB/2 > otherwise Bus Error Hard Fault"
19292,RCC->CFGR |= RCC_CFGR_HPRE_3 | RCC_CFGR_SW_PLL;
19293,
19294,"// Select & Enable IO Clocks (PLL > USB, ADC; HSI16 > UART)"
19295,RCC->CCIPR = RCC_CCIPR_CLK48SEL_0 | RCC_CCIPR_ADC12SEL_1 | RCC_CCIPR_USART1SEL_1 | RCC_CCIPR_USART2SEL_1 | RCC_CCIPR_USART3SEL_1 | RCC_CCIPR_UART4SEL_1;
19296,RCC->AHB2ENR |= RCC_AHB2ENR_ADC12EN | RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN | RCC_AHB2ENR_GPIOCEN;
19297,RCC->APB1ENR1 |= RCC_APB1ENR1_USBEN | RCC_APB1ENR1_UART4EN | RCC_APB1ENR1_USART3EN | RCC_APB1ENR1_USART2EN;
19298,RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
19299,
19300,// Enable DMAMUX & DMA1 Clock
19301,RCC->AHB1ENR |= RCC_AHB1ENR_DMAMUX1EN | RCC_AHB1ENR_DMA1EN;
19302,"#define __USB_MEM __attribute__((section("".usbbuf"")))"
19303,#define __USBBUF_BEGIN 0x40006000
19304,#define __MEM2USB(X) (((int)X - __USBBUF_BEGIN))
19305,0x40006000
19306,typedef struct {
19307,    unsigned short ADDR_TX;
19308,    unsigned short COUNT_TX;
19309,    unsigned short ADDR_RX;
19310,    unsigned short COUNT_RX;
19311,} USB_BTABLE_ENTRY;
19312,
19313,__ALIGNED(8)
19314,__USB_MEM
19315,static USB_BTABLE_ENTRY BTable[8] = {0};
19316,
19317,__ALIGNED(2)
19318,__USB_MEM
19319,static char EP0_Buf[2][64] = {0};
19320,"NVIC_SetPriority(USB_HP_IRQn, 0);"
19321,"NVIC_SetPriority(USB_LP_IRQn, 0);"
19322,"NVIC_SetPriority(USBWakeUp_IRQn, 0);"
19323,NVIC_EnableIRQ(USB_HP_IRQn);
19324,NVIC_EnableIRQ(USB_LP_IRQn);
19325,NVIC_EnableIRQ(USBWakeUp_IRQn);
19326,
19327,USB->CNTR &= ~USB_CNTR_PDWN;
19328,
19329,// Wait 1μs until clock is stable
19330,SysTick->LOAD = 100;
19331,SysTick->VAL = 0;
19332,SysTick->CTRL = 1;
19333,while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0) {
19334,}
19335,SysTick->CTRL = 0;
19336,
19337,USB->CNTR &= ~USB_CNTR_FRES;
19338,USB->ISTR = 0;
19339,
19340,USB->CNTR |= USB_CNTR_RESETM | USB_CNTR_CTRM | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ESOFM;
19341,USB->BCDR |= USB_BCDR_DPPU;
19342,if ((USB->ISTR & USB_ISTR_RESET) != 0) {
19343,    USB->ISTR = ~USB_ISTR_RESET;
19344,
19345,    // Enable EP0
19346,    USB->BTABLE = __MEM2USB(BTable);
19347,
19348,    BTable[0].ADDR_TX = __MEM2USB(EP0_Buf[0]);
19349,    BTable[0].COUNT_TX = 0;
19350,    BTable[0].ADDR_RX = __MEM2USB(EP0_Buf[1]);
19351,    BTable[0].COUNT_RX = (1 << 15) | (1 << 10);
19352,
19353,    USB->EP0R = USB_EP_CONTROL | (2 << 4) | (3 << 12);
19354,    USB->CNTR = USB_CNTR_CTRM | USB_CNTR_RESETM;
19355,
19356,    USB->DADDR = USB_DADDR_EF;
19357,}
19358,0x40006000
19359,SUSP
19360,WKUP
19361,SOF
19362,ERR
19363,SOF
19364,USB->EP0R
19365,RCC->CCIPR = RCC_CCIPR_CLK48SEL_0 | ...
19366,Reserved
19367,RCC->CCIPR = RCC_CCIPR_CLK48SEL_1 | ...
19368,SOF
19369,CTR
19370,c
19371,TI mcu
19372,"""Error: failed writing zone setting to flash"""
19373,#define PATTERN_ZONE_1_FLASH_OFFSET 0x100008
19374,
19375,static int32_t saveZoneSetting()
19376,{
19377,    int32_t     retVal = 0;
19378,"    uint32_t    zone1, zone2, zone3, zone4;"
19379,"    uint32_t    pZone[4] = {zone1, zone2, zone3, zone4};"
19380,
19381,    /* Flash calibration data */
19382,"    if(flashWrite(PATTERN_ZONE_1_FLASH_OFFSET, pZone, sizeof(uint32_t)*4)<0){"
19383,        /* Flash Header failed */
19384,"        System_printf (""Error: failed writing zone setting to flash\n"");"
19385,        return -1;
19386,    }
19387,    return(retVal);
19388,}
19389,zone1
19390,zone2
19391,zone3
19392,zone4
19393,pZone
19394,flashWrite()
19395,struct tga_header {
19396,      uint8_t magic1;             // must be zero
19397,      uint8_t colormap;           // must be zero
19398,      uint8_t encoding;           // must be 2
19399,"      uint16_t cmaporig, cmaplen; // must be zero"
19400,      uint8_t cmapent;            // must be zero
19401,      uint16_t x;                 // must be zero
19402,      uint16_t y;                 // image's height
19403,      uint16_t h;                 // image's height
19404,      uint16_t w;                 // image's width
19405,      uint8_t bpp;                // must be 32
19406,      uint8_t pixeltype;          // must be 40
19407,} __attribute__((packed));
19408,            
19409,void display_tga(struct tga_header *base)
19410,{
19411,   if (base->magic1 != 0 || base->colormap != 0 || base->encoding != 2
19412,       || base->cmaporig != 0 || base->cmapent != 0 || base->x != 0
19413,       || base->bpp != 32 || base->pixeltype != 40)
19414,       return;
19415,   uint32_t *img = (u32*)(sizeof(struct tga_header)+(uint64_t)base);
19416,"   draw_icon(700, 50, base->w, base->h, img);"
19417,}
19418,"static void draw_icon(int x, int y, int w, int h, u32 *img) {"
19419,"   int j, l, i;"
19420,
19421,   for (l = j = 0; l < h; l++) {
19422,"      for (i = 0; i < w; i++, j++) {"
19423,"         putpixel(x + i, y + l, img[j]);"
19424,      }
19425,   }
19426,}
19427,h
19428,w
19429,tga_header
19430,valgrind
19431,str
19432,"char **splitstring(char *str, const char *delim)"
19433,{
19434,"    int i, wn;"
19435,    char **array;
19436,    char *token;
19437,    char *copy;
19438,
19439,    copy = malloc(strlen(str) + 1);
19440,    if (copy == NULL)
19441,    {
19442,"        perror(""hsh"");"
19443,        return (NULL);
19444,    }
19445,    i = 0;
19446,    while (str[i])
19447,    {
19448,        copy[i] = str[i];
19449,        i++;
19450,    }
19451,    copy[i] = '\0';
19452,
19453,"    token = strtok(copy, delim);"
19454,    array = malloc((sizeof(char *) * 2));
19455,    array[0] = strdup(token);
19456,
19457,    i = 1;
19458,    wn = 3;
19459,    while (token)
19460,    {
19461,"        token = strtok(NULL, delim);"
19462,"        array = realloc(array, (sizeof(char *) * (wn - 1)), (sizeof(char *) * wn));"
19463,        array[i] = strdup(token);
19464,        i++;
19465,        wn++;
19466,    }
19467,    free(copy);
19468,    return (array);
19469,}
19470, 
19471,strcpy
19472,strdup
19473,realloc
19474,realloc
19475,NULL
19476,"token = strtok(NULL, delim);"
19477,token
19478,array[i] = strdup(token);
19479,strtok
19480,"token = strtok(NULL, delim);"
19481,while
19482,while(token)
19483,token
19484,#include <stdio.h>
19485,
19486,int main() {
19487,    char c2 = 'ab';
19488,"    printf(""c2: %c\n"", c2);"
19489,
19490,    return 0;
19491,}
19492,#include <stdio.h>
19493,
19494,int main() {
19495,    char c3;
19496,"    scanf(""%c"", &c3);"
19497,"    printf(""c3: %c\n"", c3);"
19498,    
19499,    return 0;
19500,}
19501,char
19502,'ab'
19503,char
19504,'ab'
19505,b
19506,b
19507,'ab'
19508,char
19509,'ab'
19510,char
19511,'b'
19512,<source>: In function 'main':
19513,<source>:4:15: warning: multi-character character constant [-Wmultichar]
19514,    4 |     char c2 = 'ab';
19515,      |               ^~~~
19516,<source>:4:15: warning: overflow in conversion from 'int' to 'char' changes value from '24930' to '98' [-Woverflow]
19517,b
19518,>>> chr(98)
19519,'b'
19520,'ab'
19521,scanf
19522,%c
19523,'a'
19524,scanf
19525,main.c: In function ‘main’:
19526,main.c:4:15: warning: multi-character character constant [-Wmultichar]
19527,    4 |     char c2 = 'ab';
19528,      |               ^~~~
19529,main.c:4:15: warning: overflow in conversion from ‘int’ to ‘char’ changes value from ‘24930’ to ‘98’ [-Woverflow]
19530,24930 = 0x6162
19531,b'
19532,int
19533,char
19534,'a'
19535,'b'
19536,'a'
19537,'b'
19538,'b'
19539,'ab'
19540,int
19541,"li 4,98"
19542,'b'
19543,int
19544,char
19545,char
19546,'x'
19547,int
19548,'ab'
19549,int
19550,stdin
19551,scanf
19552,int input = 24100;
19553,int num_zeroes = 0;
19554,
19555,while (input > 0) {
19556,    if (input % 10 == 0) {
19557,        num_zeroes = num_zeroes + 1;
19558,        input = input / 10;
19559,    }
19560,    else {
19561,        break;
19562,    }
19563,}
19564,
19565,"printf(""%d"", num_zeroes);  // 2"
19566,input != 0
19567,"int cnt = 0; while( input && input % 10 == 0)  cnt++, input /= 10;"
19568,Syslog
19569,rsyslog
19570,Linux
19571,Syslog
19572,journalctl -f -u Myservice
19573,Debian Jessie
19574,Linux
19575,I use the journal -f
19576,journalctl
19577,a
19578,a
19579,  for(int i=0;i<5;i++)
19580,  {
19581,      int a=i;
19582,"      printf(""a=%d\n"",a);"
19583,  }
19584,}
19585,a=0
19586,a=1
19587,a=2
19588,a=3
19589,a=4
19590,int
19591,new
19592,another
19593,#include <stdio.h>
19594,
19595,int main(void) {
19596,  for (int i = 0; i < 5; i++) {
19597,    int a = i;
19598,"    printf(""a=%d %p\n"", a, &a);"
19599,  }
19600,
19601,  return 0;
19602,}
19603,these new created a will be assigned to the same address
19604,a=0 0000008F898FFB44
19605,a=1 0000008F898FFB44
19606,a=2 0000008F898FFB44
19607,a=3 0000008F898FFB44
19608,a=4 0000008F898FFB44
19609,&a
19610,i
19611,a
19612,for(int i=0;i<5;i++)
19613,  {
19614,"      int a=i;                    //a new variable a will be created, initialized with the value of i "
19615,"      printf(""a=%d\n"",a);"
19616,"  }                               // lifetime of the variable a will end, forget everything"
19617,a
19618,for(int i=0;i<5;i++) //for loop will have 5 iterations starting at i value 0 - 4
19619,  {
19620,"      int a=i; //each iteration a ""new"" variable ""a"" is declared and initialized to the value of i"
19621,"      printf(""a=%d\n"",a); //prints the value of ""a"" to the standard out"
19622,  }
19623,}
19624,#include <stdio.h>
19625,int main()
19626,{
19627,  for(int i=0;i<5;i++)
19628,  {
19629,      int a=i;
19630,"      printf(""a=%x\n"",&a);"
19631,  }
19632,
19633,    return 0;
19634,}
19635,gcc -fverbose-asm main1.c -S -o main1.s
19636,"        .file   ""main1.c"""
19637, # GNU C17 (MinGW.org GCC Build-2) version 9.2.0 (mingw32)
19638," #  compiled by GNU C version 9.2.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.21-GMP"
19639,
19640, # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
19641, # options passed:  -iprefix c:\mingw\bin\../lib/gcc/mingw32/9.2.0/ main1.c
19642, # -mtune=generic -march=i586 -auxbase-strip main1.s -fverbose-asm
19643, # options enabled:  -faggressive-loop-optimizations -fassume-phsa
19644, # -fasynchronous-unwind-tables -fauto-inc-dec -fcommon
19645, # -fdelete-null-pointer-checks -fdwarf2-cfi-asm -fearly-inlining
19646, # -feliminate-unused-debug-types -ffp-int-builtin-inexact -ffunction-cse
19647, # -fgcse-lm -fgnu-runtime -fgnu-unique -fident -finline-atomics
19648, # -fipa-stack-alignment -fira-hoist-pressure -fira-share-save-slots
19649, # -fira-share-spill-slots -fivopts -fkeep-inline-dllexport
19650, # -fkeep-static-consts -fleading-underscore -flifetime-dse
19651, # -flto-odr-type-merging -fmath-errno -fmerge-debug-strings -fpeephole
19652, # -fplt -fprefetch-loop-arrays -freg-struct-return
19653, # -fsched-critical-path-heuristic -fsched-dep-count-heuristic
19654, # -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
19655, # -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
19656, # -fsched-stalled-insns-dep -fschedule-fusion -fsemantic-interposition
19657, # -fset-stack-executable -fshow-column -fshrink-wrap-separate
19658, # -fsigned-zeros -fsplit-ivs-in-unroller -fssa-backprop -fstdarg-opt
19659, # -fstrict-volatile-bitfields -fsync-libcalls -ftrapping-math
19660, # -ftree-cselim -ftree-forwprop -ftree-loop-if-convert -ftree-loop-im
19661, # -ftree-loop-ivcanon -ftree-loop-optimize -ftree-parallelize-loops=
19662, # -ftree-phiprop -ftree-reassoc -ftree-scev-cprop -funit-at-a-time
19663, # -funwind-tables -fverbose-asm -fzero-initialized-in-bss -m32 -m80387
19664, # -m96bit-long-double -maccumulate-outgoing-args -malign-double
19665, # -malign-stringops -mavx256-split-unaligned-load
19666, # -mavx256-split-unaligned-store -mfancy-math-387 -mfp-ret-in-387
19667, # -mieee-fp -mlong-double-80 -mms-bitfields -mno-red-zone -mno-sse4
19668, # -mpush-args -msahf -mstack-arg-probe -mstv -mvzeroupper
19669,
19670,    .text
19671,    .def    ___main;    .scl    2;  .type   32; .endef
19672,"    .section .rdata,""dr"""
19673,LC0:
19674,"    .ascii ""a=%x\12\0"""
19675,    .text
19676,    .globl  _main
19677,    .def    _main;  .scl    2;  .type   32; .endef
19678,_main:
19679,LFB13:
19680,    .cfi_startproc
19681,    pushl   %ebp     #
19682,    .cfi_def_cfa_offset 8
19683,"    .cfi_offset 5, -8"
19684,"    movl    %esp, %ebp   #,"
19685,    .cfi_def_cfa_register 5
19686,"    andl    $-16, %esp   #,"
19687,"    subl    $32, %esp    #,"
19688, # main1.c:3: {
19689,    call    ___main  #
19690, # main1.c:4:   for(int i=0;i<5;i++)
19691,"    movl    $0, 28(%esp)     #, i"
19692, # main1.c:4:   for(int i=0;i<5;i++)
19693,    jmp L2   #
19694,L3:
19695, # main1.c:6:       int a=i;
19696,"    movl    28(%esp), %eax   # i, tmp84"
19697,"    movl    %eax, 24(%esp)   # tmp84, a"
19698," # main1.c:7:       printf(""a=%x\n"",&a);"
19699,"    leal    24(%esp), %eax   #, tmp85"
19700,"    movl    %eax, 4(%esp)    # tmp85,"
19701,"    movl    $LC0, (%esp)     #,"
19702,    call    _printf  #
19703, # main1.c:4:   for(int i=0;i<5;i++)
19704,"    addl    $1, 28(%esp)     #, i"
19705,L2:
19706, # main1.c:4:   for(int i=0;i<5;i++)
19707,"    cmpl    $4, 28(%esp)     #, i"
19708,"    jle L3   #,"
19709, # main1.c:10:  return 0;
19710,"    movl    $0, %eax     #, _5"
19711, # main1.c:11: }
19712,    leave   
19713,    .cfi_restore 5
19714,"    .cfi_def_cfa 4, 4"
19715,    ret 
19716,    .cfi_endproc
19717,LFE13:
19718,"    .ident  ""GCC: (MinGW.org GCC Build-2) 9.2.0"""
19719,    .def    _printf;    .scl    2;  .type   32; .endef
19720, # main1.c:6:       int a=i;
19721,"movl    28(%esp), %eax   # i, tmp84"
19722,"movl    %eax, 24(%esp)   # tmp84, a"
19723,    #include <stdio.h>
19724,int main()
19725,{
19726,    for(int i=0;i<5;i++)
19727,    {
19728,        int a=i;
19729,"        printf(""a=%x\n"",&a);"
19730,    }
19731,    int y = 10;
19732,    int a = 5;
19733,
19734,    return 0;
19735,}
19736,"        .file   ""main1.c"""
19737, # GNU C17 (MinGW.org GCC Build-2) version 9.2.0 (mingw32)
19738," #  compiled by GNU C version 9.2.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.21-GMP"
19739,
19740, # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
19741, # options passed:  -iprefix c:\mingw\bin\../lib/gcc/mingw32/9.2.0/ main1.c
19742, # -mtune=generic -march=i586 -auxbase-strip main2.s -fverbose-asm
19743, # options enabled:  -faggressive-loop-optimizations -fassume-phsa
19744, # -fasynchronous-unwind-tables -fauto-inc-dec -fcommon
19745, # -fdelete-null-pointer-checks -fdwarf2-cfi-asm -fearly-inlining
19746, # -feliminate-unused-debug-types -ffp-int-builtin-inexact -ffunction-cse
19747, # -fgcse-lm -fgnu-runtime -fgnu-unique -fident -finline-atomics
19748, # -fipa-stack-alignment -fira-hoist-pressure -fira-share-save-slots
19749, # -fira-share-spill-slots -fivopts -fkeep-inline-dllexport
19750, # -fkeep-static-consts -fleading-underscore -flifetime-dse
19751, # -flto-odr-type-merging -fmath-errno -fmerge-debug-strings -fpeephole
19752, # -fplt -fprefetch-loop-arrays -freg-struct-return
19753, # -fsched-critical-path-heuristic -fsched-dep-count-heuristic
19754, # -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
19755, # -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
19756, # -fsched-stalled-insns-dep -fschedule-fusion -fsemantic-interposition
19757, # -fset-stack-executable -fshow-column -fshrink-wrap-separate
19758, # -fsigned-zeros -fsplit-ivs-in-unroller -fssa-backprop -fstdarg-opt
19759, # -fstrict-volatile-bitfields -fsync-libcalls -ftrapping-math
19760, # -ftree-cselim -ftree-forwprop -ftree-loop-if-convert -ftree-loop-im
19761, # -ftree-loop-ivcanon -ftree-loop-optimize -ftree-parallelize-loops=
19762, # -ftree-phiprop -ftree-reassoc -ftree-scev-cprop -funit-at-a-time
19763, # -funwind-tables -fverbose-asm -fzero-initialized-in-bss -m32 -m80387
19764, # -m96bit-long-double -maccumulate-outgoing-args -malign-double
19765, # -malign-stringops -mavx256-split-unaligned-load
19766, # -mavx256-split-unaligned-store -mfancy-math-387 -mfp-ret-in-387
19767, # -mieee-fp -mlong-double-80 -mms-bitfields -mno-red-zone -mno-sse4
19768, # -mpush-args -msahf -mstack-arg-probe -mstv -mvzeroupper
19769,
19770,    .text
19771,    .def    ___main;    .scl    2;  .type   32; .endef
19772,"    .section .rdata,""dr"""
19773,LC0:
19774,"    .ascii ""a=%x\12\0"""
19775,    .text
19776,    .globl  _main
19777,    .def    _main;  .scl    2;  .type   32; .endef
19778,_main:
19779,LFB13:
19780,    .cfi_startproc
19781,    pushl   %ebp     #
19782,    .cfi_def_cfa_offset 8
19783,"    .cfi_offset 5, -8"
19784,"    movl    %esp, %ebp   #,"
19785,    .cfi_def_cfa_register 5
19786,"    andl    $-16, %esp   #,"
19787,"    subl    $32, %esp    #,"
19788, # main1.c:3: {
19789,    call    ___main  #
19790, # main1.c:4:     for(int i=0;i<5;i++)
19791,"    movl    $0, 28(%esp)     #, i"
19792, # main1.c:4:     for(int i=0;i<5;i++)
19793,    jmp L2   #
19794,L3:
19795, # main1.c:6:         int a=i;
19796,"    movl    28(%esp), %eax   # i, tmp84"
19797,"    movl    %eax, 16(%esp)   # tmp84, a"
19798," # main1.c:7:         printf(""a=%x\n"",&a);"
19799,"    leal    16(%esp), %eax   #, tmp85"
19800,"    movl    %eax, 4(%esp)    # tmp85,"
19801,"    movl    $LC0, (%esp)     #,"
19802,    call    _printf  #
19803, # main1.c:4:     for(int i=0;i<5;i++)
19804,"    addl    $1, 28(%esp)     #, i"
19805,L2:
19806, # main1.c:4:     for(int i=0;i<5;i++)
19807,"    cmpl    $4, 28(%esp)     #, i"
19808,"    jle L3   #,"
19809, # main1.c:9:     int y = 10;
19810,"    movl    $10, 24(%esp)    #, y"
19811, # main1.c:10:  int a = 5;
19812,"    movl    $5, 20(%esp)     #, a"
19813, # main1.c:12:     return 0;
19814,"    movl    $0, %eax     #, _7"
19815, # main1.c:13: }
19816,    leave   
19817,    .cfi_restore 5
19818,"    .cfi_def_cfa 4, 4"
19819,    ret 
19820,    .cfi_endproc
19821,LFE13:
19822,"    .ident  ""GCC: (MinGW.org GCC Build-2) 9.2.0"""
19823,    .def    _printf;    .scl    2;  .type   32; .endef
19824, # main1.c:6:         int a=i;
19825,"movl    28(%esp), %eax   # i, tmp84"
19826,"movl    %eax, 16(%esp)   # tmp84, a"
19827,# main1.c:9:     int y = 10;
19828,"movl    $10, 24(%esp)    #, y"
19829,# main1.c:10:  int a = 5;
19830,"movl    $5, 20(%esp)     #, a"
19831,    #include <stdio.h>
19832,int main()
19833,{
19834,    int *ptr;
19835,    for(int i=0;i<5;i++)
19836,    {
19837,        int a=10;
19838,        ptr = &a;
19839,        int x;
19840,    }
19841,    int y = 10;
19842,
19843,"    printf(""a = %d\n"",*ptr); // how come a = 10?"
19844,    return 0;
19845,}
19846,    void func2()
19847,{
19848,    for(int i=0;i<5;i++)
19849,    {
19850,        int a=10;
19851,        int x;
19852,    }
19853,}
19854,
19855,void func1()
19856,{
19857,    for(int i=0;i<5;i++)
19858,    {
19859,        int a=10;
19860,        int x;
19861,        
19862,    }
19863,}
19864,
19865,int main()
19866,{
19867,    func1();
19868,    func2();
19869,    int y = 10;
19870,
19871,    return 0;
19872,}
19873,"        .file   ""main1.c"""
19874, # GNU C17 (MinGW.org GCC Build-2) version 9.2.0 (mingw32)
19875," #  compiled by GNU C version 9.2.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.21-GMP"
19876,
19877, # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
19878, # options passed:  -iprefix c:\mingw\bin\../lib/gcc/mingw32/9.2.0/ main1.c
19879, # -mtune=generic -march=i586 -auxbase-strip main2.s -fverbose-asm
19880, # options enabled:  -faggressive-loop-optimizations -fassume-phsa
19881, # -fasynchronous-unwind-tables -fauto-inc-dec -fcommon
19882, # -fdelete-null-pointer-checks -fdwarf2-cfi-asm -fearly-inlining
19883, # -feliminate-unused-debug-types -ffp-int-builtin-inexact -ffunction-cse
19884, # -fgcse-lm -fgnu-runtime -fgnu-unique -fident -finline-atomics
19885, # -fipa-stack-alignment -fira-hoist-pressure -fira-share-save-slots
19886, # -fira-share-spill-slots -fivopts -fkeep-inline-dllexport
19887, # -fkeep-static-consts -fleading-underscore -flifetime-dse
19888, # -flto-odr-type-merging -fmath-errno -fmerge-debug-strings -fpeephole
19889, # -fplt -fprefetch-loop-arrays -freg-struct-return
19890, # -fsched-critical-path-heuristic -fsched-dep-count-heuristic
19891, # -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
19892, # -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
19893, # -fsched-stalled-insns-dep -fschedule-fusion -fsemantic-interposition
19894, # -fset-stack-executable -fshow-column -fshrink-wrap-separate
19895, # -fsigned-zeros -fsplit-ivs-in-unroller -fssa-backprop -fstdarg-opt
19896, # -fstrict-volatile-bitfields -fsync-libcalls -ftrapping-math
19897, # -ftree-cselim -ftree-forwprop -ftree-loop-if-convert -ftree-loop-im
19898, # -ftree-loop-ivcanon -ftree-loop-optimize -ftree-parallelize-loops=
19899, # -ftree-phiprop -ftree-reassoc -ftree-scev-cprop -funit-at-a-time
19900, # -funwind-tables -fverbose-asm -fzero-initialized-in-bss -m32 -m80387
19901, # -m96bit-long-double -maccumulate-outgoing-args -malign-double
19902, # -malign-stringops -mavx256-split-unaligned-load
19903, # -mavx256-split-unaligned-store -mfancy-math-387 -mfp-ret-in-387
19904, # -mieee-fp -mlong-double-80 -mms-bitfields -mno-red-zone -mno-sse4
19905, # -mpush-args -msahf -mstack-arg-probe -mstv -mvzeroupper
19906,
19907,    .text
19908,    .globl  _func2
19909,    .def    _func2; .scl    2;  .type   32; .endef
19910,_func2:
19911,LFB0:
19912,    .cfi_startproc
19913,    pushl   %ebp     #
19914,    .cfi_def_cfa_offset 8
19915,"    .cfi_offset 5, -8"
19916,"    movl    %esp, %ebp   #,"
19917,    .cfi_def_cfa_register 5
19918,"    subl    $16, %esp    #,"
19919, # main1.c:3:         for(int i=0;i<5;i++)
19920,"    movl    $0, -4(%ebp)     #, i"
19921, # main1.c:3:         for(int i=0;i<5;i++)
19922,    jmp L2   #
19923,L3:
19924, # main1.c:5:             int a=10;
19925,"    movl    $10, -8(%ebp)    #, a"
19926, # main1.c:3:         for(int i=0;i<5;i++)
19927,"    addl    $1, -4(%ebp)     #, i"
19928,L2:
19929, # main1.c:3:         for(int i=0;i<5;i++)
19930,"    cmpl    $4, -4(%ebp)     #, i"
19931,"    jle L3   #,"
19932, # main1.c:8:     }
19933,    nop 
19934,    nop 
19935,    leave   
19936,    .cfi_restore 5
19937,"    .cfi_def_cfa 4, 4"
19938,    ret 
19939,    .cfi_endproc
19940,LFE0:
19941,    .globl  _func1
19942,    .def    _func1; .scl    2;  .type   32; .endef
19943,_func1:
19944,LFB1:
19945,    .cfi_startproc
19946,    pushl   %ebp     #
19947,    .cfi_def_cfa_offset 8
19948,"    .cfi_offset 5, -8"
19949,"    movl    %esp, %ebp   #,"
19950,    .cfi_def_cfa_register 5
19951,"    subl    $16, %esp    #,"
19952, # main1.c:12:         for(int i=0;i<5;i++)
19953,"    movl    $0, -4(%ebp)     #, i"
19954, # main1.c:12:         for(int i=0;i<5;i++)
19955,    jmp L5   #
19956,L6:
19957, # main1.c:14:             int a=10;
19958,"    movl    $10, -8(%ebp)    #, a"
19959, # main1.c:12:         for(int i=0;i<5;i++)
19960,"    addl    $1, -4(%ebp)     #, i"
19961,L5:
19962, # main1.c:12:         for(int i=0;i<5;i++)
19963,"    cmpl    $4, -4(%ebp)     #, i"
19964,"    jle L6   #,"
19965, # main1.c:18:     }
19966,    nop 
19967,    nop 
19968,    leave   
19969,    .cfi_restore 5
19970,"    .cfi_def_cfa 4, 4"
19971,    ret 
19972,    .cfi_endproc
19973,LFE1:
19974,    .def    ___main;    .scl    2;  .type   32; .endef
19975,    .globl  _main
19976,    .def    _main;  .scl    2;  .type   32; .endef
19977,_main:
19978,LFB2:
19979,    .cfi_startproc
19980,    pushl   %ebp     #
19981,    .cfi_def_cfa_offset 8
19982,"    .cfi_offset 5, -8"
19983,"    movl    %esp, %ebp   #,"
19984,    .cfi_def_cfa_register 5
19985,"    andl    $-16, %esp   #,"
19986,"    subl    $16, %esp    #,"
19987, # main1.c:21:     {
19988,    call    ___main  #
19989, # main1.c:22:         func1();
19990,    call    _func1   #
19991, # main1.c:23:      func2();
19992,    call    _func2   #
19993, # main1.c:24:         int y = 10;
19994,"    movl    $10, 12(%esp)    #, y"
19995, # main1.c:26:         return 0;
19996,"    movl    $0, %eax     #, _5"
19997, # main1.c:27:     }
19998,    leave   
19999,    .cfi_restore 5
20000,"    .cfi_def_cfa 4, 4"
20001,    ret 
20002,    .cfi_endproc
20003,LFE2:
20004,"    .ident  ""GCC: (MinGW.org GCC Build-2) 9.2.0"""
20005,     # main1.c:12:         for(int i=0;i<5;i++)
20006,"    movl    $0, -4(%ebp)     #, i"
20007, # main1.c:12:         for(int i=0;i<5;i++)
20008,    jmp L5   #
20009,L6:
20010, # main1.c:14:             int a=10;
20011,"    movl    $10, -8(%ebp)    #, a"
20012, # main1.c:12:         for(int i=0;i<5;i++)
20013,"    addl    $1, -4(%ebp)     #, i"
20014,L5:
20015, # main1.c:12:         for(int i=0;i<5;i++)
20016,"    cmpl    $4, -4(%ebp)     #, i"
20017,"    jle L6   #,"
20018, # main1.c:18:     }
20019,     # main1.c:3:         for(int i=0;i<5;i++)
20020,"    movl    $0, -4(%ebp)     #, i"
20021, # main1.c:3:         for(int i=0;i<5;i++)
20022,    jmp L2   #
20023,L3:
20024, # main1.c:5:             int a=10;
20025,"    movl    $10, -8(%ebp)    #, a"
20026, # main1.c:3:         for(int i=0;i<5;i++)
20027,"    addl    $1, -4(%ebp)     #, i"
20028,L2:
20029, # main1.c:3:         for(int i=0;i<5;i++)
20030,"    cmpl    $4, -4(%ebp)     #, i"
20031,"    jle L3   #,"
20032, # main1.c:8:     }
20033,    #include <stdio.h>
20034,
20035,    void func2()
20036,    {
20037,        int x = 10;
20038,"        printf(""address of x = %x\n"" , &x);"
20039,    }
20040,
20041,    void func1()
20042,    {
20043,        int y = 5;
20044,"        printf(""address of y = %x\n"" , &y);"
20045,    }
20046,
20047,    int main()
20048,    {
20049,
20050,        func1();
20051,        func2();
20052,        int y = 10;
20053,
20054,        return 0;
20055,    }
20056,#include <stdio.h>
20057,
20058,int main()
20059,{
20060,"    int c, i, x;"
20061,"    char s[10], r[10];"
20062,"    scanf(""%d"", &x);"
20063,
20064,"    for(i = 0, c = 0; i < x; i++){"
20065,"        scanf(""%s%s"", s, r);"
20066,        c++;
20067,        if(s[4] == 'a' && r[0] == 'l' || s[4] == 'a' && r[0] == 't'){
20068,"            printf(""Caso #%d: Bazinga!\n"", c);"
20069,        }
20070,        else if(s[0] == 'l' && r[4] == 'a' || s[0] == 't' && r[4] == 'a'){
20071,"            printf(""Caso #%d: Raj trapaceou!\n"", c);"
20072,        }
20073,
20074,        else if(s[0] == 'p' && r[4] == 'a' || s[0] == 'p' && r[0] == 's'){
20075,"            printf(""Caso #%d: Bazinga!\n"", c);"
20076,        }
20077,        else if(s[4] == 'a' && r[0] == 'p' || s[0] == 's' && r[0] == 'p'){
20078,"            printf(""Caso #%d: Raj trapaceou!\n"", c);"
20079,        }
20080,
20081,        else if(s[0] == 't' && r[0] == 'p' || s[0] == 't' && r[0] == 'l'){
20082,"            printf(""Caso #%d: Bazinga!\n"", c);"
20083,        }
20084,        else if(s[0] == 'p' && r[0] == 't' || s[0] == 'l' && r[0] == 't'){
20085,"            printf(""Caso #%d: Raj trapaceou!\n"", c);"
20086,        }
20087,
20088,        else if(s[0] == 'l' && r[0] == 's' || s[0] == 'l' && r[0] == 'p'){
20089,"            printf(""Caso #%d: Bazinga!\n"", c);"
20090,        }
20091,        else if(s[0] == 's' && r[0] == 'l' || s[0] == 'p' && r[0] == 'l'){
20092,"            printf(""Caso #%d: Raj trapaceou!\n"", c);"
20093,        }
20094,
20095,        else if(s[0] == 's' && r[0] == 't' || s[0] == 's' && r[4] == 'a'){
20096,"            printf(""Caso #%d: Bazinga!\n"", c);"
20097,        }
20098,        else if(s[0] == 't' && r[0] == 's' || s[4] == 'a' && r[0] == 's'){
20099,"            printf(""Caso #%d: Raj trapaceou!\n"", c);"
20100,        }
20101,        else if(s[4] == 'a' && r[4] == 'a' || s[0] == 'p' && r[0] == 'p' || s[0] == 't' && r[0] == 't' || s[0] == 'l' && r[0] == 'l' || s[0] == 's' && r[0] == 's'){
20102,"            printf(""Caso #%d: De novo!\n"", c);"
20103,        }
20104,
20105,    }
20106,}
20107,[2]
20108,s
20109,r
20110,d: pedra
20111,p: papel
20112,s: tesoura
20113,g: legarto
20114,o: spock
20115,novo: 
20116,
20117,s[2] == r[2]
20118,
20119,bazinga:
20120,
20121,s[2] == 's' && r[2] == 'p'
20122,s[2] == 'p' && r[2] == 'd'
20123,s[2] == 'd' && r[2] == 'g'
20124,s[2] == 'g' && r[2] == 'o'
20125,s[2] == 'o' && r[2] == 's'
20126,s[2] == 's' && r[2] == 'g'
20127,s[2] == 'g' && r[2] == 'p'
20128,s[2] == 'p' && r[2] == 'o'
20129,s[2] == 'o' && r[2] == 'd'
20130,s[2] == 'd' && r[2] == 's'
20131,
20132,trapaceou: otherwise.
20133,./main -r 213
20134,./main -o bmp
20135,"int r, g, b, c;"
20136,char t[3];
20137,"while ((c = getopt (argc, argv, ""abc:"")) != -1)"
20138,    switch (c)
20139,      {
20140,      case 'r':
20141,"        printf(""Option r has option %s\n"", optarg);"
20142,        break;
20143,      case 'g':
20144,"        printf(""Option g has option %s\n"", optarg);"
20145,        break;
20146,      case 'b':
20147,"        printf(""Option b has option %s\n"", optarg);"
20148,        break;
20149,        break;
20150,      case 't':
20151,"        printf(""Option t has option %s\n"", optarg);"
20152,        break;
20153,      }
20154,./main -r 123 -g 89 -b -76
20155,./main: invalid option -- 'r'
20156,
20157,./main: invalid option -- 'g'
20158,
20159,Option b has option (null)
20160,
20161,./main: invalid option -- '7'
20162,
20163,./main: invalid option -- '6'
20164,getopt()
20165,-a
20166,-b
20167,-c
20168,abc:
20169,c
20170,abc:
20171,b:g:r:t:
20172,#define _POSIX_C_SOURCE 2
20173,#include <stdio.h>
20174,#include <unistd.h>
20175,
20176,"int main(int argc, char **argv) {"
20177,    char c;
20178,"    while ((c = getopt (argc, argv, ""b:g:r:t:"")) != -1) {"
20179,        switch (c) {
20180,            case 'b':
20181,"                printf(""Option b has option %s\n"", optarg);"
20182,                break;
20183,            case 'g':
20184,"                printf(""Option g has option %s\n"", optarg);"
20185,                break;
20186,            case 'r':
20187,"                printf(""Option r has option %s\n"", optarg);"
20188,                break;
20189,            case 't':
20190,"                printf(""Option t has option %s\n"", optarg);"
20191,                break;
20192,        }
20193,    }
20194,    return 0;
20195,}
20196,$ ./main -r 123 -g 89 -b -76
20197,Option r has option 123
20198,Option g has option 89
20199,Option b has option -76
20200,#include <stdio.h>
20201,#include <unistd.h>
20202,#include <fcntl.h>
20203,#include <sys/stat.h>
20204,#include <semaphore.h>
20205,"int main(int argc, char* argv[]) {"
20206,"    sem_t* p = sem_open(""ec_initial_name_sem"", O_RDWR|O_CREAT, 0777, 1); "
20207,    while(1) { usleep(10000000); }
20208,}
20209,g++ main.cpp -lpq
20210,g++
20211,cmake_minimum_required(VERSION 3.5.1)
20212,project(day_g)
20213,
20214,"set(CMAKE_CXX_FLAGS ""-lpq"")"
20215,
20216,add_definitions(-lpq)
20217,
20218,"message(""CMAKE_CXX_FLAGS is ${CMAKE_CXX_FLAGS}"")"
20219,
20220,set(CMAKE_CXX_STANDARD 11)
20221,
20222,set(SOURCE_FILES main.cpp)
20223,add_executable(day_g ${SOURCE_FILES})
20224,CMAKE_CXX_FLAGS
20225,CMAKE_CXX_FLAGS is -lpq
20226,-- Configuring done
20227,-- Generating done
20228,-l
20229,target_link_libraries(day_g pq)
20230,-l
20231,target_link_libraries(day_g pq)
20232,"set(CMAKE_CXX_FLAGS ""-lpq"")"
20233,add_definitions(-lpq)
20234,add_definitions
20235,target_link_libraries()
20236,add_executable
20237,CMakeLists.txt
20238,target_link_libraries(target_name libraries...)
20239,target_link_libraries(day_g pq)
20240,"set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -O3"")"
20241,make VERBOSE=1
20242,#include<stdio.h>
20243,#include<stdlib.h>
20244,
20245,char PalindromeCheck (int number){
20246,   int NumCopy = number;
20247,   while (NumCopy != 0){
20248,      int LastDigit = NumCopy % 10;
20249,      NumCopy = NumCopy / 10;
20250,      if (LastDigit != NumCopy % 10){
20251,"         return ""Not a Palindrome"";"
20252,      }
20253,   }
20254,"   return ""Palindrome"";"
20255,}
20256,int main(void)
20257,{
20258,"   printf(""Enter a number: "");"
20259,"   int n = scanf(""%d"", &n);"
20260,"   printf(""%s"", PalindromeCheck(n));"
20261,   return 0;
20262,}
20263,"int n = scanf(""%d"", &n);"
20264,scanf
20265,"printf(""%s"", PalindromeCheck(n));"
20266,char
20267,%s
20268,const char*
20269,char*
20270,char
20271,char
20272,char*
20273,"int n = scanf(""%d"", &n);"
20274,scanf()
20275,scanf()
20276,if (LastDigit != NumCopy % 10)
20277,if (NumCopy != 0 && LastDigit != NumCopy % 10)
20278,    #include<stdio.h>
20279,#include<stdlib.h>
20280,
20281,char* PalindromeCheck (int number){
20282,    int NumCopy = number;
20283,    while (NumCopy != 0){
20284,        int LastDigit = NumCopy % 10;
20285,        NumCopy = NumCopy / 10;
20286,        if (NumCopy != 0 && LastDigit != NumCopy % 10){
20287,"            return ""Not a Palindrome"";"
20288,        }
20289,    }
20290,"    return ""Palindrome"";"
20291,}
20292,int main(void)
20293,{
20294,"    printf(""Enter a number: "");"
20295,    int n;
20296,"    scanf(""%d"", &n);"
20297,"    printf(""%s"", PalindromeCheck(n));"
20298,    return 0;
20299,}
20300,#include<stdio.h>
20301,#include<stdlib.h>
20302,#include<string.h>
20303,
20304,char* PalindromeCheck (int number){
20305,   char* toReturn = (char*) malloc(sizeof(char) * 17);
20306,   int NumCopy = number;
20307,   while (NumCopy != 0){
20308,      int LastDigit = NumCopy % 10;
20309,      NumCopy = NumCopy / 10;
20310,      if (LastDigit != NumCopy % 10){
20311,"         strncpy(toReturn,""Not a Palindrome"", 17);"
20312,         return toReturn;
20313,      }
20314,   }
20315,"   strncpy(toReturn,""Palindrome"", 11);"
20316,   return toReturn;
20317,}
20318,int main(void)
20319,{
20320,"   printf(""Enter a number: "");"
20321,   int n;
20322,"   scanf(""%d"", &n);"
20323,"   printf(""%s\n"", PalindromeCheck(n));"
20324,   return 0;
20325,}
20326,#define MOTOR_CON           PORTA
20327,
20328,"#define DC_ENABLE_ON        sbi(PORTA, 3)"
20329,"#define DC_ENABLE_OFF       cbi(PORTA, 3)"
20330,
20331,"#define DC_PHASE_ON         sbi(PORTA, 2)"
20332,"#define DC_PHASE_OFF        cbi(PORTA, 2)"
20333,
20334,"#define DC_MODE_ON          sbi(PORTA, 1)"
20335,"#define DC_MODE_OFF         cbi(PORTA, 1)"
20336,    
20337,void MotorSpeedSwingUp(void)
20338,{
20339,    DC_ENABLE_ON;
20340,}
20341,
20342,void MotorSpeedSwingDn(void)
20343,{
20344,    DC_ENABLE_OFF;
20345,}
20346,
20347,void MotorForwardPhase(void)
20348,{
20349,    DC_PHASE_ON;
20350,    DC_MODE_OFF;
20351,}
20352,
20353,void MotorReversePhase(void)
20354,{
20355,    DC_PHASE_OFF;
20356,    DC_MODE_OFF;
20357,}
20358,
20359,void MotorRun(void)
20360,{
20361,    if(motor_swing_flag == TRUE)
20362,    {
20363,        motor_swing_flag = FALSE;
20364,        MotorSpeedSwingUp();
20365,    }
20366,    else
20367,    {
20368,        motor_swing_flag = TRUE;
20369,        MotorSpeedSwingDn();
20370,    }
20371,}
20372,
20373,void MotorBrake(void)
20374,{
20375,    DC_PHASE_OFF;//Forward
20376,    DC_ENABLE_OFF;
20377,    DC_MODE_ON;
20378,}
20379,9.2.3.1 Pulse Width Modulating ENABLE
20380,usleep()
20381,#define CYCLE 200       // 200usec for 1 cycle
20382,#include <unistd.h>
20383,
20384,/*
20385," * have the motor run at ""duty"" speed for ""duration"" seconds"
20386, * 0.0 <= duty <= 1.0
20387, */
20388,"void PwmRun(double duty, int duration)"
20389,{
20390,"    if (duty < 0.) duty = 0.;                   // lower limit of ""duty"""
20391,"    if (duty > 1.) duty = 1.;                   // upper limit of ""duty"""
20392,
20393,    int ontime = (int)(CYCLE * duty);           // PWM on time
20394,    int offtime = (int)(CYCLE * (1. - duty));   // PWM off time
20395,
20396,    for (int t = 0; t < duration * 1000000; t += CYCLE) {
20397,        if (ontime > 0) DC_ENABLE_ON;
20398,        usleep(ontime);
20399,        if (offtime > 0) DC_ENABLE_OFF;
20400,        usleep(offtime);
20401,    }
20402,}
20403,
20404,// example to run the motor at 70% speed for 3 seconds
20405,"PwmRun(0.7, 3);"
20406,duration
20407,PwmRun()
20408,for
20409,for (1) { ..
20410,"int   i = 2, j=3, k,l;"
20411,"float   a, b;"
20412,k = i / j * j;
20413,l = j / i * i;
20414,a = i / j * j;
20415,b = j / i * i;
20416,"printf( ""%d %d %f %f"", k, l, a, b );"
20417,k = i / j * j;
20418,j > i
20419,i / j
20420,0 * j
20421,a
20422,b
20423,a ÷ b•c
20424,a / (b * c)
20425,(a / b) * c
20426,(a / b) * c
20427,a / (b * c)
20428,k = i / j * j;
20429,  = (i / j) * j;
20430,  = (2 / 3) * 3
20431,  = 0 * 3
20432,  = 0
20433,#include <string.h>
20434,#include <stdio.h>
20435,
20436,"printf(""%d\n"", strncmp(""test\200"", ""test\0"", 6));"
20437,strcmp
20438,\0
20439,strcmp()?
20440,test\0\0
20441,0
20442,"strncmp(""test\200"",""test"",6)"
20443,\200
20444,\0
20445,#include <stdio.h>
20446,#include <string.h>
20447,
20448,int main(void) {
20449,"    printf(""%d\n"", strncmp(""\200"", """", 1));"
20450,    return 0;
20451,}
20452,#include <stdio.h>
20453,#include <stdlib.h>
20454,
20455,int main(void) {
20456,  int size = 0;
20457,"  printf(""Enter size: "");"
20458,"  scanf(""%d"", &size);"
20459,"  int *a = calloc(size, sizeof(int));"
20460,  // initialize the array with some values
20461,  for (int i = 0; i < size; i++) a[i] = size - i;
20462,  // print out the array values
20463,  for (int i = 0; i < size; i++)
20464,"    printf(""a[%d] = %d\n"", i, a[i]);"
20465,"  printf(""\na: %p\n"", a);"
20466,  
20467,"  a = realloc(a, sizeof(int) * (size + 5));"
20468,  // set the additional 2 int values in the array to 9
20469,  for (int i = size; i < (size+2); i++) a[i] = 9;
20470,
20471,  for (int i = 0; i < (size+2); i++)
20472,"    printf(""a[%d] = %d\n"", i, a[i]);"
20473,"  printf(""\n"");"
20474,
20475,  int *save = a; 
20476,  free(a); 
20477,"  printf(""save: %p\n"", save);"
20478,  for (int i = 0; i < (size+2); i++)
20479,"    printf(""save[%d] = %d\n"", i, save[i]);"
20480,
20481,  return 0;
20482,} 
20483,save[0] = 5
20484,save[1] = 4
20485,save[2] = 3
20486,save[3] = 2
20487,save[4] = 1
20488,save[5] = 9
20489,save[6] = 9
20490,save[0] = -1397267184
20491,save[1] = 576
20492,save[2] = -1397292720
20493,save[3] = 576
20494,save[4] = 1
20495,save[5] = 9
20496,save[6] = 9
20497,-fsanitize=address
20498,printf
20499,save
20500,a
20501,printf
20502,malloc
20503,free(a);
20504,malloc
20505,a
20506,int *save = a;
20507,calloc()
20508,[mc]alloc()
20509,fopen()
20510,scanf()
20511,int
20512,malloc
20513,free
20514,free
20515,save
20516,a
20517,a
20518,free
20519,save 
20520,#include <stdio.h>
20521,int main(){
20522,    int val = 30;
20523,    FILE *file;
20524,"    if(!(fopen(""file.bin"",""wb""))){"
20525,"        fwrite(&val,sizeof(int),1,file);"
20526,        fclose(file);
20527,    }
20528,    return 0;
20529,}
20530,htonl
20531,file
20532,"fwrite(&val, sizeof(int), 1, file);"
20533,int
20534,int
20535,"putc((val >> 8) & 0xff, file);     /* MSB */"
20536,"putc( val       & 0xff, file);     /* LSB */"
20537,int
20538,val
20539,"putc( val       & 0xff, file);     /* LSB */"
20540,"putc((val >> 8) & 0xff, file);     /* MSB */"
20541,getc
20542,val  = getc(file);
20543,val |= getc(file) << 8;
20544,val
20545,unsigned
20546,#include <stdio.h>
20547,#include <stdlib.h>
20548,#include <string.h>
20549,
20550,struct fest {
20551,    struct fest* next;
20552,    char Name[10];
20553,    int  Zahl;
20554,};
20555,
20556,struct fest* anker = NULL;
20557,
20558,int main (void){
20559,   
20560,    for(int i=0; i< 4; i++)
20561,    {
20562,        struct fest* zeiger;
20563,        if((zeiger=malloc(sizeof(struct fest)))!=NULL)
20564,        {
20565,            zeiger->Zahl = i+1;
20566,            
20567,            switch(i){
20568,"                case 0: char letter1[] =""Whisky\n"";strcpy(zeiger->Name,letter1); break; //error"
20569,"                case 1: char letter2[] =""Tango\n"";strcpy(zeiger->Name,letter2); break;"
20570,"                case 2: char letter3[]=""Foxtrott\n"";strcpy(zeiger->Name,letter3); break;"
20571,"                case 3: char letter4[]=""X-Ray\n"";strcpy(zeiger->Name,letter4); break;"
20572,            }
20573,
20574,            zeiger->next = anker;
20575,            anker = zeiger;
20576,        }
20577,    }
20578,    struct fest* abruf= anker;
20579,
20580,    while(abruf !=NULL){
20581,"        printf(""%d %s\n"", abruf->Zahl, abruf->Name);"
20582,        abruf = abruf->next;
20583,    }
20584,
20585,    return 0;
20586,}´´´
20587,char*
20588,char[10]
20589,"strcpy(x, ""y"")"
20590,"char* words[] = { ""whisky"", ""..."", ... }"
20591,words[n]
20592,NULL
20593,strcpy
20594,case
20595,            switch(i){
20596,"                case 0: {char letter1[] =""Whisky\n"";strcpy(zeiger->Name,letter1); break; }"
20597,"                case 1: {char letter2[] =""Tango\n"";strcpy(zeiger->Name,letter2); break;}"
20598,"                case 2: {char letter3[]=""Foxtrott\n"";strcpy(zeiger->Name,letter3); break;}"
20599,"                case 3: {char letter4[]=""X-Ray\n"";strcpy(zeiger->Name,letter4); break;}"
20600,            }
20601,"strcpy(zeiger->Name, ""X-Ray\n"");"
20602,case
20603,switch(i){
20604,"            case 0: {char letter1[] =""Whisky\n"";strcpy(zeiger->Name,letter1); break;} "
20605,"            case 1: {char letter2[] =""Tango\n"";strcpy(zeiger->Name,letter2); break;}"
20606,"            case 2: {char letter3[]=""Foxtrott\n"";strcpy(zeiger->Name,letter3); break;}"
20607,"            case 3: {char letter4[]=""X-Ray\n"";strcpy(zeiger->Name,letter4); break;}"
20608,        }
20609,switch(i){
20610,            case 0: {
20611,"                char letter1[] =""Whisky\n"";"
20612,"                strcpy(zeiger->Name,letter1);"
20613,                break;
20614,            } 
20615,            case 1: {
20616,"                char letter2[] =""Tango\n"";"
20617,"                strcpy(zeiger->Name,letter2);"
20618,                break;
20619,            }
20620,            case 2: {
20621,"                char letter3[]=""Foxtrott\n"";"
20622,"                strcpy(zeiger->Name,letter3);"
20623,                break;
20624,            }
20625,            case 3: {
20626,"                char letter4[]=""X-Ray\n"";"
20627,"                strcpy(zeiger->Name,letter4);"
20628,                break;
20629,            }
20630,        }
20631,while ((ch = getc(fp)) != EOF) {
20632,  ...
20633,}
20634,getc
20635,fp
20636,getc
20637,ch
20638,ch
20639,EOF
20640,-1
20641,EOF
20642,End Of File
20643,getc
20644,EOF
20645,ch
20646,int
20647,char
20648,getc
20649,EOF
20650,EOF
20651,EOF
20652,getc
20653,fp
20654,getc
20655,fp
20656,getc
20657,ch
20658,getc
20659,int
20660,ch = getc(fp)
20661,ch
20662,ch
20663,ch
20664,ch
20665,int
20666,ch
20667,EOF
20668,ch
20669,EOF
20670,getc
20671,EOF
20672,ch
20673,EOF
20674,ch
20675,EOF
20676,-1
20677,EOF
20678,int
20679,EOF
20680,End Of File
20681,EOF
20682,getc
20683,stream
20684,EOF
20685,getc
20686,EOF
20687,rewind
20688,clearerr
20689,getc
20690,EOF
20691,EOF
20692,clearerr()
20693,ch != EOF
20694,EOF
20695,clearerr()
20696,tail -f
20697,because the ch != EOF condition fails when you get to the end
20698,EOF
20699,feof()
20700,EOF
20701,feof
20702,EOF
20703,feof()
20704,EOF
20705,feof()
20706,#include<stdio.h>
20707,#include<cs50.h>
20708,#include<math.h>
20709,int main(void){
20710, int changeswhithcustomer;
20711,do{
20712,"     changeswhithcustomer = get_int(""how much changes you want to exchange ? "");"
20713,}while(changeswhithcustomer < 0);
20714,int coins = 0;
20715,while(changeswhithcustomer >= 25){
20716,  changeswhithcustomer = changeswhithcustomer - 25;
20717,    coins++;
20718,}
20719,while(changeswhithcustomer >= 10){
20720,  changeswhithcustomer = changeswhithcustomer - 10;
20721,    coins++;
20722,}
20723,while(changeswhithcustomer >= 5){
20724,  changeswhithcustomer = changeswhithcustomer - 5;
20725,    coins++;
20726,}
20727,while(changeswhithcustomer >= 1){
20728,  changeswhithcustomer = changeswhithcustomer - 1;
20729,    coins++;
20730,}
20731,"printf(""%i\n"",coins);"
20732,}
20733,#include <math.h>
20734,return 0;
20735,coins
20736,#ifdef CS50_POLYFILL
20737,int get_int(const char *s) {
20738,"    printf(""%s"", s);"
20739,    int i;
20740,"    scanf(""%d"", &i);"
20741,    return i;
20742,}
20743,#else
20744,#include <cs50.h>
20745,#endif
20746,#include <stdio.h>
20747,
20748,"unsigned change(unsigned amount, unsigned face_value, unsigned *count) {"
20749,    for(*count = 0; amount >= face_value; (*count)++)
20750,        amount -= face_value;
20751,    return amount;
20752,}
20753,
20754,int main(void) {
20755,    struct {
20756,        unsigned face_value;
20757,        unsigned count;
20758,    } coins[] = {
20759,"        { .face_value = 25 },"
20760,"        { .face_value = 10 },"
20761,"        { .face_value = 5 },"
20762,"        { .face_value = 1 },"
20763,    };
20764,"    int amount = get_int(""how much changes you want to exchange? "");"
20765,    if(amount < 0)
20766,        return 0;
20767,    for(unsigned i = 0; i < sizeof(coins) / sizeof(*coins); i++) {
20768,"        amount = change(amount, coins[i].face_value, &coins[i].count);"
20769,        if(coins[i].count)
20770,"            printf(""face value %u: count: %u\n"","
20771,"                coins[i].face_value,"
20772,                coins[i].count
20773,            );
20774,    }
20775,    return 0;
20776,}
20777,how much changes you want to exchange? 73
20778,face value 25: count: 2
20779,face value 10: count: 2
20780,face value 1: count: 3
20781,"<?xml version=""1.0"" encoding=""UTF-8""?>"
20782,<!-- Generated with glade 3.22.2 -->
20783,<interface>
20784,"  <requires lib=""gtk+"" version=""3.20""/>"
20785,"  <object class=""GtkImage"" id=""image1"">"
20786,"    <property name=""visible"">True</property>"
20787,"    <property name=""can_focus"">False</property>"
20788,"    <property name=""stock"">gtk-justify-fill</property>"
20789,  </object>
20790,"  <object class=""GtkApplicationWindow"" id=""window"">"
20791,"    <property name=""can_focus"">False</property>"
20792,"    <child type=""titlebar"">"
20793,      <placeholder/>
20794,    </child>
20795,    <child>
20796,"      <object class=""GtkGrid"" id=""grid"">"
20797,"        <property name=""visible"">True</property>"
20798,"        <property name=""can_focus"">False</property>"
20799,        <child>
20800,"          <object class=""GtkButton"" id=""button"">"
20801,"            <property name=""width_request"">24</property>"
20802,"            <property name=""height_request"">24</property>"
20803,"            <property name=""visible"">True</property>"
20804,"            <property name=""can_focus"">True</property>"
20805,"            <property name=""receives_default"">True</property>"
20806,"            <property name=""image"">image1</property>"
20807,"            <signal name=""clicked"" handler=""on_button_clicked"" swapped=""no""/>"
20808,          </object>
20809,          <packing>
20810,"            <property name=""left_attach"">0</property>"
20811,"            <property name=""top_attach"">0</property>"
20812,          </packing>
20813,        </child>
20814,      </object>
20815,    </child>
20816,  </object>
20817,</interface>
20818,"<?xml version=""1.0"" encoding=""UTF-8""?>"
20819,<interface>
20820,"  <menu id=""menu"">"
20821,    <section>
20822,      <item>
20823,"        <attribute name=""label"" translatable=""yes"">_Preferences</attribute>"
20824,"        <attribute name=""action"">app.preferences</attribute>"
20825,      </item>
20826,    </section>
20827,    <section>
20828,      <item>
20829,"        <attribute name=""label"" translatable=""yes"">_Quit</attribute>"
20830,"        <attribute name=""action"">app.quit</attribute>"
20831,      </item>
20832,    </section>
20833,  </menu>
20834,</interface>
20835,#include <gtk/gtk.h>
20836,
20837,GtkWidget       *window;
20838,GtkWidget       *button;
20839,GMenuModel      *menu;
20840,GtkWidget       *popover;
20841,GtkBuilder      *builder;
20842,GtkBuilder      *buildmenu;
20843,GSimpleAction   *quit_action;
20844,
20845,void on_button_clicked(GtkWidget *widget)
20846,{
20847,    gtk_widget_show_all(popover);
20848,}
20849,
20850,"int main(int argc, char *argv[])"
20851,{
20852,"    gtk_init(&argc, &argv);"
20853,
20854,"    builder     = gtk_builder_new_from_file(""/home/craig/C_Programs/GTK_Projects/PopoverMenu/PopoverMenu.ui"");"
20855,
20856,"    buildmenu   = gtk_builder_new_from_file(""/home/craig/C_Programs/GTK_Projects/PopoverMenu/menu.ui"");"
20857,
20858,"    window      = GTK_WIDGET(gtk_builder_get_object(builder, ""window""));"
20859,"    button      = GTK_WIDGET(gtk_builder_get_object(builder, ""button""));"
20860,
20861,"    menu = G_MENU_MODEL(gtk_builder_get_object(buildmenu, ""menu""));"
20862,
20863,"    popover     = gtk_popover_new_from_model(button, G_MENU_MODEL(menu));"
20864,
20865,"    gtk_builder_connect_signals(builder, NULL);"
20866,
20867,"    quit_action = g_simple_action_new (""quit"", NULL);"
20868,"    g_signal_connect (quit_action, ""activate"", G_CALLBACK (gtk_main_quit), window);"
20869,
20870,"    g_signal_connect(G_OBJECT(window), ""destroy"", G_CALLBACK(gtk_main_quit), G_OBJECT(window));"
20871,
20872,"    gtk_window_set_default_size(GTK_WINDOW(window), 400, 200);"
20873,
20874,    gtk_widget_show_all(window);
20875,
20876,    gtk_main();
20877,
20878,    return 0;
20879,}
20880,# this line is a full comment that might be pseudo-code or whatever
20881,"4, 2 # 4, 3  "
20882,1  
20883,# 9  
20884,7  
20885,endNode  
20886,endNet
20887,#include <stdio.h>
20888,#include <string.h>
20889,#define BUFF_SIZE 1024
20890,#define COMMENT_MARKER '#'
20891,int main()
20892,{
20893,
20894,FILE *fp;
20895,char buffer[BUFF_SIZE];
20896,
20897,"if ((fp = fopen(""F:\\PythonProjects\\C\\text.txt"", ""r"")) == NULL)"
20898,{
20899,"    perror(""Error opening file"");"
20900,    exit(1);
20901,}
20902,
20903,"while (fgets(buffer, BUFF_SIZE, fp) != NULL)"
20904,{
20905,"    char *comment = strchr(buffer, COMMENT_MARKER);"
20906,    if (comment != NULL)
20907,    {
20908,        size_t len = strlen(comment);
20909,"        memset(comment, '\0', len);"
20910,"        printf(""%s"", buffer);"
20911,        
20912,    }
20913,}
20914,fclose(fp);
20915,}
20916,#
20917,memset()
20918,if (comment) *comment = 0;
20919,buffer
20920,printf()
20921,if
20922,#
20923,#
20924,memset()
20925,#include <stdio.h>
20926,#include <string.h>
20927,#include <stdlib.h> // Needed for exit()
20928,
20929,#define BUFF_SIZE 1024
20930,#define COMMENT_MARKER '#'
20931,
20932,int main()
20933,{
20934,  FILE *fp;
20935,  char buffer[BUFF_SIZE];
20936,
20937,"  if ((fp = fopen(""text.txt"", ""r"")) == NULL)"
20938,    {
20939,"      perror(""Error opening file"");"
20940,      exit(1);
20941,    }
20942,
20943,"  char tokens[3] = { COMMENT_MARKER, '\n', '\0' };"
20944,  
20945,"  while (fgets(buffer, BUFF_SIZE, fp) != NULL)"
20946,    {
20947,      // Look for the first # or newline in the string
20948,"      char *comment_or_nl = strpbrk(buffer, tokens);"
20949,      if (comment_or_nl)
20950,        {
20951,"          // and if found, replace it with a nul byte"
20952,          *comment_or_nl = '\0';
20953,        }
20954,      // Then print out the possibly-truncated string (puts() adds a newline)
20955,      puts(buffer);
20956,    }
20957,  
20958,  fclose(fp);
20959,  return 0;
20960,}
20961,BUFFER_LEN
20962,#
20963,BUFFER_LEN
20964,puts()
20965,:-)
20966,#include <stdio.h>
20967,#include <string.h>
20968,#define BUFF_SIZE 1024
20969,#define COMMENT_MARKER '#'
20970,
20971,int main()
20972,{
20973,    FILE *fp;
20974,"    if ((fp = fopen(""F:\\PythonProjects\\C\\text.txt"", ""r"")) == NULL)"
20975,    {
20976,"        perror(""Error opening file"");"
20977,        exit(1);
20978,    }
20979,
20980,    char buffer[BUFF_SIZE]; // declare variables proximate to use
20981,"    while (fgets(buffer, BUFF_SIZE, fp) != NULL)"
20982,    {
20983,"        char *comment = strchr(buffer, COMMENT_MARKER);"
20984,        if (comment != NULL)
20985,        {
20986,"            strcpy( comment, ""\n"" ); // Just clobber the comment section"
20987,        }
20988,"        printf(""%s"", buffer); // Always print something"
20989,    }
20990,    fclose(fp);
20991,}
20992,int result;
20993,
20994,result = 125/100;
20995,result = 43/100;
20996,"""I just throw the dam fraction part in the trash and move on with life"""
20997,(a / b) * b + a % b == a
20998,a % b
20999,a
21000,a % b
21001,a
21002,b
21003,reliable integer division
21004,*-*
21005,expr1 / expr2
21006,expr1 % expr2
21007,expr1
21008,expr2
21009,-5 / 2 = -2
21010, 5 / 2 =  2
21011,filtered = (k - 1) * filtered + value + carry; carry = filtered % factor; filtered /= factor
21012,value
21013,k
21014,carry
21015,div
21016,factor
21017,filtered += (filter+(factor div 2)) div factor
21018,INT_MAX-(factor div 2)
21019,int integerDivisionResultPositive= 125/100;//= 1
21020,double flooringResultPositive= floor(125.0/100.0);//=1.0
21021,int integerDivisionResultNegative= -125/100;//=-1
21022,double flooringResultNegative= floor(-125.0/100.0);//=-2.0
21023,5 / 2 = 2
21024,5.0 / 2 or 5 / 2.0 or 5.0 /2.0 = 2.5
21025,"for i in itertools.combinations(DictAthleteObjects.keys()),8):"
21026,   do stuff here on instances of classes
21027,import time
21028,start_time = time.process_time()
21029,// stuff
21030,print(f'runtime(sec): {time.process_time() - start_time}')
21031,# Code to check how long itertools.combinations() takes to run
21032,import itertools
21033,import time
21034,
21035,data = []
21036,for i in range(250000):
21037,    data.append(i)
21038,
21039,ncombos = (250000 * 249999) / 2
21040,
21041,"for num_items in range(2, 9):"
21042,    start_time = time.process_time()
21043,"    g = itertools.combinations(data, num_items)"
21044,    print(f'combo_sz:{num_items} num_combos:{ncombos} elapsed(sec):{time.process_time() - start_time}')
21045,Dr.Memory
21046,Dr.Memory
21047,int main() {
21048,"    clock_t start, end;"
21049,    float cpu_time_used;
21050,    start = clock();
21051,
21052,"    int array[5] = {2, 4, 5, 6, 7};"
21053,    int number = array[10];
21054,"    printf(""This is a number: %i\n"", number);"
21055,
21056,    end = clock();
21057,    cpu_time_used = ((float) (end - start)) / CLOCKS_PER_SEC;
21058,"    printf(""\nTotal speed  was %f\n"", cpu_time_used);"
21059,
21060,
21061,    return EXIT_SUCCESS;
21062,}
21063,Dr.Memory
21064,Dr. Memory version 2.5.0 build 0 built on Oct 18 2021 03:01:22
21065,Windows version: WinVer=105;Rel=2009;Build=22000;Edition=Professional
21066,"Dr. Memory results for pid 9640: ""CControl.exe"""
21067,"Application cmdline: """"C:\Users\dmn\OneDrive - ITH\Dokument\Projekt\Eclipse\CControl\Debug\CControl.exe"""""
21068,Recorded 124 suppression(s) from default C:\Program Files (x86)\Dr. Memory\bin64\suppress-default.txt
21069,
21070,Error #1: UNADDRESSABLE ACCESS beyond top of stack: reading 0x000000164a9ff980-0x000000164a9ff988 8 byte(s)
21071,# 0 ___chkstk_ms                            [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:132]
21072,# 1 _pei386_runtime_relocator
21073,# 2 __tmainCRTStartup
21074,# 3 .l_start    
21075,# 4 ntdll.dll!RtlUserThreadStart
21076,Note: @0:00:00.097 in thread 18604
21077,Note: 0x000000164a9ff980 refers to 664 byte(s) beyond the top of the stack 0x000000164a9ffc18
21078,Note: instruction: or     $0x0000000000000000 (%rcx) -> (%rcx)
21079,
21080,Error #2: UNADDRESSABLE ACCESS beyond top of stack: reading 0x000000164a9ffa50-0x000000164a9ffa58 8 byte(s)
21081,# 0 ___chkstk_ms                       [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:132]
21082,# 1 __pformat_int.isra.0               [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21083,# 2 __mingw_pformat                    [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21084,# 3 __mingw_vfprintf                   [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21085,# 4 printf      
21086,# 5 main        
21087,Note: @0:00:00.135 in thread 18604
21088,Note: 0x000000164a9ffa50 refers to 8 byte(s) beyond the top of the stack 0x000000164a9ffa58
21089,Note: instruction: or     $0x0000000000000000 (%rcx) -> (%rcx)
21090,
21091,Error #3: UNINITIALIZED READ: reading register rcx
21092,# 0 __pformat_int.isra.0               [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21093,# 1 __mingw_pformat                    [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21094,# 2 __mingw_vfprintf                   [../../../../../src/gcc-11.2.0/libgcc/config/i386/cygwin.S:138]
21095,# 3 printf      
21096,# 4 main        
21097,Note: @0:00:00.135 in thread 18604
21098,Note: instruction: test   %rcx %rcx
21099,
21100,Error #4: POSSIBLE LEAK 98 direct bytes 0x00000153bd9001c0-0x00000153bd900222 + 0 indirect bytes
21101,# 0 replace_malloc                   [d:\a\drmemory\drmemory\common\alloc_replace.c:2580]
21102,# 1 msvcrt.dll!malloc_crt
21103,# 2 msvcrt.dll!_setargv  
21104,# 3 msvcrt.dll!_getmainargs
21105,# 4 pre_cpp_init
21106,# 5 msvcrt.dll!initterm  
21107,# 6 __tmainCRTStartup
21108,# 7 .l_start    
21109,# 8 ntdll.dll!RtlUserThreadStart
21110,
21111,===========================================================================
21112,FINAL SUMMARY:
21113,
21114,DUPLICATE ERROR COUNTS:
21115,    Error #   1:      2
21116,    Error #   2:      2
21117,
21118,SUPPRESSIONS USED:
21119,
21120,ERRORS FOUND:
21121,"      2 unique,     4 total unaddressable access(es)"
21122,"      1 unique,     1 total uninitialized access(es)"
21123,"      0 unique,     0 total invalid heap argument(s)"
21124,"      0 unique,     0 total GDI usage error(s)"
21125,"      0 unique,     0 total handle leak(s)"
21126,"      0 unique,     0 total warning(s)"
21127,"      0 unique,     0 total,      0 byte(s) of leak(s)"
21128,"      1 unique,     1 total,     98 byte(s) of possible leak(s)"
21129,ERRORS IGNORED:
21130,"      3 unique,     3 total,    113 byte(s) of still-reachable allocation(s)"
21131,"         (re-run with ""-show_reachable"" for details)"
21132,Details: C:\Users\dmn\AppData\Roaming\Dr. Memory\DrMemory-CControl.exe.9640.000\results.txt
21133,Error #3:
21134,-fsanitize=address
21135,#include <stdio.h>
21136,#include <stdlib.h>
21137,#include <time.h>
21138,
21139,#define N 15
21140,
21141,char randWord() {
21142,    int len;
21143,    srand(time(NULL));
21144,    len = (rand() % 10) + 1;
21145,    char * word = malloc(len);
21146,    
21147,    for (int i = 0; i < len; i++) {
21148,        word[i] = ((rand() % 26) + 97);     
21149,    }
21150,
21151,    return word;
21152,}
21153,
21154,int main() {
21155,    char* s;
21156,    int i;
21157,
21158,    for (i = 0; i < N; i++) {
21159,        randWord(s);
21160,"        printf(""%s\n"", s);"
21161,        free(s);
21162,    }
21163,
21164,    return 0;
21165,}
21166,char *randWord() 
21167,main()
21168,randWord()
21169,randWord()
21170,srand()
21171,rand()
21172,char* randWord(char* s)
21173,int addOne(int x) { 
21174,  return x + 1;
21175,}
21176,f(x)=x+1
21177,f(1)
21178,2
21179,f(2)
21180,3
21181,randWord
21182,char *randWord()
21183,s
21184,char randWord() {
21185,char *
21186,randWord(s)
21187,char *
21188,char
21189,char randWord() {
21190,    int len;
21191,    srand(time(NULL));
21192,    len = (rand() % 10) + 1;
21193,    char * word = malloc(len);
21194,    
21195,    for (int i = 0; i < len; i++) {
21196,        word[i] = ((rand() % 26) + 97);     
21197,    }
21198,    return word;
21199,}
21200,'\0'
21201,char * randWord( void ) {
21202,    size_t len = (rand() % 10) + 1;
21203,    char * word = malloc(len);
21204,    
21205,    if ( word != NULL )
21206,    {
21207,        size_t i = 0;
21208,        for (; i < len - 1; i++) {
21209,            word[i] = ((rand() % 26) + 'a');     
21210,        }
21211,        word[i] = '\0';     
21212,    }
21213,
21214,    return word;
21215,}
21216,s = randWord();
21217,if ( s != NULL ) puts( s );
21218,free( s );
21219,srand(time(NULL));
21220,#include <stdio.h>
21221,#include <stdlib.h>
21222,#include <time.h>
21223,
21224,#define N 15
21225,
21226,char *randWord() { // Return ptr to word buffer (the string)
21227,    int len = rand() % 10 + 1; // knowing operator precedence avoids overuse of ( )
21228,
21229,    char *word = malloc( len + 1 ); // allow room for '\0'
21230,    if( word == NULL )
21231,        exit( EXIT_FAILURE ); // do not presume success
21232,
21233,"    // Here ""len"" is the # of chars to generate (at least one)"
21234,    for( int i = 0; i < len; i++ ) {
21235,"        word[i] = rand() % 26 + 'a'; // use ASCII value, not magic number"
21236,    }
21237,    word[i] = '\0'; // TERMINATE the string
21238,
21239,    return word;
21240,}
21241,
21242,int main() { // be consistent with braces
21243,    srand( time( NULL ) ); // Seed the random number generator only once
21244,
21245,    for( int i = 0; i < N; i++ ) { // Be consistent
21246,        char *s = randWord(); // declare variables proximate to use. Strive for clarity
21247,        puts( s ); // Simpler function than printf
21248,        free( s );
21249,    }
21250,
21251,    return 0;
21252,}
21253,#include <gtk/gtk.h>
21254,
21255,static void on_activate (GtkApplication *app) {
21256,  // Create a new window
21257,  GtkWidget *window = gtk_application_window_new (app);
21258,  // Create a new button
21259,"  GtkWidget *button = gtk_button_new_with_label (""Hello, World!"");"
21260,"  // When the button is clicked, close the window passed as an argument"
21261,"  g_signal_connect_swapped (button, ""clicked"", G_CALLBACK (gtk_window_close), window);"
21262,"  gtk_window_set_child (GTK_WINDOW (window), button);"
21263,  gtk_window_present (GTK_WINDOW (window));
21264,}
21265,
21266,"int main (int argc, char *argv[]) {"
21267,  // Create a new application
21268,"  GtkApplication *app = gtk_application_new (""com.example.GtkApplication"", G_APPLICATION_FLAGS_NONE);"
21269,"  g_signal_connect (app, ""activate"", G_CALLBACK (on_activate), NULL);"
21270,"  return g_application_run (G_APPLICATION (app), argc, argv);"
21271,}
21272,#0  0x00007ffff72e906c in type_node_check_conformities_UorL
21273,"    (node=0x55555557ca10, iface_node=iface_node@entry=0x5557a540, support_interfaces=support_interfaces@entry=1, support_prerequisites=support_prerequisites@entry=0, have_lock=have_lock@entry=0) at ../glib/gobject/gtype.c:3519"
21274,"#1  0x00007ffff72eb2ca in type_node_conforms_to_U (support_prerequisites=0, support_interfaces=1, iface_node=0x5557a540, node=<optimized out>) at ../glib/gobject/gtype.c:3564"
21275,"#2  g_type_check_instance_cast (type_instance=0x5555555840e0, iface_type=<optimized out>) at ../glib/gobject/gtype.c:4128"
21276,"#3  0x00005555555552d3 in main (argc=1, argv=0x7fffffffde18) at src/main.c:19"
21277,"Program received signal SIGSEGV, Segmentation fault."
21278,"0x00007ffff72e906c in type_node_check_conformities_UorL (node=0x55555557ca10, iface_node=iface_node@entry=0x5557a540, support_interfaces=support_interfaces@entry=1, support_prerequisites=support_prerequisites@entry=0, have_lock=have_lock@entry=0) at ../glib/gobject/gtype.c:3519"
21279,"3519          NODE_IS_ANCESTOR (iface_node, node))"
21280,"return g_application_run (G_APPLICATION (app), argc, argv);"
21281,xterm
21282,xev
21283,gtk_window_close
21284,void
21285,gtk_window_close (
21286,  GtkWindow* window
21287,)
21288,window
21289,window
21290,GTK_WINDOW
21291,"g_signal_connect_swapped (button, ""clicked"", G_CALLBACK (gtk_window_close), GTK_WINDOW (window));"
21292,#include <stdio.h>
21293,#define SQUARE(X) X * X
21294,"#define PR(X) printf(""The result is %d.\n"", X)"
21295,
21296,int main(void) {
21297,  int x = 5;
21298,"  printf(""x = %d\n"", x);"
21299,  PR(SQUARE(++x)); // print out 49 but x is 5
21300,
21301,  return 0;
21302,}
21303,#define SQUARE(X) ((X) * (X))
21304,SQUARE(2+1)
21305,2 + 1 * 2 + 1
21306,5
21307,9
21308,7 * 7
21309,((7) * (7))
21310,PR(SQUARE(++x));
21311,==>
21312,PR(++x * ++x)
21313,==>
21314,"printf(""The result is %d.\n"", ++x * ++x);"
21315,x
21316,;
21317,"frama-c -rte main.c -cpp-extra-args=""-I src/include -I ..."""
21318,e-acsl-gcc.sh --rte=all -c main.c
21319,"[kernel] Parsing main.c (with preprocessing)/main.c:10:10: fatal error: header.h: No such file or directory #include ""header.h"""
21320,e-acsl-gcc.sh -h
21321,Options:
21322,  -h         show this help page
21323,  -c         compile instrumented code
21324,  (...)
21325,  -E         pass additional arguments to the Frama-C preprocessor
21326,  -F         pass additional options to the Frama-C command line
21327,  (...)
21328,-E
21329,-cpp-extra-args
21330,-F
21331,"e-acsl-gcc.sh -E ""-Isrc/include -I..."" <other options and source files>"
21332,"e-acsl-gcc.sh -F -cpp-extra-args=""-Isrc/include,-I..."" <other options and source files>"
21333,-F
21334,"""-Isrc/include,-I..."""
21335,-I
21336,e-acsl-gcc.sh
21337,-I
21338,-D
21339,-E
21340,-F
21341,-cpp-extra-args
21342,-I
21343,-E
21344,-E
21345,[kernel] Parsing file.c
21346,[e-acsl] beginning translation.
21347,"[e-acsl] translation done in project ""e-acsl"""
21348,[e-acsl]
21349,-E
21350,-I
21351,"e-acsl-gcc.sh -c main.c -E ""-I src/include"""
21352,-I
21353,double integrate(double (*func)(double));
21354,double f(double x)
21355,integrate(f)
21356,"double f(double x, double y);"
21357,"g(x)=f(x,1)"
21358,"h(x)=f(x,2)"
21359,double compute(double y){
21360,  double g(double x){
21361,"    return f(x, y);"
21362,  }
21363,  return integrate(g);
21364,}
21365,integrate
21366,compute
21367,"double f(double, double); double g(double x) { return f(x, 1); } integrate(&g)"
21368,"double g1(double x) { return f(x, 1); }"
21369,…
21370,integrate(g1);
21371,double y;
21372,"double g(double x) { return f(x, y); }"
21373,…
21374,y = 1;
21375,integrate(g);
21376,integrate
21377,"double integrate(double (*func)(double, const void *))"
21378,
21379,struct MyData { double y; }; // This structure can contain whatever you want.
21380,
21381,"double g(double x, const void *p)"
21382,{
21383,    const struct MyData *data = p;
21384,"    return f(x, data->y);"
21385,}
21386,…
21387,struct MyData data = { 1 };
21388,"integrate(g, &data);"
21389,double compute(double y)
21390,{
21391,"    double g(double x) { return f(x, y); }"
21392,    return integrate(g);
21393,}
21394,integrate
21395,g
21396,"//The value returned by sam(3,0) of the below function is:"
21397,#include <stdio.h>
21398,"int sam(int n,int a)"
21399,{
21400,
21401,    if(n==0)
21402,         return a;
21403,    else
21404,    {
21405,        a+=n;
21406,"        sam(--n, a);"
21407,        a+=n;
21408,    }
21409,}
21410,int main()
21411,{
21412,"    printf(""%ld"",sam(3,0));"
21413,    return 0;
21414,}
21415,#include <stdio.h>
21416,"int sam(int n,int a)"
21417,{
21418,    if(n==0){
21419,"        printf(""%d"",a); //Check the change here"
21420,        return a;
21421,    }
21422,    else{
21423,        a+=n;
21424,"        sam(--n,a);"
21425,        a+=n;
21426,    }
21427,}
21428,
21429,int main()
21430,{
21431,"    sam(3,0);"
21432,    return 0;
21433,}
21434,sam
21435,n != 0
21436,n
21437,0
21438,#include <stdio.h>
21439,
21440,"int sam(int n, int a) {"
21441,    if (n == 0)
21442,        return a;
21443,    else {
21444,        a += n;
21445,"        sam(--n, a);"
21446,        a += n;
21447,    } 
21448,} 
21449,struct timeval tv;
21450,"int ret = gettimeofday(&tv, NULL);"
21451,if (ret < 0)
21452,"    printf(""gettimeofday failed with %s\n"", strerror(errno));"
21453,"printf(""%lu.%ld\n"", tv.tv_sec, tv.tv_usec);"
21454,gettimeofday failed with Value too large for defined data type
21455,1078605538.1
21456,"clock_gettime(CLOCK_REALTIME, &tv);"
21457,gettimeofday()
21458,"read(3, "" \0\0\0\1\0\0\0\273\0\0\0\230\1\0\0\1\0\0\0\20\0\254\0\254\0\223\261zG\377F""..., 65536) = 199"
21459,"clock_gettime(CLOCK_REALTIME, {tv_sec=3416400658881740019, tv_nsec=4632575514938983213}) = 0"
21460,dup(2)                                  = 4
21461,"fcntl64(4, F_GETFL)                     = 0x20002 (flags O_RDWR|O_LARGEFILE)"
21462,"statx(4, """", AT_STATX_SYNC_AS_STAT|AT_NO_AUTOMOUNT|AT_EMPTY_PATH, STATX_BASIC_STATS, {stx_mask=STATX_BASIC_STATS, stx_attributes=0, stx_mode=S_IFCHR|0600, stx_size=0, ...}) = 0"
21463,"write(4, ""gettimeofday: Value too large fo""..., 52gettimeofday: Value too large for defined data type"
21464,) = 52
21465,close(4)
21466,"[ and same repeats, we are in a loop ]            "
21467,1078605538
21468,"memset(&tv, 0, sizeof tv)"
21469,gettimeofday
21470,0.0
21471,gettimeofday
21472,errno
21473,errno
21474,strace
21475,strace
21476,clock_gettime
21477,0
21478,gettimeofday
21479,errno
21480,0
21481,stdout
21482,4
21483,int main(void)
21484,#include <SDL2/SDL.h>
21485,#include <SDL2/SDL_ttf.h>
21486, 
21487,"void renderText(SDL_Renderer* renderer, const char* text, int const size, const SDL_Rect text_rect, const SDL_Color text_color)"
21488,{
21489,    #ifdef __linux__
21490,"      const char* font_path = ""/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"";"
21491,    #elif _WIN32
21492,"      const char* font_path = ""C:\\Windows\\Fonts\\Arial.ttf"";"
21493,    #endif
21494, 
21495,"    TTF_Font* font = TTF_OpenFont(font_path, size);"
21496, 
21497,"    if (!font) { SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, ""SDL_ttf - %s"", TTF_GetError()); return; }"
21498, 
21499,"    SDL_Surface* text_surface = TTF_RenderText_Blended(font, text, text_color);"
21500,"    SDL_Texture* text_texture = SDL_CreateTextureFromSurface(renderer, text_surface);"
21501,"    if (text_color.a!=255)      SDL_SetTextureAlphaMod(text_texture, text_color.a);"
21502, 
21503,"    SDL_RenderCopy(renderer, text_texture, NULL, &text_rect);"
21504, 
21505,    SDL_DestroyTexture(text_texture);
21506,    SDL_FreeSurface(text_surface);
21507,    TTF_CloseFont(font);
21508,}
21509, 
21510,"int main(int argc, char** argv)"
21511,{
21512,    //(void)argc; (void)argv;
21513, 
21514,    SDL_Init(SDL_INIT_VIDEO);
21515, 
21516,    TTF_Init();
21517, 
21518,"    SDL_Window* win = SDL_CreateWindow(""Example for memory leak with SDL2_ttf"", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, 0);"
21519, 
21520,"    SDL_Renderer* ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);"
21521, 
21522,    SDL_Event event;
21523, 
21524,    SDL_bool running = SDL_TRUE;
21525, 
21526,    while (running)
21527,    {
21528,        while (SDL_PollEvent(&event))
21529,        {
21530,            running = event.type != SDL_QUIT;
21531,        }
21532, 
21533,"        renderText(ren, ""Hi devs !"", 22, (SDL_Rect){ (640-128)/2, (480-64)/2, 128, 64 }, (SDL_Color){ 255, 255, 255, 255 });"
21534, 
21535,        SDL_RenderPresent(ren);
21536,    }
21537, 
21538,    SDL_DestroyRenderer(ren);
21539,    SDL_DestroyWindow(win);
21540,    TTF_Quit();
21541,    SDL_Quit();
21542, 
21543,  return 0;
21544, 
21545,}
21546,==79266== LEAK SUMMARY:
21547,==79266==    definitely lost: 504 bytes in 1 blocks
21548,"==79266==    indirectly lost: 43,152 bytes in 235 blocks"
21549,"==79266==      possibly lost: 8,496 bytes in 44 blocks"
21550,"==79266==    still reachable: 274,261 bytes in 3,422 blocks"
21551,==79266==         suppressed: 0 bytes in 0 blocks
21552,#include <SDL2/SDL.h>
21553,#include <SDL2/SDL_ttf.h>
21554, 
21555,"void renderText(SDL_Renderer* renderer, const char* text, TTF_Font* font, const int size, const SDL_Rect text_rect, const SDL_Color text_color)"
21556,{
21557,"    SDL_Surface* text_surface = TTF_RenderText_Blended(font, text, text_color);"
21558,"    SDL_Texture* text_texture = SDL_CreateTextureFromSurface(renderer, text_surface);"
21559,
21560,    if (text_color.a!=255)
21561,"        SDL_SetTextureAlphaMod(text_texture, text_color.a);"
21562, 
21563,"    SDL_RenderCopy(renderer, text_texture, NULL, &text_rect);"
21564, 
21565,    SDL_DestroyTexture(text_texture);
21566,    SDL_FreeSurface(text_surface);
21567,}
21568, 
21569,"int main(int argc, char** argv)"
21570,{
21571,    /* Init SDL */
21572, 
21573,    SDL_Init(SDL_INIT_VIDEO);
21574, 
21575,"    SDL_Window* win = SDL_CreateWindow(""Example for memory leak with SDL2_ttf"", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, 0);"
21576, 
21577,"    SDL_Renderer* ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);"
21578, 
21579,    SDL_Event event;
21580,
21581,    /* Init TTF */
21582,
21583,    TTF_Init();
21584,
21585,    #ifdef __linux__
21586,"      const char* font_path = ""/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"";"
21587,    #elif _WIN32
21588,"      const char* font_path = ""C:\\Windows\\Fonts\\Arial.ttf"";"
21589,    #endif
21590,
21591,"    TTF_Font* font = TTF_OpenFont(font_path, 22);"
21592,
21593,    if (!font)
21594,    {
21595,"        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, ""SDL_ttf - %s"", TTF_GetError());"
21596,        return -1;
21597,    }
21598,
21599,    /* Main loop */
21600, 
21601,    SDL_bool running = SDL_TRUE;
21602, 
21603,    while (running)
21604,    {
21605,        while (SDL_PollEvent(&event))
21606,        {
21607,            running = event.type != SDL_QUIT;
21608,        }
21609, 
21610,"        renderText(ren, ""Hi devs !"", font, 22, (SDL_Rect){ (640-128)/2, (480-64)/2, 128, 64 }, (SDL_Color){ 255, 255, 255, 255 });"
21611, 
21612,        SDL_RenderPresent(ren);
21613,    }
21614, 
21615,    TTF_CloseFont(font);
21616,
21617,    SDL_DestroyRenderer(ren);
21618,    SDL_DestroyWindow(win);
21619,
21620,    TTF_Quit();
21621,    SDL_Quit();
21622, 
21623,  return 0;
21624, 
21625,}
21626,==18309== LEAK SUMMARY:
21627,==18309==    definitely lost: 504 bytes in 1 blocks
21628,==18309==    indirectly lost: 160 bytes in 1 blocks
21629,"==18309==      possibly lost: 65,728 bytes in 367 blocks"
21630,"==18309==    still reachable: 274,261 bytes in 3,422 blocks"
21631,==18309==         suppressed: 0 bytes in 0 blocks
21632,==22622==    definitely lost: 504 bytes in 1 blocks
21633,"==22622==    indirectly lost: 43,152 bytes in 235 blocks"
21634,"==22622==      possibly lost: 21,136 bytes in 123 blocks"
21635,"==22622==    still reachable: 274,261 bytes in 3,422 blocks"
21636,==22622==         suppressed: 0 bytes in 0 blocks
21637,#include <SDL2/SDL.h>
21638,int main(void) { SDL_Init(SDL_INIT_VIDEO); SDL_Quit(); }
21639,SDL
21640,valgrind --leak-check=full
21641,==5815==    by 0x400C81: main (ttf-valgrind.c:24)
21642,    SDL_Init(SDL_INIT_VIDEO);
21643,libSDL2_ttf
21644,libSDL2
21645,libX11
21646,    TTF_CloseFont(font);
21647,
21648,    SDL_DestroyRenderer(ren);
21649,    SDL_DestroyWindow(win);
21650,
21651,    TTF_Quit();
21652,    SDL_Quit();
21653,main()
21654,xxx_Quit()
21655,time
21656,"system(""(time qemu-riscv64 ./a.out) >outputqemu.txt 2>&1"");"
21657,x0  0
21658,0.00user 0.01system 0:00.03elapsed 74%CPU (0avgtext+0avgdata 11208maxresident)k 5512inputs+8outputs (36major+663minor)pagefaults
21659,0swaps
21660,$(time qemu-riscv64 ./a.out) >outputqemu.txt 2>&1
21661,x0  0
21662,
21663,"real    0m0,015s "
21664,"user    0m0,013s "
21665,"sys 0m0,000s"
21666,system
21667,#include <stdio.h>
21668,#include <iphlpapi.h>
21669,
21670,ulong main()
21671,{
21672,   PMIB_IPNETTABLE IpNetTablePointer = NULL;
21673,   ulong dwResult;
21674,
21675,   PULONG SizePointer;
21676,"   dwResult = GetIpNetTable(IpNetTablePointer, SizePointer, 0);"
21677,
21678,   return 0;
21679,}
21680,"||=== Build file: ""no target"" in ""no project"" (compiler: unknown) ===|"
21681,"\usr\include\w32api\_bsd_types.h|30|error: expected '=', ',', ';', 'asm' or '__attribute__' before '__ms_u_long'|"
21682,\usr\include\w32api\inaddr.h|21|error: unknown type name '__ms_u_long'|
21683,"\usr\include\w32api\_bsd_types.h|30|error: expected '=', ',', ';', 'asm' or '__attribute__' before '__ms_u_long'|"
21684,"||=== Build failed: 3 error(s), 0 warning(s) (0 minute(s), 2 second(s)) ===|"
21685,#include
21686,%u
21687,unsigned int
21688,void *
21689,%p
21690,main
21691,int
21692,#include <stdio.h>
21693,#include <string.h>
21694,
21695,int main()
21696,{
21697," char str[] = ""MMCDXIX"";"
21698," int i, bandera = 0, suma = 0, flag = 0, strLength = strlen(str);"
21699,
21700,for (i = 0; i <= strLength; i++)
21701,{
21702, if (i != 0 && flag != 0)
21703, {
21704,     i = i - 1;
21705, }
21706,
21707, if ((int)(str[i]) == 73) // I
21708, {
21709,     if ((int)(str[i + 1]) == 88) // X
21710,     {
21711,         suma = suma + 9;
21712,         bandera = 1;
21713,     }
21714,
21715,     if ((int)(str[i + 1]) == 86) // V
21716,     {
21717,         suma = suma + 4;
21718,         bandera = 1;
21719,     }
21720,
21721,     if ((int)(str[i]) == 73 && bandera != 1)
21722,     {
21723,         if ((int)(str[i + 1]) == 73) // X
21724,         {
21725,             suma = suma + 1;
21726,             flag = 0;
21727,         }
21728,
21729,         else
21730,         {
21731,             suma = suma + 1;
21732,             flag = 0;
21733,         }
21734,     }
21735,
21736,     if (bandera == 1)
21737,     {
21738,         i += 2;
21739,         flag = 1;
21740,     }
21741,
21742,     bandera = 0;
21743, }
21744,
21745, if ((int)(str[i]) == 86) // V
21746, {
21747,     suma = suma + 5;
21748, }
21749,
21750, if ((int)(str[i]) == 88) // X
21751, {
21752,     if ((int)(str[i + 1]) == 67) // C
21753,     {
21754,         suma = suma + 90;
21755,         bandera = 1;
21756,     }
21757,
21758,     if ((int)(str[i + 1]) == 76) // L
21759,     {
21760,         suma = suma + 40;
21761,         bandera = 1;
21762,     }
21763,
21764,     if ((int)(str[i]) == 88 && bandera != 1)
21765,     {
21766,         if ((int)(str[i + 1]) == 88) // X
21767,         {
21768,             suma = suma + 10;
21769,             flag = 0;
21770,         }
21771,
21772,         else
21773,         {
21774,             suma = suma + 10;
21775,             flag = 0;
21776,         }
21777,     }
21778,
21779,     if (bandera == 1)
21780,     {
21781,         i += 2;
21782,         flag = 1;
21783,     }
21784,
21785,     bandera = 0;
21786, }
21787,
21788, if ((int)(str[i]) == 76) // L
21789, {
21790,     suma = suma + 50;
21791, }
21792,
21793, if ((int)(str[i]) == 67) // C
21794, {
21795,     if ((int)(str[i + 1]) == 77) // M
21796,     {
21797,         suma = suma + 900;
21798,         bandera = 1;
21799,     }
21800,
21801,     if ((int)(str[i + 1]) == 68) // D
21802,     {
21803,         suma = suma + 400;
21804,         bandera = 1;
21805,     }
21806,
21807,     if ((int)(str[i]) == 67 && bandera != 1)
21808,     {
21809,         if ((int)(str[i + 1]) == 67) // X
21810,         {
21811,             suma = suma + 100;
21812,             flag = 0;
21813,         }
21814,
21815,         else
21816,         {
21817,             suma = suma + 100;
21818,             flag = 0;
21819,         }
21820,     }
21821,
21822,     if (bandera == 1)
21823,     {
21824,         i += 2;
21825,         flag = 1;
21826,     }
21827,
21828,     bandera = 0;
21829, }
21830,
21831, if ((int)(str[i]) == 68) // D
21832, {
21833,     suma = suma + 500;
21834, }
21835,
21836, if ((int)(str[i]) == 77) // M
21837, {
21838,     suma = suma + 1000;
21839, }
21840,}
21841,
21842,"printf(""%s\n"", str);"
21843,"printf(""%d\n"", suma);"
21844,
21845,return 0;
21846,}
21847,char
21848,'I'
21849,'X'
21850,i = i - 1
21851,i < strLength
21852,str
21853,i == strLength
21854,str[i + 1]
21855,i = i - 1
21856,flag
21857,// Record preference if vote is valid
21858,"bool vote(int voter, int rank, string name)"
21859,{
21860,    for (int i = 0; i < candidate_count; i++)
21861,    {
21862,"        if (strcmp(name, candidates[i].name) == 0)"
21863,        {
21864,            /*
21865,            update the preferences 2d array to indicate
21866,            the voter has that cand as their rank n
21867,            */ 
21868,            preferences[voter][rank] = i;
21869,            // preferences[1][j] = rank;
21870,"            printf(""voter: %d\n"", voter);"
21871,"            printf(""rank: %d\n"", rank);"
21872,            return true;
21873,        }
21874,    }
21875,    
21876,    return false;
21877,}
21878,preferences[voter][rank]
21879,preferences
21880,preferences[voter]
21881,preferences[voter][rank]
21882,int
21883,i
21884,preferences[voter][rank]
21885,preferences
21886,voter
21887,rank
21888,name
21889,calloc
21890,"int initMTX(int r, int c, int ***MTX) {"
21891,"  int **locMTX = malloc(r * sizeof(int *)), i, j;"
21892,  for (i = 0; i < r; i++) {
21893,    locMTX[i] = (int *)malloc(c * sizeof(int));
21894,  }
21895,  for (i = 0; i < r; i++)
21896,    for (j = 0; j < c; j++)
21897,      locMTX[i][j] = 0;
21898,  *MTX = locMTX;
21899,
21900,  return 1;
21901,}
21902,#include <stdio.h>
21903,#include <stdlib.h>
21904,
21905,"int initMTX(int r, int c, int ***MTX);"
21906,"void printMTX(int r, int c, int **MTX);"
21907,"void freeMTX(int r, int **MTX);"
21908,
21909,int main(void) {
21910,"  int NBits = 4, NNumbers = 2 ^ NBits, **MTXResults;"
21911,"  initMTX(NNumbers, NBits, &MTXResults);"
21912,  // code
21913,"  printMTX(NNumbers, NBits, MTXResults);"
21914,"  freeMTX(NNumbers, MTXResults);"
21915,}
21916,
21917,"int initMTX(int r, int c, int ***MTX) {"
21918,"  int **locMTX = malloc(r * sizeof(int *)), i, j;"
21919,  for (i = 0; i < r; i++) {
21920,    locMTX[i] = (int *)malloc(c * sizeof(int));
21921,  }
21922,  for (i = 0; i < r; i++)
21923,    for (j = 0; j < c; j++)
21924,      locMTX[i][j] = 0;
21925,  *MTX = locMTX;
21926,  return 1;
21927,}
21928,
21929,"void printMTX(int r, int c, int **MTX) {"
21930,"  int i, j;"
21931,  for (i = 0; i < r; i++) {
21932,    for (j = 0; j < c; j++)
21933,"      printf(""%d "", MTX[i][r]);"
21934,"    printf(""\n"");"
21935,  }
21936,}
21937,
21938,"void freeMTX(int r, int **MTX) {"
21939,  for (int i = 0; i < r; i++)
21940,    free(MTX[i]);
21941,  free(MTX);
21942,}
21943,calloc
21944,"printf(""%d "", MTX[i][r]);"
21945,2 ^ NBits
21946,^
21947,1
21948,MTX[i][r]
21949,MTX[i][j]
21950,#include <stdio.h>
21951,#include <stdlib.h>
21952,
21953,"void printMTX(int r, int c, int (*MTX)[c]);"
21954,
21955,int main(void) {
21956,    int NBits = 4;
21957,    int NNumbers = NBits * NBits;
21958,    int (*MTXResults)[NBits];
21959,"    if ( NULL == ( MTXResults = calloc( sizeof *MTXResults, NNumbers))) {"
21960,"        fprintf ( stderr, ""problem calloc\n"");"
21961,        return 1;
21962,    }
21963,"    printMTX(NNumbers, NBits, MTXResults);"
21964,    free ( MTXResults);
21965,}
21966,
21967,"void printMTX(int r, int c, int (*MTX)[c]) {"
21968,"    int i, j;"
21969,    for (i = 0; i < r; i++) {
21970,        for (j = 0; j < c; j++) {
21971,"            printf(""%d "", MTX[i][j]);"
21972,        }
21973,"        printf(""\n"");"
21974,    }
21975,}
21976,MTX[i][r]
21977,MTX[i][j]
21978,freeMTX()
21979,#include <stdio.h>
21980,#include <stdlib.h>
21981,
21982,"int initMTX(int r, int c, int ***MTX);"
21983,"void printMTX(int r, int c, int **MTX);"
21984,"void freeMTX(int r, int **MTX);"
21985,
21986,int main(void)
21987,{
21988,    int NBits = 4;
21989,    int NNumbers = 16;
21990,    int **MTXResults;
21991,
21992,"    if (initMTX(NNumbers, NBits, &MTXResults))"
21993,    {
21994,"        printMTX(NNumbers, NBits, MTXResults);"
21995,"        freeMTX(NNumbers, MTXResults);"
21996,    }
21997,    else
21998,"        fprintf(stderr, ""failed to allocate %dx%d matrix\n"", NBits, NNumbers);"
21999,}
22000,
22001,"int initMTX(int r, int c, int ***MTX)"
22002,{
22003,    int **locMTX = malloc(r * sizeof(int *));
22004,    if (locMTX == 0)
22005,        return 0;
22006,    for (int i = 0; i < r; i++)
22007,    {
22008,        locMTX[i] = (int *)malloc(c * sizeof(int));
22009,        if (locMTX[i] == 0)
22010,        {
22011,            for (int j = 0; j < i; j++)
22012,                free(locMTX[j]);
22013,            free(locMTX);
22014,            return 0;
22015,        }
22016,    }
22017,    for (int i = 0; i < r; i++)
22018,    {
22019,        for (int j = 0; j < c; j++)
22020,            locMTX[i][j] = 0;
22021,    }
22022,
22023,    *MTX = locMTX;
22024,    return 1;
22025,}
22026,
22027,"void printMTX(int r, int c, int **MTX)"
22028,{
22029,    for (int i = 0; i < r; i++)
22030,    {
22031,        for (int j = 0; j < c; j++)
22032,"            printf(""%d "", MTX[i][j]);"
22033,"        printf(""\n"");"
22034,    }
22035,}
22036,
22037,"void freeMTX(int r, int **MTX)"
22038,{
22039,    for (int i = 0; i < r; i++)
22040,        free(MTX[i]);
22041,    free(MTX);
22042,}
22043,#include <stdio.h>
22044,#include <stdlib.h>
22045,
22046,"int initMTX(int r, int c, int ***MTX);"
22047,"void printMTX(int r, int c, int **MTX);"
22048,void freeMTX(int **MTX);
22049,
22050,int main(void)
22051,{
22052,    int NBits = 4;
22053,    int NNumbers = 16;
22054,    int **MTXResults;
22055,
22056,"    if (initMTX(NNumbers, NBits, &MTXResults))"
22057,    {
22058,"        printMTX(NNumbers, NBits, MTXResults);"
22059,        freeMTX(MTXResults);
22060,    }
22061,    else
22062,"        fprintf(stderr, ""failed to allocate %dx%d matrix\n"", NBits, NNumbers);"
22063,}
22064,
22065,"int initMTX(int r, int c, int ***MTX)"
22066,{
22067,    int **locMTX = malloc(r * sizeof(locMTX[0]));
22068,    if (locMTX == 0)
22069,        return 0;
22070,    int *data = malloc(r * c * sizeof(locMTX[0][0]));
22071,    if (data == 0)
22072,    {
22073,        free(locMTX);
22074,        return 0;
22075,    }
22076,    for (int i = 0; i < r; i++)
22077,    {
22078,        locMTX[i] = data + i * c;
22079,        for (int j = 0; j < c; j++)
22080,            locMTX[i][j] = 0;
22081,    }
22082,
22083,    *MTX = locMTX;
22084,    return 1;
22085,}
22086,
22087,"void printMTX(int r, int c, int **MTX)"
22088,{
22089,    for (int i = 0; i < r; i++)
22090,    {
22091,        for (int j = 0; j < c; j++)
22092,"            printf(""%d "", MTX[i][j]);"
22093,"        printf(""\n"");"
22094,    }
22095,}
22096,
22097,void freeMTX(int **MTX)
22098,{
22099,    free(MTX[0]);
22100,    free(MTX);
22101,}
22102,'V'
22103,'C'
22104,'D'
22105,"""VCD"""
22106,2og  
22107,Ok1  
22108,Ok  
22109,oK2  
22110,Ok1
22111,oK2
22112,int main() {
22113,"  int x=1, i=0, flag=1, j=0;"
22114,"  char str[500], n_file[100], formato[500],c;"
22115,"  printf(""\nInsert file name:\n"");"
22116,"  scanf(""%s%*c"",n_file);"
22117,"  FILE *fr=fopen(n_file, ""w"");"
22118,"  printf(""\nTo quit from writing input 'quit'\n"");"
22119,  while (x!=0) {
22120,"    fgets(str, sizeof str, stdin);"
22121,"    if (strcmp(str, ""quit\n"")==0) {"
22122,      x=0;
22123,    }else{
22124,"      fputs(str,fr);"
22125,    }
22126,  }
22127,  fclose(fr);
22128,"  printf(""\nInsert the format string (V for vowels, C for consonants and D for digits):\n"");"
22129,"  scanf(""%s%*c"",formato);"
22130,"  printf(""%s"",formato);"
22131,"  FILE *fp=fopen(n_file, ""r"");"
22132,  while (!feof(fp)) {
22133,"    fgets(str, sizeof str, fp);"
22134,    while (str[i]!='\n' && str[i]!='\0' && flag!=0 && formato[j]!='\n') {
22135,"      printf(""\n%c"",str[i]);"
22136,      if (formato[j]=='V') {
22137,        if (str[i]=='a' || str[i]=='A' || str[i]=='E' || str[i]=='e' || str[i]=='i' || str[i]=='I' || str[i]=='o' || str[i]=='O' || str[i]=='u' || str[i]=='U') {
22138,          flag=1;
22139,          i++;
22140,          j++;
22141,"          printf(""\nPrimo if"");"
22142,        }else{
22143,          flag=0;
22144,        }
22145,      }else if (formato[j]=='C'){
22146,        if ((str[i]>='b'-32 && str[i]<='z'-32) || (str[i])>='b' && str[i]<='z') {
22147,          flag=1;
22148,          i++;
22149,          j++;
22150,"          printf(""\nSecondo if"");"
22151,        }else{
22152,          flag=0;
22153,        }
22154,      }else if (formato[j]=='D') {
22155,        if (str[i]>=0 && str[i]<=9) {
22156,          flag=1;
22157,          i++;
22158,          j++;
22159,        } else {
22160,          flag=0;
22161,"          printf(""\nTerzo if"");"
22162,        }
22163,      }
22164,    }
22165,    if (flag==1) {
22166,"      printf(""\n%s"",str);"
22167,    }
22168,    j=0;
22169,    i=0;
22170,      }
22171,      return 0;
22172,    }
22173,'V'
22174,while
22175,str[]
22176,0
22177,"""VCD"""
22178,switch
22179,fgets()
22180,"""w"""
22181,stdin
22182,stdin
22183,while (!feof(fp))
22184,'V'
22185,'C'
22186,'D'
22187," while (fgets (line, size, fp)) { ... }"
22188,main()
22189,main()
22190,"int main (int argc, char **argv) {"
22191,
22192,"  char line[MAXC+1], *fmt, *fname;    /* buffer for line, names for args */"
22193,  FILE *fp;                           /* file pointer for file stream */
22194,  
22195,  if (argc != NARG + 1) {   /* validate 2 arguments given (exe is always 1) */
22196,"    fprintf (stderr, ""error: incorrect number of arguments, 2 required.\n"""
22197,"                     ""usage: %s str (max 3 chars 'V', 'C', 'D'), fname\n"","
22198,                     argv[0]);
22199,    return 1;
22200,  }
22201,  
22202,  fname = argv[1];    /* optional descriptive names for cmdline arguments */
22203,  fmt = argv[2];
22204,  
22205,  if (bad_fmt_chars (fmt)) {  /* validate format string */
22206,    return 1;
22207,  }
22208,  
22209,"  if (!(fp = fopen (fname, ""r""))) { /* open/validate file open for reading */"
22210,"    perror (""fopen-fname"");"
22211,    return 1;
22212,  }
22213,  
22214,"  while (fgets (line, MAXC + 1, fp)) {    /* loop reading each line */"
22215,    
22216,"    line[strcspn (line, ""\n"")] = 0;       /* trim '\n' from line */"
22217,    
22218,"    if (!bad_line_fmt (line, fmt)) {      /* check line format */"
22219,      puts (line);
22220,    }
22221,  }
22222,}
22223,#include <stdio.h>
22224,#include <string.h>
22225,#include <ctype.h>
22226,
22227,"#define NARG        2   /* if you need a constant, #define one (or more) */"
22228,#define MAXC      500           /* max chars in line */
22229,"#define VALIDC   ""VCD""          /* valid chars for str */"
22230,"#define VOWELS   ""AEIOUaeiou""   /* vowels */"
22231,
22232,/* function prototypes (declarations) */
22233,int bad_fmt_chars (const char *str);
22234,"int bad_line_fmt (const char *line, const char *fmt);"
22235,
22236,"int main (int argc, char **argv) {"
22237,
22238,"  char line[MAXC+1], *fmt, *fname;    /* buffer for line, names for args */"
22239,  FILE *fp;                           /* file pointer for file stream */
22240,  
22241,  if (argc != NARG + 1) {   /* validate 2 arguments given (exe is always 1) */
22242,"    fprintf (stderr, ""error: incorrect number of arguments, 2 required.\n"""
22243,"                     ""usage: %s str (max 3 chars 'V', 'C', 'D'), fname\n"","
22244,                     argv[0]);
22245,    return 1;
22246,  }
22247,  
22248,  fname = argv[1];    /* optional descriptive names for cmdline arguments */
22249,  fmt = argv[2];
22250,  
22251,  if (bad_fmt_chars (fmt)) {  /* validate format string */
22252,    return 1;
22253,  }
22254,  
22255,"  if (!(fp = fopen (fname, ""r""))) { /* open/validate file open for reading */"
22256,"    perror (""fopen-fname"");"
22257,    return 1;
22258,  }
22259,  
22260,"  while (fgets (line, MAXC + 1, fp)) {    /* loop reading each line */"
22261,    
22262,"    line[strcspn (line, ""\n"")] = 0;       /* trim '\n' from line */"
22263,    
22264,"    if (!bad_line_fmt (line, fmt)) {      /* check line format */"
22265,      puts (line);
22266,    }
22267,  }
22268,}
22269,strchr()
22270,strchr()
22271,int
22272,stdbool.h
22273,bool
22274,int
22275,1
22276,0
22277,"/* check if format string has bad char not one of ""VCD"","
22278," * returns 1 if bad char found, 0 otherwise"
22279, */
22280,int bad_fmt_chars (const char *str)
22281,{
22282,  for (int i = 0; str[i]; i++) {      /* loop over chars in str */
22283,    
22284,"    /* case insensitive char not in VALIDC, return err */"
22285,"    if (!strchr (VALIDC, toupper(str[i]))) {"
22286,"      fprintf (stderr, ""error: invalid char '%c' is not one of \""VCD\"".\n"","
22287,               str[i]);
22288,      return 1;
22289,    }
22290,  }
22291,  
22292,  return 0;   /* return good (no bad chars) */
22293,}
22294,strchr()
22295,VALIDC
22296,1
22297,0
22298,switch()
22299,case:
22300,case
22301,break
22302,case
22303,'V'
22304,'v'
22305,line
22306,'v'
22307,'V'
22308,'c'
22309,'C'
22310,'d'
22311,'D'
22312,mismatch
22313,"/* confirm each character in line matches format char in fmt,"
22314," * returns 1 on any format mismatch or difference in length,"
22315, * returns 0 if format matches exactly.
22316, */
22317,"int bad_line_fmt (const char *line, const char *fmt)"
22318,{
22319,  int i = 0;      /* declare i to survive loop */
22320,  
22321,  /* both line and format chars must be available */
22322,  for (; line[i] && fmt[i]; i++) {
22323,    int mismatch = 0;
22324,    /* case fall-through intentional */
22325,    switch (fmt[i]) {
22326,      case 'v': /* if not in VOWELS break loop */
22327,"      case 'V': if (!strchr (VOWELS, line[i])) { mismatch = 1; } break;"
22328,      case 'c': /* if in VOWELS break loop */
22329,"      case 'C': if (strchr (VOWELS, line[i]) || "
22330,                    isdigit (line[i]) ||
22331,                    ispunct (line[i]) ||
22332,                    isspace (line[i])) { 
22333,                  mismatch = 1;
22334,                }
22335,                break;
22336,      case 'd': /* if not digit break loop */
22337,      case 'D': if (!isdigit (line[i])) { mismatch = 1; } break;
22338,    }
22339,    
22340,    if (mismatch) {   /* if mismatch between format and char */
22341,      return 1;       /* return bad format */
22342,    }
22343,  }
22344,  
22345,  if (line[i] || fmt[i]) {  /* if either line or fmt not at end */
22346,    return 1;               /* return bad format */
22347,  }
22348,  
22349,  return 0;     /* return line matches format - return good */
22350,}
22351,'c'
22352,'C'
22353,-Wno-implicit-fallthrough
22354,-Werror
22355,dat/formatvcd.txt
22356,"$ ./bin/formatVCD dat/formatvcd.txt ""VCD"""
22357,Ok1
22358,oK2
22359,"$ ./bin/formatVCD dat/formatvcd.txt ""VcD"""
22360,Ok1
22361,oK2
22362,"$ ./bin/formatVCD dat/formatvcd.txt ""DVC"""
22363,2og
22364,"$ ./bin/formatVCD dat/formatvcd.txt ""VC"""
22365,Ok
22366,"$ ./bin/formatVCD dat/formatvcd.txt ""VqD"""
22367,"error: invalid char 'q' is not one of ""VCD""."
22368,"$ ./bin/formatVCD dat/formatvcd.txt ""V"""
22369,(no output)
22370,main()
22371,main()
22372,gcc
22373,$  gcc -Wall -Wextra -pedantic -Wshadow -Werror -Wno-implicit-fallthrough -std=c11 -Ofast -o formatVCD formatVCD.c
22374,formatVCD
22375,formatVCD.c
22376,:)
22377,:)
22378,:-)
22379,#include <stdio.h>
22380,#include <string.h>
22381,#include <ctype.h>
22382,
22383,int main() {
22384,    char *legit[] = {
22385,"        """","
22386,"        ""BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz"","
22387,"        ""0123456789"","
22388,"        ""AEIOUaeiou"","
22389,    };
22390,
22391,"    char *formato = ""VCD"";"
22392,"    char *arr[] = { ""2og"",""Ok1"",""Ok"",""oK2"", };"
22393,
22394,    for( int i = 0; i < sizeof arr/sizeof arr[0]; i++ ) {
22395,        char *str = arr[ i ];
22396,        char *wnt = formato;
22397,
22398,"        while( *wnt && *str && strchr( legit[ *wnt>>1&3 ], *str ) )"
22399,"            wnt++, str++;"
22400,
22401,        if ( !*str && !*wnt )
22402,            puts( arr[ i ] );
22403,    }
22404,
22405,    return 0;
22406,}
22407,Ok1
22408,oK2
22409,#define V 'V'
22410,#define C 'C'
22411,#define D 'D'
22412,#define B 1
22413,char tbl[] = {
22414,"    B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, "
22415,"    B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, "
22416,"    B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, "
22417,"    D, D, D, D, D, D, D, D, D, D, B, B, B, B, B, B, "
22418,"    B, V, C, C, C, V, C, C, C, V, C, C, C, C, C, V, "
22419,"    C, C, C, C, C, V, C, C, C, C, C, B, B, B, B, B, "
22420,"    B, V, C, C, C, V, C, C, C, V, C, C, C, C, C, V, "
22421,"    C, C, C, C, C, V, C, C, C, C, C, B, B, B, B, B, "
22422,};
22423,#undef B
22424,#undef D
22425,#undef C
22426,#undef V
22427,
22428,int main() {
22429,"    char *formato = ""VCD"";"
22430,"    char *arr[] = { ""2og"", ""Ok1"", ""Ok"", ""oK2"", };"
22431,
22432,    for( int i = 0; i < sizeof arr/sizeof arr[0]; i++ ) {
22433,        char *str = arr[ i ];
22434,        char *wnt = formato;
22435,
22436,        while( *wnt == tbl[ *str ] )
22437,"            wnt++, str++;"
22438,
22439,        if ( !*str && !*wnt )
22440,            puts( arr[ i ] );
22441,    }
22442,    return 0;
22443,}
22444,1
22445,3
22446,wnt
22447,b101
22448,:)
22449,:-)
22450,:-)
22451,legit
22452,:)
22453,:-)
22454,:-)
22455,system()
22456,jobs
22457,prows
22458,void *
22459,initBoard
22460,prows
22461,initBoard
22462,prows
22463,/***
22464, * =======================================
22465, *                board.h
22466, * =======================================
22467,***/
22468,
22469,#ifndef BOARD_H_INCLUDED
22470,#define BOARD_H_INCLUDED
22471,
22472,const unsigned int boardDim = 3;
22473,
22474,typedef struct {
22475,    int * (*prows)[boardDim];
22476,    int score;
22477,    unsigned int turn;
22478,    _Bool isTerminal;
22479,} Board;
22480,
22481,Board * initBoard(void);
22482,
22483,#endif
22484,
22485,
22486,
22487,/***
22488, * =======================================
22489, *                board.c
22490, * =======================================
22491,***/
22492,
22493,#include <stdio.h>
22494,#include <stdlib.h>
22495,
22496,"#include ""board.h"""
22497,
22498,/*
22499," * to initialize the prows field of a new Board struct, I figured it would be a good"
22500, * approach to first initialize the array of int pointers to which prows points to and 
22501, * then initialize prows by taking the address of the initialized array of int pointers
22502,*/
22503,Board * initBoard(void) {
22504,    /*
22505,"     * initialize array of int pointers called ""rows"" ..."
22506,     *
22507,"     * from what I know, rows stores the address of the first element in the array's"
22508,"     * memory block, so a pointer to the ""rows"" array will essentially be a pointer to an"
22509,"     * int pointer, so we should cast the returned void pointer (void *) from malloc to "
22510,     * type pointer to int pointer (int **) ...
22511,     * 
22512,"     * lastly, because rows will contain (boardDim) number of pointers (one for each row"
22513,"     * in the board), inside malloc, I should pass ""boardDim * sizeof(int *)"" to allocate"
22514,     * (boardDim) number of int pointers
22515,    */
22516,    int * rows[boardDim] = (int **) malloc(boardDim * sizeof(int *));
22517,    
22518,    int * row;
22519,    for (row = rows; row < rows + boardDim; row++) {
22520,        row = (int *) malloc(sizeof(int));
22521,    }
22522,
22523,    int * (*prows)[boardDim] = &rows;
22524,
22525,"    int score = 0, turn = 0;"
22526,    _Bool isTerminal = 0;
22527,
22528,    Board * board = (Board *) malloc(sizeof(Board));
22529,
22530,    board->prows = prows;
22531,    board->score = score;
22532,    board->turn = turn;
22533,    board->isTerminal = isTerminal;
22534,
22535,    return board;
22536,}
22537,Board
22538,prows
22539,int
22540,int (*prows)[boardDim]
22541,prows
22542,int rows[boardDim][boardDim];
22543,Board *board = malloc(sizeof *board);
22544,Board
22545,#define boardDim  3
22546,#define boardDim 3
22547,
22548,int *(*prows)[boardDim];
22549,prows = malloc(sizeof(int *[boardDim]));
22550,    int rval3= 0x0c10; // want to make this generic
22551,    int rval3= *buf;
22552,    int rev;
22553,    rev = (rval3 >>10) & 0x7;
22554,"    printf(""rval3 = %X\n"", rval3);"
22555,"    printf(""rev = %x\n"", rev);"
22556,rval3 = C10
22557,rev = 3
22558,"    char *cmd = ""/opt/phytool read ps0e0/0xEF/3"";"
22559,    char buf[BUFSIZE];
22560,    FILE *fp;
22561,"       if ((fp = popen(cmd, ""r"")) == NULL) {"
22562,"        printf(""Error opening pipe!\n"");"
22563,        return -1;
22564,    }
22565,
22566,"    while (fgets(buf, BUFSIZE, fp) != NULL) {"
22567,        // Do whatever you want here...
22568,"        printf(""OUTPUT: %s"", buf); // OUTPUT: 0x0c10"
22569,    }
22570,
22571,    if (pclose(fp)) {
22572,"        printf(""Command not found or exited with error status\n"");"
22573,        return -1;
22574,    }
22575,
22576,    //int rval3= 0x0c10; // want to make this generic
22577,    int rval3= *buf; // buf holds 0x0c10
22578,    int rev;
22579,    rev = (rval3 >>10) & 0x7;
22580,"    printf(""rval3 = %X\n"", rval3);"
22581,"    printf(""rev = %x\n"", rev);"
22582,rval3 = 30
22583,rev = 0
22584,int rval3= *buf
22585,*buf
22586,char
22587,char
22588,rval3
22589,0x0c10
22590,0x0c10
22591,"""0x0c10"""
22592,buf
22593,"""0x0c10"""
22594,*buf
22595,buf[0]
22596,'0'
22597,48
22598,0x30
22599,0x
22600,    #include <unistd.h>
22601,
22602,"   unsigned int ft_strlcat(char *dest, char *src, unsigned int size)"
22603,    
22604,
22605,    
22606,    unsigned int dest_len = 0;
22607,    unsigned int src_len = 0;
22608,    while (dest[dest_len])
22609,        dest_len++;
22610,    while (src[src_len] && (src_len + dest_len + 1) < size)
22611,    {
22612,        dest[dest_len + src_len] = src[src_len];
22613,        src_len++;
22614,    }
22615,    while (src[src_len])
22616,        src_len++;
22617,    dest[dest_len + src_len] = 0;
22618,    if (size <= dest_len)
22619,        return (src_len + size);
22620,    else
22621,        return (dest_len + src_len);
22622,}
22623,while (src[src_len]) src_len++;
22624,src_len
22625,src_len
22626,if (size <= dest_len) return (src_len + size);
22627,// hauptteil.c (main part)
22628,"#include ""nebenfkt.h"""
22629,#include <stdio.h>
22630,#include <stdlib.h>
22631,
22632,int main (void)
22633,{
22634,    int x =10;
22635,    int ergebnis=0;
22636,    ergebnis =ver(x);
22637,"    printf(""Doubled number: %d"", ergebnis);"
22638,    return 0;
22639,}
22640,//nebenfkt.h
22641,int ver(int x);
22642,"#include ""nebenfkt.h"""
22643,#include <stdio.h>
22644,#include <stdlib.h>
22645,
22646,
22647,int ver(int x)
22648,{
22649,    int rueck;
22650,    rueck= x*2;
22651,    return rueck;
22652,}
22653,ausgabe
22654,.c
22655,    #include <stdio.h>
22656,    #include <stdlib.h>
22657,
22658,    int ver(int x)
22659,    {
22660,        int rueck;
22661,        rueck= x*2;
22662,        return rueck;
22663,    }
22664,    int main (void)
22665,    {
22666,        int x =10;
22667,        int ergebnis=0;
22668,        ergebnis =ver(x);
22669,"        printf(""Doubled number: %d"", ergebnis);"
22670,        return 0;
22671,    }
22672,libtiff-3.9.1
22673,[ 28%] Performing configure step for 'libtiff-3.9.6'
22674,checking build system type... i386-apple-darwin21.5.0
22675,checking host system type... i386-apple-darwin21.5.0
22676,checking for a BSD-compatible install... /usr/bin/install -c
22677,checking whether build environment is sane... yes
22678,checking for a thread-safe mkdir -p... config/install-sh -c -d
22679,checking for gawk... no
22680,checking for mawk... no
22681,checking for nawk... no
22682,checking for awk... awk
22683,checking whether make sets $(MAKE)... yes
22684,checking whether to enable maintainer-specific portions of Makefiles... no
22685,checking whether build environment is sane... yes
22686,checking for gcc... /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc
22687,checking whether the C compiler works... no
22688,configure: error: in `/Users/ziadmalik/Desktop/project/amongus/build/_deps/libtiff-3.9.6/src':
22689,configure: error: C compiler cannot create executables
22690,See `config.log' for more details
22691,config.log
22692,configure:3675: checking for C compiler version
22693,configure:3684: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc --version >&5
22694,Apple clang version 13.1.6 (clang-1316.0.21.2)
22695,Target: x86_64-apple-darwin21.5.0
22696,Thread model: posix
22697,InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
22698,configure:3695: $? = 0
22699,configure:3684: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -v >&5
22700,Apple clang version 13.1.6 (clang-1316.0.21.2)
22701,Target: x86_64-apple-darwin21.5.0
22702,Thread model: posix
22703,InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
22704,configure:3695: $? = 0
22705,configure:3684: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -V >&5
22706,clang: error: argument to '-V' is missing (expected 1 value)
22707,clang: error: no input files
22708,configure:3695: $? = 1
22709,configure:3684: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -qversion >&5
22710,clang: error: unknown argument '-qversion'; did you mean '--version'?
22711,clang: error: no input files
22712,configure:3695: $? = 1
22713,configure:3715: checking whether the C compiler works
22714,configure:3737: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -O3 -DNDEBUG -Wno-everything   conftest.c  >&5
22715,ld: library not found for -lSystem
22716,clang: error: linker command failed with exit code 1 (use -v to see invocation)
22717,configure:3741: $? = 1
22718,configure:3779: result: no
22719,configure: failed program was:
22720,| /* confdefs.h */
22721,"| #define PACKAGE_NAME ""LibTIFF Software"""
22722,"| #define PACKAGE_TARNAME ""tiff"""
22723,"| #define PACKAGE_VERSION ""3.9.6"""
22724,"| #define PACKAGE_STRING ""LibTIFF Software 3.9.6"""
22725,"| #define PACKAGE_BUGREPORT ""tiff@lists.maptools.org"""
22726,"| #define PACKAGE_URL """""
22727,"| #define PACKAGE ""tiff"""
22728,"| #define VERSION ""3.9.6"""
22729,| /* end confdefs.h.  */
22730,|
22731,| int
22732,| main ()
22733,| {
22734,|
22735,|   ;
22736,|   return 0;
22737,| }
22738,configure:3784: error: in `/Users/ziadmalik/Desktop/project/amongus/build/_deps/libtiff-3.9.6/src':
22739,configure:3786: error: C compiler 
22740,configure:3684: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -V >&5 clang: error: argument to '-V' is missing (expected 1 value)
22741,gcc
22742,clang
22743,#include <stdio.h>
22744,#include <stdlib.h>
22745,#include <linux/keyboard.h>
22746,#include <sys/ioctl.h>
22747,#include <sys/kd.h>
22748,
22749,int
22750,"main(int argc, char **argv) {"
22751,  struct kbentry ke;
22752,  
22753,  ke.kb_table = (unsigned char)atoi(argv[1]);
22754,  ke.kb_index = (unsigned char)atoi(argv[2]);
22755,"  ioclt(0, KDGKBENT, &ke);"
22756,"  printf(""keycode %u = %04x\n"", ke.kb_index, ke.kb_value);"
22757,  return 0;
22758,}
22759,FFmpeg Kit
22760,FFmpegKit.execute
22761,asBytes
22762,originalVideo
22763,watermark
22764,ffmpeg_kit_flutter: ^4.5.1
22765,import 'package:ffmpeg_kit_flutter/ffmpeg_kit.dart';
22766,
22767,"Future<File> waterMarkVideo(String videoPath, String watermarkPath) async {"
22768,    //these calls are to load the video into temporary directory
22769,    final response = await http.get(Uri.parse(videoPath));
22770,    final originalVideo = File ('${(await getTemporaryDirectory()).path}/video.mp4');
22771,    await originalVideo.create(recursive: true);
22772,    await originalVideo.writeAsBytes(response.bodyBytes);
22773,    print('video path' + originalVideo.path);
22774,
22775,    //this grabs the watermark image from assets and decodes it
22776,    final byteData = await rootBundle.load(watermarkPath);
22777,    final watermark = File('${(await getTemporaryDirectory()).path}/image.png');
22778,    await watermark.create(recursive: true);
22779,"    await watermark.writeAsBytes(byteData.buffer.asUint8List(byteData.offsetInBytes, byteData.lengthInBytes));"
22780,    print('watermark path' + watermark.path);
22781,
22782,    //this creates temporary directory for new watermarked video
22783,    var tempDir = await getTemporaryDirectory();
22784,    final newVideoPath = '${tempDir.path}/${DateTime.now().microsecondsSinceEpoch}result.mp4';
22785,    final videoFile = await File(newVideoPath).create();
22786,
22787,//overlaying video using FFmpegkit where I need some help
22788,"    await FFmpegKit.executeAsync(""-i $originalVideo -i $watermark -filter_complex 'overlay=(W-w)/2:(H-h)/2' $videoFile"")"
22789,    .then((session) async {
22790,      final state = FFmpegKitConfig.sessionStateToString(await session.getState());
22791,      final returnCode = await session.getReturnCode();
22792,      final failStackTrace = await session.getFailStackTrace();
22793,      final output = await session.getOutput();
22794,      print('FFmpeg process exited with state ${state} and rs ${returnCode}.If failed ${failStackTrace}');
22795,      print('Last output $output');
22796,    } );
22797,    print('new video path' + newVideoPath);
22798,    Uint8List videoByteData = await videoFile.readAsBytes();
22799,    return videoFile.writeAsBytes(videoByteData);
22800,}
22801,flutter: video path/Users/dennisashford/Library/Developer/CoreSimulator/Devices/FBFB4D51-EC31-47DF-8FE0-66B114806EA4/data/Containers/Data/Application/0EA3BB35-D364-4B98-A104-15CDB17AAD54/Library/Caches/video.mp4
22802,flutter: watermark path/Users/dennisashford/Library/Developer/CoreSimulator/Devices/FBFB4D51-EC31-47DF-8FE0-66B114806EA4/data/Containers/Data/Application/0EA3BB35-D364-4B98-A104-15CDB17AAD54/Library/Caches/image.png
22803,ffmpeg version v4.5-dev-3393-g30322ebe3c Copyright (c) 2000-2021 the FFmpeg developers
22804,  built with Apple clang version 13.0.0 (clang-1300.0.29.30)
22805,  configuration: --cross-prefix=x86_64-ios-darwin- --sysroot=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk --prefix=/Users/taner/Projects/ffmpeg-kit/prebuilt/apple-ios-x86_64/ffmpeg --pkg-config=/opt/homebrew/bin/pkg-config --enable-version3 --arch=x86_64 --cpu=x86_64 --target-os=darwin --disable-neon --disable-asm --ar=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar --cc=clang --cxx=clang++ --as='clang -arch x86_64 -target x86_64-apple-ios12.1-simulator -march=x86-64 -msse4.2 -mpopcnt -m64 -DFFMPEG_KIT_X86_64 -Wno-unused-function -Wno-deprecated-declarations -fstrict-aliasing -DIOS -DFFMPEG_KIT_BUILD_DATE=20220114 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk -O2 -mios-simulator-version-min=12.1 -I/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk/usr/include' --ranlib=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib --strip=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip --nm=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm --extra-ldflags='-mios-simulator-version-min=12.1' --disable-autodetect --enable-cross-compile --enable-pic --enable-inline-asm --enable-optimizations --enable-swscale --enable-shared --disable-static --install-name-dir='@rpath' --enable-pthreads --disable-v4l2-m2m --disable-outdev=v4l2 --disable-outdev=fbdev --disable-indev=v4l2 --disable-indev=fbdev --enable-small --disable-xmm-clobber-test --disable-debug --disable-neon-clobber-test --disable-programs --disable-postproc --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-sndio --disable-schannel --disable-securetransport --disable-xlib --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --disable-alsa --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --enable-gmp --enable-gnutls --disable-sdl2 --disable-openssl --enable-zlib --enable-audiotoolbox --disable-outdev=audiotoolbox --enable-bzlib --enable-videotoolbox --enable-avfoundation --enable-iconv --disable-coreimage --disable-appkit --disable-opencl --disable-opengl
22806,  libavutil      57. 13.100 / 57. 13.100
22807,  libavcodec     59. 15.102 / 59. 15.102
22808,  libavformat    59. 10.100 / 59. 10.100
22809,  libavdevice    59.  1.100 / 59.  1.100
22810,  libavfilter     8. 21.100 /  8. 21.100
22811,  libswscale      6.  1.102 /  6.  1.102
22812,  libswresample   4.  0.100 /  4.  0.100
22813,File:: Protocol not found
22814,Did you mean file:File:?
22815,flutter: FFmpeg process exited with state RUNNING and rs 1.If failed null
22816,flutter: Last output ffmpeg version v4.5-dev-3393-g30322ebe3c Copyright (c) 2000-2021 the FFmpeg developers
22817,flutter:   built with Apple clang version 13.0.0 (clang-1300.0.29.30)
22818,flutter:   configuration: --cross-prefix=x86_64-ios-darwin- --sysroot=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk --prefix=/Users/taner/Projects/ffmpeg-kit/prebuilt/apple-ios-x86_64/ffmpeg --pkg-config=/opt/homebrew/bin/pkg-config --enable-version3 --arch=x86_64 --cpu=x86_64 --target-os=darwin --disable-neon --disable-asm --ar=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar --cc=clang --cxx=clang++ --as='clang -arch x86_64 -target x86_64-apple-ios12.1-simulator -march=x86-64 -msse4.2 -mpopcnt -m64 -DFFMPEG_KIT_X86_64 -Wno-unused-function -Wno-deprecated-declarations -fstrict-aliasing -DIOS -DFFMPEG_KIT_BUILD_DATE=20220114 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk -O2 -mios-simulator-version-min=12.1 -I/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator15.2.sdk/usr/include' --ranlib=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib --strip=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip --nm=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm --extra-ldflags='-mios-simulator-version-min=12.1' --disable-autodetect --enable-cross-compile --enable-pic --enable-inline-asm --enable-optimizations --enable-swscale --enable-shared --disable-static --install-name-dir='@rpath' --enable-pthreads --disable-v4l2-m2m --disable-outdev=v4l2 --disable-outdev=fbdev --disable-indev=v4l2 --disable-indev=fbdev --enable-small --disable-xmm-clobber-test --disable-debug --disable-neon-clobber-test --disable-programs --disable-postproc --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-sndio --disable-schannel --disable-securetransport --disable-xlib --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --disable-alsa --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --enable-gmp --enable-gnutls --disable-sdl2 --disable-openssl --enable-zlib --enable-audiotoolbox --disable-outdev=audiotoolbox --enable-bzlib --enable-videotoolbox --enable-avfoundation --enable-iconv --disable-coreimage --disable-appkit --disable-opencl --disable-opengl
22819,flutter:   libavutil      57. 13.100 / 57. 13.100
22820,flutter:   libavcodec     59. 15.102 / 59. 15.102
22821,flutter:   libavformat    59. 10.100 / 59. 10.100
22822,flutter:   libavdevice    59.  1.100 / 59.  1.100
22823,flutter:   libavfilter     8. 21.100 /  8. 21.100
22824,flutter:   libswscale      6.  1.102 /  6.  1.102
22825,flutter:   libswresample   4.  0.100 /  4.  0.100
22826,flutter: File:: Protocol not found
22827,flutter: Did you mean file:File:?
22828,flutter: 
22829,flutter: new video path/Users/dennisashford/Library/Developer/CoreSimulator/Devices/FBFB4D51-EC31-47DF-8FE0-66B114806EA4/data/Containers/Data/Application/0EA3BB35-D364-4B98-A104-15CDB17AAD54/Library/Caches/1661892011213545result.mp4
22830,File:: Protocol not found
22831,Did you mean file:File:?
22832,flutter: video path/var/mobile/Containers/Data/Application/70EA92CD-DF5D-440E-BBE1-C130BC7F0CC7/Library/Caches/video.mp4
22833,flutter: watermark path/var/mobile/Containers/Data/Application/70EA92CD-DF5D-440E-BBE1-C130BC7F0CC7/Library/Caches/image.png
22834,ffmpeg version v4.5-dev-3393-g30322ebe3c Copyright (c) 2000-2021 the FFmpeg developers
22835,  built with Apple clang version 13.0.0 (clang-1300.0.29.30)
22836,  configuration: --cross-prefix=arm64-ios-darwin- --sysroot=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk --prefix=/Users/taner/Projects/ffmpeg-kit/prebuilt/apple-ios-arm64/ffmpeg --pkg-config=/opt/homebrew/bin/pkg-config --enable-version3 --arch=aarch64 --cpu=armv8 --target-os=darwin --enable-neon --enable-asm --ar=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar --cc=clang --cxx=clang++ --as='/Users/taner/Projects/ffmpeg-kit/.tmp/gas-preprocessor.pl -arch aarch64 -- clang -arch arm64 -target arm64-apple-ios12.1 -march=armv8-a+crc+crypto -mcpu=generic -DFFMPEG_KIT_ARM64 -Wno-unused-function -Wno-deprecated-declarations -fstrict-aliasing -fembed-bitcode -DIOS -DFFMPEG_KIT_BUILD_DATE=20220114 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk -Oz -miphoneos-version-min=12.1 -I/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk/usr/include' --ranlib=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib --strip=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip --nm=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm --extra-ldflags='-miphoneos-version-min=12.1' --disable-autodetect --enable-cross-compile --enable-pic --enable-inline-asm --enable-optimizations --enable-swscale --enable-shared --disable-static --install-name-dir='@rpath' --enable-pthreads --disable-v4l2-m2m --disable-outdev=v4l2 --disable-outdev=fbdev --disable-indev=v4l2 --disable-indev=fbdev --enable-small --disable-xmm-clobber-test --disable-debug --disable-neon-clobber-test --disable-programs --disable-postproc --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-sndio --disable-schannel --disable-securetransport --disable-xlib --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --disable-alsa --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --enable-gmp --enable-gnutls --disable-sdl2 --disable-openssl --enable-zlib --enable-audiotoolbox --disable-outdev=audiotoolbox --enable-bzlib --enable-videotoolbox --enable-avfoundation --enable-iconv --disable-coreimage --disable-appkit --disable-opencl --disable-opengl
22837,  libavutil      57. 13.100 / 57. 13.100
22838,  libavcodec     59. 15.102 / 59. 15.102
22839,  libavformat    59. 10.100 / 59. 10.100
22840,  libavdevice    59.  1.100 / 59.  1.100
22841,  libavfilter     8. 21.100 /  8. 21.100
22842,  libswscale      6.  1.102 /  6.  1.102
22843,  libswresample   4.  0.100 /  4.  0.100
22844,File:: Protocol not found
22845,Did you mean file:File:?
22846,flutter: FFmpeg process exited with state RUNNING and rs 1.If failed null
22847,flutter: Last output ffmpeg version v4.5-dev-3393-g30322ebe3c Copyright (c) 2000-2021 the FFmpeg developers
22848,  built with Apple clang version 13.0.0 (clang-1300.0.29.30)
22849,  configuration: --cross-prefix=arm64-ios-darwin- --sysroot=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk --prefix=/Users/taner/Projects/ffmpeg-kit/prebuilt/apple-ios-arm64/ffmpeg --pkg-config=/opt/homebrew/bin/pkg-config --enable-version3 --arch=aarch64 --cpu=armv8 --target-os=darwin --enable-neon --enable-asm --ar=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar --cc=clang --cxx=clang++ --as='/Users/taner/Projects/ffmpeg-kit/.tmp/gas-preprocessor.pl -arch aarch64 -- clang -arch arm64 -target arm64-apple-ios12.1 -march=armv8-a+crc+crypto -mcpu=generic -DFFMPEG_KIT_ARM64 -Wno-unused-function -Wno-deprecated-declarations -fstrict-aliasing -fembed-bitcode -DIOS -DFFMPEG_KIT_BUILD_DATE=20220114 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk -Oz -miphoneos-version-min=12.1 -I/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS15.2.sdk/usr/include' --ranlib=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib --strip=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip --nm=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm --extra-ldflags='-miphoneos-version-min=12.1' --disable-autodetect --enable-cross-compile --enable-pic --enable-inline-asm --enable-optimizations --enable-swscale --enable-shared --disable-static --install-name-dir='@rpath' --enable-pthreads --disable-v4l2-m2m --disable-outdev=v4l2 --disable-outdev=fbdev --disable-indev=v4l2 --disable-indev=fbdev --enable-small --disable-xmm-clobber-test --disable-debug --disable-neon-clobber-test --disable-programs --disable-postproc --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-sndio --disable-schannel --disable-securetransport --disable-xlib --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --disable-alsa --disable-cuda --disable-cuvid --disable-nvenc --disable-vaapi --disable-vdpau --enable-gmp --enable-gnutls --disable-sdl2 --disable-openssl --enable-zlib --enable-audiotoolbox --disable-outdev=audiotoolbox --enable-bzlib --enable-videotoolbox --enable-avfoundation --enable-iconv --disable-coreimage --disable-appkit --disable-opencl --disable-opengl
22850,  libavutil      57. 13.100 / 57. 13.100
22851,  libavcodec     59. 15.102 / 59. 15.102
22852,  libavformat    59. 10.100 / 59. 10.100
22853,  libavdevice    59.  1.100 / 59.  1.100
22854,  libavfilter     8. 21.100 /  8. 21.100
22855,  libswscale      6.  1.102 /  6.  1.102
22856,  libswresample   4.  0.100 /  4.  0.100
22857,File:: Protocol not found
22858,Did you mean file:File:?
22859,flutter: new video path/var/mobile/Containers/Data/Application/70EA92CD-DF5D-440E-BBE1-C130BC7F0CC7/Library/Caches/1661891272856433result.mp4
22860,"await FFmpegKit.executeAsync('-i $videoPath -i ${watermark.path} -filter_complex ""overlay=10:10"" -y ${videoFile.path}')"
22861,originalVideo
22862,watermark
22863,FFmpeg process exited with state COMPLETED and rs 1.
22864,flutter: Last output ffmpeg version v4.5...
22865,<…>
22866,File:...
22867,File:
22868,file:
22869,#include <stdio.h>
22870,#include <cs50.h>
22871,
22872,int main(void)
22873,{
22874,"    string name = get_string(""What's your name? "");"
22875,"    printf(""hello, %s/n "" , name);"
22876,}
22877,d:/vs compiler/mingw/bin/../lib/gcc/x86_64-w64-mingw32/11.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\MHAMAD~1\AppData\Local\Temp\cc2BDKsf.o:hello.c:(.text+0x6e): undefined reference to `get_string'
22878,collect2.exe: error: ld returned 1 exit status
22879,#include <cs50.h>
22880,"#include ""cs50.h"""
22881,arr_integer
22882,typedef struct arr_integer{
22883,
22884,int size;
22885,
22886,int *arr;}arr_integer;
22887,int solution(arr_integer inputArray) {
22888,    int n = inputArray.size;
22889,"    int i, j;"
22890,    for ( i=0 ; i<n-1 ; i++ )
22891,        for ( j=i+1 ; j<n ; j++ )
22892,            if ( inputArray.arr[i] > inputArray.arr[j] )
22893,            {
22894,                int pom = inputArray.arr[i];
22895,                inputArray.arr[i] = inputArray.arr[j];
22896,                inputArray.arr[j] = pom;
22897,            }
22898,    int a[10000];
22899,    for ( i=0 ; i<=10000 ; i++ )
22900,        a[i] = 0;
22901,
22902,    for ( i=0 ; i<n ; i++ )
22903,        a[inputArray.arr[i]] = 1;
22904,
22905,    int br = 0;
22906,    for ( i=1 ; i<=inputArray.arr[n-1]+1 ; i++ )
22907,    {
22908,        for ( j=1 ; j<inputArray.arr[n-1] ; j++ )
22909,        {
22910,            if ( a[i*j] == 1 )
22911,            {
22912,                br++;
22913,                break;
22914,            }   
22915,        }
22916,        if( br == 0 )
22917,            return i;
22918,        br = 0;
22919,    }
22920,}
22921,%
22922,10000
22923,for ( i=0 ; i<=10000 ; i++ )
22924,i==10000
22925,for (i = 0 ; i < xy; i++)
22926,<=
22927,"{10000, 11000, 11001}"
22928,"// #include ""include/main.h"""
22929,#include <time.h>
22930,
22931,#include <stdio.h>
22932,#include <stdlib.h>
22933,#define QUEUE_SIZE 30
22934,
22935,typedef float dataArray[20];
22936,
22937,struct node
22938,{
22939,    dataArray *data;
22940,    struct node *next;
22941,};
22942,typedef struct node node;
22943,
22944,struct queue
22945,{
22946,    int count;
22947,    node *front;
22948,    node *rear;
22949,};
22950,typedef struct queue queue;
22951,
22952,void initialize(queue *q);
22953,int is_empty(queue *q);
22954,"void enqueue(queue *q, dataArray value);"
22955,"void dequeue(queue *q, dataArray *outputArray);"
22956,void display(node *head);
22957,
22958,float random_float();
22959,
22960,void initialize(queue *q)
22961,{
22962,    q->count = 0;
22963,    q->front = NULL;
22964,    q->rear = NULL;
22965,}
22966,
22967,int is_empty(queue *q)
22968,{
22969,    return (q->rear == NULL);
22970,}
22971,
22972,"void enqueue(queue *q, dataArray value)"
22973,{
22974,    if (q->count == QUEUE_SIZE)
22975,    {
22976,        dataArray tmp;
22977,"        dequeue(q, &tmp);"
22978,        free(tmp);
22979,    }
22980,    node *tmp;
22981,    tmp = malloc(sizeof(node));
22982,"    printf(""[enqueue] sizeof node %d\r\n"", (uint) sizeof(node));"
22983,"    // memcpy(tmp->data, value, sizeof(value));"
22984,    tmp->data = &value;
22985,    tmp->next = NULL;
22986,    
22987,"    printf("" contents of value in enqueue\n"");"
22988,    for (int i = 0; i < 20; i++)
22989,    {
22990,"        printf(""%f\n"", value[i]);"
22991,    }
22992,
22993,"    printf("" contents of tmp-node in enqueue\n"");"
22994,    for (int i = 0; i < 20; i++)
22995,    {
22996,"        printf(""%f\n"", tmp->data[i]);"
22997,    }
22998,
22999,    if (!is_empty(q))
23000,    {
23001,        q->rear->next = tmp;
23002,        q->rear = tmp;
23003,    }
23004,    else
23005,    {
23006,        q->front = q->rear = tmp;
23007,    }
23008,    q->count++;
23009,}
23010,
23011,"void dequeue(queue *q, dataArray *outputArray)"
23012,{
23013,    node *tmp;
23014,    outputArray = q->front->data;
23015,"    printf(""dequeue output before freeing memory\r\n===========\r\n"");"
23016,    for (int i = 0; i < 20; i++)
23017,    {
23018,"        printf(""%f\n"", outputArray[i]);"
23019,    }
23020,"    printf(""[dequeue] size %d - %d\r\n"", (uint) sizeof(q->front->data), (uint) sizeof(q->front->data[0]));"
23021,    tmp = q->front;
23022,    q->front = q->front->next;
23023,    q->count--;
23024,    free(tmp);
23025,}
23026,
23027,void display(node *head)
23028,{
23029,    if (head == NULL)
23030,    {
23031,"        printf(""NULL\r\n"");"
23032,    }
23033,    else
23034,    {
23035,        for (int i = 0; i < 20; i++)
23036,        {
23037,"            printf(""%f\n"", head->data[i]);"
23038,        }
23039,
23040,        display(head->next);
23041,    }
23042,}
23043,
23044,float random_float()
23045,{
23046,    srand((unsigned int)time(NULL));
23047,
23048,    float a = 50.0;
23049,    return ((float)rand() / (float)(RAND_MAX)) * a;
23050,}
23051,
23052,int main()
23053,{
23054,    queue *q;
23055,    q = malloc(sizeof(queue));
23056,    initialize(q);
23057,    srand((unsigned int)time(NULL));
23058,
23059,    dataArray tmp;
23060,    for (int i = 0; i < 20; i++)
23061,    {
23062,        tmp[i] = random_float();
23063,    }
23064,"    printf(""display dataArray before fill\r\n===========\r\n"");"
23065,    for (int i = 0; i < 20; i++)
23066,    {
23067,"        printf(""%f\n"", tmp[i]);"
23068,    }
23069,
23070,"    enqueue(q, tmp);"
23071,    
23072,"    printf(""Queue display after init and fill\r\n===========\r\n"");"
23073,// THIS WILL PRINT 0 <<<<--------------------------------------- what it shouldn't
23074,    display(q->front);
23075,
23076,"    printf(""Queue before dequeue\r\n===========\r\n"");"
23077,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23078,    // Nächsten Queue Eintrag holen
23079,    dataArray *queData = malloc(sizeof(dataArray));
23080,"    dequeue(q, queData);"
23081,"    printf(""Queue after dequeue\r\n===========\r\n"");"
23082,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23083,
23084,    for (int i = 0; i < 20; i++)
23085,    {
23086,"        printf(""%f\n"", queData[i]);"
23087,    }
23088,    return 0;
23089,}
23090,"// #include ""include/main.h"""
23091,#include <time.h>
23092,
23093,#include <stdio.h>
23094,#include <stdlib.h>
23095,#define QUEUE_SIZE 30
23096,
23097,typedef float dataArray[20];
23098,
23099,struct node
23100,{
23101,    dataArray *data;
23102,    struct node *next;
23103,};
23104,typedef struct node node;
23105,
23106,struct queue
23107,{
23108,    int count;
23109,    node *front;
23110,    node *rear;
23111,};
23112,typedef struct queue queue;
23113,
23114,void initialize(queue *q);
23115,int is_empty(queue *q);
23116,"void enqueue(queue *q, dataArray *value);"
23117,"void dequeue(queue *q, dataArray *outputArray);"
23118,void display(node *head);
23119,
23120,float random_float();
23121,
23122,void initialize(queue *q)
23123,{
23124,    q->count = 0;
23125,    q->front = NULL;
23126,    q->rear = NULL;
23127,}
23128,
23129,int is_empty(queue *q)
23130,{
23131,    return (q->rear == NULL);
23132,}
23133,
23134,"void enqueue(queue *q, dataArray *value)"
23135,{
23136,    if (q->count == QUEUE_SIZE)
23137,    {
23138,        dataArray tmp;
23139,"        dequeue(q, &tmp);"
23140,        free(tmp);
23141,    }
23142,    
23143,"    printf("" contents of value in enqueue\n"");"
23144,    for (int i = 0; i < 20; i++)
23145,    {
23146,"        printf(""%f\n"", *value[i]);"
23147,    }
23148,    
23149,    node *tmp;
23150,    tmp = malloc(sizeof(node));
23151,"    printf(""[enqueue] sizeof node %d\r\n"", (uint) sizeof(node));"
23152,"    // memcpy(tmp->data, &value, sizeof(value));"
23153,    tmp->data = value;
23154,    tmp->next = NULL;
23155,    
23156,
23157,
23158,"    printf("" contents of tmp-node in enqueue\n"");"
23159,    for (int i = 0; i < 20; i++)
23160,    {
23161,"        printf(""%f\n"", tmp->data[i]);"
23162,    }
23163,
23164,    if (!is_empty(q))
23165,    {
23166,        q->rear->next = tmp;
23167,        q->rear = tmp;
23168,    }
23169,    else
23170,    {
23171,        q->front = q->rear = tmp;
23172,    }
23173,    q->count++;
23174,}
23175,
23176,"void dequeue(queue *q, dataArray *outputArray)"
23177,{
23178,    node *tmp;
23179,    outputArray = q->front->data;
23180,"    printf(""dequeue output before freeing memory\r\n===========\r\n"");"
23181,    for (int i = 0; i < 20; i++)
23182,    {
23183,"        printf(""%f\n"", outputArray[i]);"
23184,    }
23185,"    printf(""[dequeue] size %d - %d\r\n"", (uint) sizeof(q->front->data), (uint) sizeof(q->front->data[0]));"
23186,    tmp = q->front;
23187,    q->front = q->front->next;
23188,    q->count--;
23189,    free(tmp);
23190,}
23191,
23192,void display(node *head)
23193,{
23194,    if (head == NULL)
23195,    {
23196,"        printf(""NULL\r\n"");"
23197,    }
23198,    else
23199,    {
23200,        for (int i = 0; i < 20; i++)
23201,        {
23202,"            printf(""%f\n"", head->data[i]);"
23203,        }
23204,
23205,        display(head->next);
23206,    }
23207,}
23208,
23209,float random_float()
23210,{
23211,    srand((unsigned int)time(NULL));
23212,
23213,    float a = 50.0;
23214,    return ((float)rand() / (float)(RAND_MAX)) * a;
23215,}
23216,
23217,int main()
23218,{
23219,    queue *q;
23220,    q = malloc(sizeof(queue));
23221,    initialize(q);
23222,    srand((unsigned int)time(NULL));
23223,
23224,    dataArray tmp;
23225,    for (int i = 0; i < 20; i++)
23226,    {
23227,        tmp[i] = random_float();
23228,    }
23229,"    printf(""display dataArray before fill\r\n===========\r\n"");"
23230,    for (int i = 0; i < 20; i++)
23231,    {
23232,"        printf(""%f\n"", tmp[i]);"
23233,    }
23234,
23235,"    enqueue(q, &tmp);"
23236,    
23237,"    printf(""Queue display after init and fill\r\n===========\r\n"");"
23238,    display(q->front);
23239,
23240,"    printf(""Queue before dequeue\r\n===========\r\n"");"
23241,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23242,    // Nächsten Queue Eintrag holen
23243,    dataArray *queData = malloc(sizeof(dataArray));
23244,"    dequeue(q, queData);"
23245,"    printf(""Queue after dequeue\r\n===========\r\n"");"
23246,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23247,
23248,    for (int i = 0; i < 20; i++)
23249,    {
23250,"        printf(""%f\n"", queData[i]);"
23251,    }
23252,    return 0;
23253,}
23254,typedef
23255,typedef
23256,malloc
23257,malloc
23258,free
23259,malloc
23260,printf()
23261,%f
23262,double
23263,float *
23264,typedef
23265,typedef
23266,// typedef float dataArray[20];
23267,"void enqueue(queue *q, dataArray *value) { ..."
23268,dataArray *value
23269,float *value[20];
23270,float *[20]
23271,20
23272,float
23273,tmp->data = value;
23274,value
23275,float
23276,float**
23277,tmp->data
23278,float
23279,typedef
23280,"void enqueue(queue *q, float *value[20])"
23281,{
23282,    if (q->count == QUEUE_SIZE)
23283,    {
23284,        float tmp[20];
23285,"        dequeue(q, &tmp);"
23286,        // free(tmp);         /* you can't free what's not allocated */
23287,    }
23288,    
23289,"    printf("" contents of value in enqueue\n"");"
23290,    for (int i = 0; i < 20; i++)
23291,    {
23292,"        printf(""%f\n"", *value[i]);"
23293,    }
23294,    
23295,    node *tmp;
23296,    tmp = malloc(sizeof(node));
23297,"    printf(""[enqueue] sizeof node %d\r\n"", (uint) sizeof(node));"
23298,"    // memcpy(tmp->data, &value, sizeof(value));"
23299,    tmp->data = value;
23300,    tmp->next = NULL;
23301,    ...
23302,memcpy()
23303,source.c:65:15: error: assignment to expression with array type
23304,     tmp->data = value;
23305,               ^
23306,main()
23307,enqueue()
23308,int main()
23309,{
23310,    ...
23311,    dataArray tmp;        /* e.g. float tmp[20] */
23312,    ...
23313,"    enqueue(q, &tmp);"
23314,    ...
23315,}
23316,tmp
23317,float (*)[20]
23318,float[20]
23319,float
23320,float (*)[20]
23321,float *[20]
23322,&tmp
23323,"enqueue(q, &tmp);"
23324,tmp
23325,value
23326,"void enqueue(queue *q, dataArray *value)"
23327,value[i]
23328,i > 0
23329,value[1]
23330,tmp
23331,main()
23332,float[20]
23333,srand()
23334,random_float()
23335,memcpy()
23336,typedef
23337,#include <time.h>
23338,
23339,#include <stdio.h>
23340,#include <stdlib.h>
23341,#include <string.h>
23342,
23343,#define QUEUE_SIZE 30
23344,#define ASZ 20
23345,
23346,// typedef float dataArray[20];
23347,typedef unsigned uint;
23348,
23349,struct node
23350,{
23351,    float data[ASZ];
23352,    struct node *next;
23353,};
23354,typedef struct node node;
23355,
23356,struct queue
23357,{
23358,    int count;
23359,    node *front;
23360,    node *rear;
23361,};
23362,typedef struct queue queue;
23363,
23364,void initialize(queue *q);
23365,int is_empty(queue *q);
23366,"void enqueue(queue *q, float *value);"
23367,"void dequeue(queue *q, float *outputArray);"
23368,void display(node *head);
23369,
23370,float random_float();
23371,
23372,void initialize(queue *q)
23373,{
23374,    q->count = 0;
23375,    q->front = NULL;
23376,    q->rear = NULL;
23377,}
23378,
23379,int is_empty(queue *q)
23380,{
23381,    return (q->rear == NULL);
23382,}
23383,
23384,"void enqueue(queue *q, float *value)"
23385,{
23386,    if (q->count == QUEUE_SIZE)
23387,    {
23388,        float tmp[ASZ];
23389,"        dequeue(q, tmp);"
23390,        // free(tmp);
23391,    }
23392,    
23393,"    printf("" contents of value in enqueue\n"");"
23394,    for (int i = 0; i < ASZ; i++)
23395,    {
23396,"        printf(""%f\n"", value[i]);"
23397,    }
23398,    
23399,    node *tmp;
23400,    tmp = malloc(sizeof(node));
23401,"    printf(""[enqueue] sizeof node %d\r\n"", (uint) sizeof(node));"
23402,"    // memcpy(tmp->data, &value, sizeof(value));"
23403,"    memcpy (tmp->data, value, ASZ * sizeof *value);"
23404,    tmp->next = NULL;
23405,    
23406,"    printf("" contents of tmp-node in enqueue\n"");"
23407,    for (int i = 0; i < ASZ; i++)
23408,    {
23409,"        printf(""%f\n"", tmp->data[i]);"
23410,    }
23411,
23412,    if (!is_empty(q))
23413,    {
23414,        q->rear->next = tmp;
23415,        q->rear = tmp;
23416,    }
23417,    else
23418,    {
23419,        q->front = q->rear = tmp;
23420,    }
23421,    q->count++;
23422,}
23423,
23424,"void dequeue(queue *q, float *outputArray)"
23425,{
23426,    node *tmp;
23427,    outputArray = q->front->data;
23428,"    printf(""dequeue output before freeing memory\r\n===========\r\n"");"
23429,    for (int i = 0; i < ASZ; i++)
23430,    {
23431,"        printf(""%f\n"", outputArray[i]);"
23432,    }
23433,"    printf(""[dequeue] size %d - %d\r\n"", (uint) sizeof(q->front->data), "
23434,            (uint) sizeof(q->front->data[0]));
23435,    tmp = q->front;
23436,    q->front = q->front->next;
23437,    q->count--;
23438,    free(tmp);
23439,}
23440,
23441,void display(node *head)
23442,{
23443,    if (head == NULL)
23444,    {
23445,"        printf(""NULL\r\n"");"
23446,    }
23447,    else
23448,    {
23449,        for (int i = 0; i < ASZ; i++)
23450,        {
23451,"            printf(""%f\n"", head->data[i]);"
23452,        }
23453,
23454,        display(head->next);
23455,    }
23456,}
23457,
23458,float random_float()
23459,{
23460,    float a = 50.0;
23461,    return ((float)rand() / (float)(RAND_MAX)) * a;
23462,}
23463,
23464,int main()
23465,{
23466,    queue *q;
23467,    q = malloc(sizeof(queue));
23468,    initialize(q);
23469,    srand((unsigned int)time(NULL));
23470,
23471,    float tmp[ASZ];
23472,    for (int i = 0; i < ASZ; i++)
23473,    {
23474,        tmp[i] = random_float();
23475,    }
23476,"    printf(""display dataArray before fill\r\n===========\r\n"");"
23477,    for (int i = 0; i < ASZ; i++)
23478,    {
23479,"        printf(""%f\n"", tmp[i]);"
23480,    }
23481,
23482,"    enqueue(q, tmp);"
23483,    
23484,"    printf(""Queue display after init and fill\r\n===========\r\n"");"
23485,    display(q->front);
23486,
23487,"    printf(""Queue before dequeue\r\n===========\r\n"");"
23488,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23489,    // Nächsten Queue Eintrag holen
23490,    float *queData = malloc(sizeof(float[ASZ]));
23491,"    dequeue(q, queData);"
23492,"    printf(""Queue after dequeue\r\n===========\r\n"");"
23493,"    printf(""Queue #1  element count: %d\r\n"", q->count);"
23494,
23495,    for (int i = 0; i < ASZ; i++)
23496,    {
23497,"        printf(""%f\n"", queData[i]);"
23498,    }
23499,    return 0;
23500,}
23501,$ ./bin/llqueue
23502,display dataArray before fill
23503,===========
23504,5.864568
23505,15.599927
23506,1.622677
23507,6.834927
23508,18.953743
23509,43.170605
23510,37.056793
23511,21.260620
23512,44.568668
23513,41.187069
23514,43.298340
23515,8.273252
23516,13.328741
23517,33.927246
23518,32.561504
23519,14.666824
23520,20.176983
23521,30.163134
23522,21.064775
23523,8.606315
23524, contents of value in enqueue
23525,5.864568
23526,15.599927
23527,1.622677
23528,6.834927
23529,18.953743
23530,43.170605
23531,37.056793
23532,21.260620
23533,44.568668
23534,41.187069
23535,43.298340
23536,8.273252
23537,13.328741
23538,33.927246
23539,32.561504
23540,14.666824
23541,20.176983
23542,30.163134
23543,21.064775
23544,8.606315
23545,[enqueue] sizeof node 88
23546, contents of tmp-node in enqueue
23547,5.864568
23548,15.599927
23549,1.622677
23550,6.834927
23551,18.953743
23552,43.170605
23553,37.056793
23554,21.260620
23555,44.568668
23556,41.187069
23557,43.298340
23558,8.273252
23559,13.328741
23560,33.927246
23561,32.561504
23562,14.666824
23563,20.176983
23564,30.163134
23565,21.064775
23566,8.606315
23567,Queue display after init and fill
23568,===========
23569,5.864568
23570,15.599927
23571,1.622677
23572,6.834927
23573,18.953743
23574,43.170605
23575,37.056793
23576,21.260620
23577,44.568668
23578,41.187069
23579,43.298340
23580,8.273252
23581,13.328741
23582,33.927246
23583,32.561504
23584,14.666824
23585,20.176983
23586,30.163134
23587,21.064775
23588,8.606315
23589,NULL
23590,Queue before dequeue
23591,===========
23592,Queue #1  element count: 1
23593,dequeue output before freeing memory
23594,===========
23595,5.864568
23596,15.599927
23597,1.622677
23598,6.834927
23599,18.953743
23600,43.170605
23601,37.056793
23602,21.260620
23603,44.568668
23604,41.187069
23605,43.298340
23606,8.273252
23607,13.328741
23608,33.927246
23609,32.561504
23610,14.666824
23611,20.176983
23612,30.163134
23613,21.064775
23614,8.606315
23615,[dequeue] size 80 - 4
23616,Queue after dequeue
23617,===========
23618,Queue #1  element count: 0
23619,-0.001425
23620,-0.001425
23621,-0.001425
23622,-0.001425
23623,-0.001425
23624,-0.001425
23625,-0.001425
23626,-0.001425
23627,-0.001425
23628,-0.001425
23629,-0.001425
23630,-0.001425
23631,-0.001425
23632,-0.001425
23633,-0.001425
23634,-0.001425
23635,-0.001425
23636,-0.001425
23637,-0.001425
23638,-0.001425
23639,typedef
23640,-Wall -Wextra -pedantic
23641,gcc/clang
23642,-Wshadow
23643,-Werror
23644,cl.exe
23645,/W3
23646,__foo
23647,#include <iostream>
23648,int main()
23649,{
23650,   int inVal;
23651,"   std::cout << ""Enter a decimal integer value: "";"
23652,   std::cin >> inVal;
23653,"   std::cout << inVal << ""\n"";"
23654,}
23655,
23656,#include <stdio.h>
23657,int main(void)
23658,{
23659,   int inVal;
23660,"   printf(""Enter a decimal integer value: "");"
23661,"   scanf(""%d"", &inVal);"
23662,"   printf(""%d\n"", inVal);"
23663,}
23664,#pragma function(memset)
23665,"void* memset(void* dest, int c, size_t count)"
23666,{
23667,    char* bytes = (char*)dest;
23668,    while(count--)
23669,    {
23670,        *bytes++ = (char)c;
23671,    }
23672,
23673,    return dest;
23674,}
23675,
23676,#pragma function(memcpy)
23677,"void* memcpy(void* dest, const void* src, size_t count)"
23678,{
23679,    char* dest8 = (char*)dest;
23680,    const char* src8 = (const char*)src;
23681,    while(count--)
23682,    {
23683,        *dest8++ = *src8++;
23684,    }
23685,    return dest;
23686,}
23687,#pragma function()
23688,#define _CRT_SECURE_NO_WARNINGS
23689,#include <Windows.h>
23690,#include <stdbool.h>
23691,
23692,//This is normally a part of the c runtime library so have to define it here
23693,int _fltused = 0x9875;
23694,
23695,//#define invalid_code_path __debugbreak()
23696,
23697,void error_func()
23698,{
23699,    //msvc break
23700,    //__debugbreak();
23701,}
23702,
23703,#define BGZ_ASSERT(condition) \
23704,do { \
23705,    if(!(condition)) \
23706,        error_func(); \
23707,} while (0)  
23708,
23709,bool app_running = false;
23710,
23711,"LRESULT CALLBACK win32_program_window_callback(HWND WindowHandle, UINT Message, WPARAM wParam, LPARAM lParam) {"
23712,    LRESULT result = { 0 };
23713,
23714,    //For hardware rendering
23715,    HDC WindowContext = GetDC(WindowHandle);
23716,    
23717,    switch (Message)
23718,    {
23719,        case WM_CREATE: {
23720,        }break;
23721,        
23722,        case WM_PAINT: {
23723,"            //To understand why you need a display buffer call here as well as game loop, see this post:"
23724,            //https://hero.handmade.network/forums/code-discussion/t/825-wm_paint_question_beginner
23725,            PAINTSTRUCT Paint;
23726,"            HDC deviceContext = BeginPaint(WindowHandle, &Paint);"
23727,
23728,"            EndPaint(WindowHandle, &Paint);"
23729,        } break;
23730,        
23731,        case WM_DESTROY: {
23732,            app_running = false;
23733,        } break;
23734,        
23735,        case WM_CLOSE: {
23736,            app_running = false;
23737,        } break;
23738,        
23739,        case WM_ACTIVATEAPP: {
23740,        } break;
23741,        
23742,        default: {
23743,"            result = DefWindowProc(WindowHandle, Message, wParam, lParam);"
23744,        } break;
23745,    }
23746,    
23747,    return result;
23748,};
23749,
23750,void win32_process_pending_messages(HWND window) {
23751,    MSG message;
23752,"    while(PeekMessage(&message, 0, 0, 0, PM_REMOVE)) {"
23753,        switch(message.message) {
23754,            case WM_QUIT: {
23755,                app_running = false;
23756,            }break;
23757,
23758,            case WM_SYSKEYDOWN:
23759,            case WM_SYSKEYUP:
23760,            case WM_KEYDOWN:
23761,            case WM_KEYUP: {
23762,
23763,            }break;
23764,
23765,            case WM_MOUSEWHEEL: {
23766,                int delta = GET_WHEEL_DELTA_WPARAM(message.wParam);
23767,            }break;
23768,
23769,            case WM_LBUTTONDOWN:
23770,            case WM_LBUTTONUP: {
23771,
23772,            }break;
23773,
23774,            default: {
23775,                TranslateMessage(&message);
23776,                DispatchMessageA(&message);
23777,            }break;
23778,        }
23779,    }
23780,}
23781,
23782,void __stdcall WinMainCRTStartup() {
23783,    SYSTEM_INFO sysInfo;
23784,    GetSystemInfo(&sysInfo);
23785,    
23786,    WNDCLASS window_properties = {0};
23787,    window_properties.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW; //TODO: Check if OWNDC/HREDRAW/VEDRAW matter
23788,    window_properties.lpfnWndProc = win32_program_window_callback;
23789,    window_properties.hInstance = GetModuleHandle(0);
23790,"    window_properties.lpszClassName = ""my_window_class"";"
23791,"    window_properties.hCursor = LoadCursor(NULL, IDC_ARROW);"
23792,
23793,    if(RegisterClass(&window_properties)) {
23794,        DWORD window_styles = WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
23795,"        RECT rect = (RECT){ 0, 0, (LONG)1280, (LONG)720 };"
23796,"        BOOL success = AdjustWindowRectEx(&rect, window_styles, false, 0);"
23797,
23798,"        HWND window = CreateWindowEx(0, window_properties.lpszClassName, ""My Window"", WS_VISIBLE | WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, rect.right - rect.left, rect.bottom - rect.top, 0, 0, window_properties.hInstance, 0);"
23799,        HDC window_context = GetDC(window);
23800,
23801,        if(window && window_context) {
23802,            app_running = true; 
23803,
23804,            while(app_running) {
23805,                win32_process_pending_messages(window);
23806,            }
23807,
23808,"            PostMessage(window, WM_CLOSE, 0, 0);"
23809,        }
23810,    }
23811,
23812,    int result = 0;
23813,    ExitProcess(result);
23814,}
23815,@echo off
23816,
23817,REM This represents the full directory path to your batch file
23818,set cwd=%~dp0
23819,
23820,REM My own thing. Equivalent to vcvarsall.bat
23821,"call ""C:\msvc\setup.bat"""
23822,
23823,"REM I believe above ""call 'C:msvc\..."" changes directorys so making sure to change back to current directory"
23824,cd /d %cwd%
23825,
23826,REM -GS- tells compiler to not worry about security calls (like __security_cookie) that would typically be inserted with c libs. -Gs99999999999 basically says don't worry about __chkdsk for checking stack overruns
23827,set compiler_flags=-Z7 -nologo -Oi -Od -Ob1 -WX -W4 -GR -EHa- -GS- -Gs999999999 -wd4505 -wd4101 -wd4530 -w14700 -wd4100 -we4820 -wd4201 -wd4189
23828,"REM -STACK:0x100000,0x100000 is setting function stack default to 1MB. Can increase this if we need to. Keep in mind though this also increases default stack size for all threads created"
23829,"set linker_flags=-subsystem:windows -machine:x64 -incremental:no -nologo -opt:ref -debug -ignore:4099 -NODEFAULTLIB -STACK:0x100000,0x100000"
23830,
23831,"set include_paths=-I""%cwd%source"" -I""C:\msvc\Windows Kits\10\Include\10.0.22621.0\um"""
23832,"set library_paths=-LIBPATH:""C:\msvc\Windows Kits\10\Lib\10.0.22621.0\um\x64"""
23833,"set import_libraries=""kernel32.lib"" ""user32.lib"""
23834,
23835,IF NOT EXIST bin mkdir bin
23836,pushd bin
23837,
23838,clang-cl /c ..\source\editor\editor.c %compiler_flags% 
23839,lld-link editor.obj -dll %linker_flags%
23840,
23841,clang-cl /c ..\source\*.c %compiler_flags% %include_paths% -DBGZ_WIN64 -Wno-unused-function -Wno-unused-variable -Wno-unused-but-set-variable
23842,lld-link *.obj -OUT:win64_main.exe %linker_flags% %library_paths% %import_libraries%
23843,
23844,popd
23845,-fno-builtin
23846,#pragma function(x)
23847,-fno-builtin -ffreestanding
23848,.appx
23849,.msix
23850,"printf(""Vendor graphic card: %s\n"", glGetString(GL_VENDOR));"
23851,"printf(""Renderer: %s\n"", glGetString(GL_RENDERER));"
23852,"printf(""Version GL: %s\n"", glGetString(GL_VERSION));"
23853,"printf(""Version GLSL: %s\n"", glGetString(GL_SHADING_LANGUAGE_VERSION));"
23854,Vendor graphic card: Intel
23855,Renderer: Intel(R) HD Graphics 2000
23856,Version GL: 3.1.0 - Build 9.17.10.4459
23857,Version GLSL: 1.40 - Intel Build 9.17.10.4459
23858,.appx
23859,.msix
23860,Vendor graphic card: Microsoft Corporation
23861,Renderer: GDI Generic
23862,Version GL: 1.1.0
23863,Version GLSL: (null)
23864,glCreateShader
23865,.appx
23866,.msix
23867,MakeAppx pack /d <my_file_directory> /p project.msix
23868,"SignTool sign /a /v /fd SHA256 /f mycert.pfx /p ""mypassword"" project.msix"
23869,-s
23870,printf
23871,SDL.h
23872,Program 'main.exe' failed to run: The specified executable is not a valid application for this OS platform
23873,Process terminated with status 32760
23874,-static
23875,ld returned 1 exit status
23876,Dwarf Error: Can't find .debug_ranges section
23877,SDL2-devel-2.24.0-mingw
23878,-s
23879,g++ --version
23880,# include<stdio.h>
23881,
23882,int main() {
23883,"    printf(""%d \n"", 7%9); //integer result"
23884,"    printf(""%f"", 7%9); //float result"
23885,    return 0;
23886,}
23887,7 % 9
23888,%f
23889,fmodf
23890,7
23891,9
23892,%
23893,7.0f % 9.0f
23894,%f
23895,int
23896,-Wall -Wextra -pedantic
23897,"printf(""%d \n"", 7%9); //integer result"
23898,"printf(""%f"", 7%9); //float result"
23899,format specifiers
23900,integer
23901,integer
23902,"printf( ""%f"", 7 );"
23903,cast
23904,"printf( ""%f"", (float)( 7 % 9 ) );"
23905,(double)( 7 % 9 )
23906,float
23907,double
23908,Error   LNK2019 unresolved external symbol __imp_curl_global_init referenced in function twilio_send_message    test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23909,Error   LNK2019 unresolved external symbol __imp_curl_easy_strerror referenced in function twilio_send_message  test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23910,Error   LNK2019 unresolved external symbol __imp_curl_easy_init referenced in function twilio_send_message  test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23911,Error   LNK2019 unresolved external symbol __imp_curl_easy_setopt referenced in function twilio_send_message    test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23912,Error   LNK2019 unresolved external symbol __imp_curl_easy_perform referenced in function twilio_send_message   test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23913,Error   LNK2019 unresolved external symbol __imp_curl_easy_cleanup referenced in function twilio_send_message   test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23914,Error   LNK2019 unresolved external symbol __imp_curl_easy_getinfo referenced in function twilio_send_message   test_plugin C:\Dev\ts3Plugin-ExtendedPoke\pluginsdk\src\twilio.obj  1   
23915,#include <string.h>
23916,#include <C:\Program Files/Curl/curl.h>
23917,"#include ""twilio.h"""
23918,include
23919,/*
23920,https://stackoverflow.com/questions/53220084/proper-input-method-to-take-char-string-input-in-c/53221258#53221258
23921,
23922,gcc array_struct_3.c &&./a.out
23923,
23924,*/ 
23925,
23926,#include<stdio.h>
23927,#include<stdlib.h>
23928,
23929,"#define ROW 5       /* if you need a constant, #define one (or more) */"
23930,#define COL 64
23931,
23932,typedef struct student_t
23933,{
23934,    char name[COL];
23935,    int score;
23936,} student_t;
23937,
23938,"int student_t_cmp_score(const void *x, const void *y)"
23939,{
23940,    struct student_t* const *ix = x; 
23941,    struct student_t* const *iy = y; 
23942,    return ((*ix)->score > (*iy)->score) - ((*ix)->score < (*iy)->score);
23943,}
23944,int main(void)
23945,{
23946,    int n = 0;
23947,    
23948,"    // student_t student[ROW] = {{.name = """"}};"
23949,    student_t *student[ROW];
23950,
23951,"    puts(""\n[note; press enter alone to end input]\n"");"
23952,    (student[n]) = malloc(sizeof(struct student_t));
23953,    
23954,    for(;;){
23955,        char buf[COL];
23956,"        fputs(""Enter student name: "", stdout);"
23957,
23958,"        if (!fgets(buf, sizeof buf, stdin)) /* read/validate line */"
23959,            break;
23960,        if(*buf == '\n') /* check for empty line */
23961,            break;
23962,
23963,        /* parse line into name and score - validate! */
23964,
23965,"        if(sscanf(buf,""%63s %d"",student[n]->name, &student[n]->score) != 2)"
23966,        {
23967,"            fputs("" error: invalid input, conversion failed.\n"",stderr);"
23968,            continue;
23969,        }
23970,        n++;
23971,        student[n] = malloc(sizeof(struct student_t));
23972,
23973,        if(n== ROW){
23974,"            fputs(""\narray full - input complete.\n"", stdout);"
23975,            break;
23976,        }
23977,    }
23978,"    printf(""sizeof student: %zu\n"", sizeof *student);"
23979,    
23980,"    qsort(student, n, sizeof *student,student_t_cmp_score);"
23981,    
23982,    for(int i = 0; i < n; i++)
23983,"        printf(""%-16s %3d\n"",student[i]->name, student[i]->score);"
23984,    return 0;
23985,}
23986,"qsort(&student, n, sizeof *student,student_t_cmp_score);"
23987,typedef struct student_t
23988,{
23989,    char name[COL];
23990,    int score;
23991,} student_t;
23992,
23993,"int student_t_cmp_score(const void *x, const void *y)"
23994,{
23995,    struct student_t* const *ix = x; 
23996,    struct student_t* const *iy = y; 
23997,    return ((*ix)->score > (*iy)->score) - ((*ix)->score < (*iy)->score);
23998,}
23999,int main(void)
24000,{
24001,    int n = 0;
24002,    
24003,"    student_t student[ROW] = {{.name = """"}};"
24004,    // student_t *student[ROW];
24005,
24006,"    puts(""\n[note; press enter alone to end input]\n"");"
24007,    // (student[n]) = malloc(sizeof(struct student_t));
24008,    
24009,    for(;;){
24010,        char buf[COL];
24011,"        fputs(""Enter student name: "", stdout);"
24012,
24013,"        if (!fgets(buf, sizeof buf, stdin)) /* read/validate line */"
24014,            break;
24015,        if(*buf == '\n') /* check for empty line */
24016,            break;
24017,
24018,        /* parse line into name and score - validate! */
24019,
24020,"        if(sscanf(buf,""%63s %d"",student[n].name, &student[n].score) != 2)"
24021,        {
24022,"            fputs("" error: invalid input, conversion failed.\n"",stderr);"
24023,            continue;
24024,        }
24025,        n++;
24026,        // student[n] = malloc(sizeof(struct student_t));
24027,
24028,        if(n== ROW){
24029,"            fputs(""\narray full - input complete.\n"", stdout);"
24030,            break;
24031,        }
24032,    }
24033,"    printf(""sizeof student: %zu\n"", sizeof *student);"
24034,
24035,"    qsort(&student, n, sizeof *student,student_t_cmp_score);"
24036,"    // qsort(student, n, sizeof *student,student_t_cmp_score);"
24037,    
24038,    for(int i = 0; i < n; i++)
24039,"        printf(""%-16s %3d\n"",student[i].name, student[i].score);"
24040,    return 0;
24041,}
24042,gdb ./a.out
24043,(gdb) run
24044,<segfault happens here>
24045,(gdb) backtrace
24046,sizeof student: 68
24047,
24048,"Program received signal SIGSEGV, Segmentation fault."
24049,"student_t_cmp_score (x=0x7fffffffdbe0, y=0x7fffffffdc24) at array_struct_3.c:22"
24050,warning: Source file is more recent than executable.
24051,"22      int student_t_cmp_score(const void *x, const void *y)"
24052,(gdb) backtrace
24053,"#0  student_t_cmp_score (x=0x7fffffffdbe0, y=0x7fffffffdc24) at array_struct_3.c:22"
24054,"#1  0x00007ffff7dc6491 in msort_with_tmp (p=p@entry=0x7fffffffdb60, b=b@entry=0x7fffffffdab8,"
24055,    n=n@entry=2) at ./stdlib/msort.c:123
24056,"#2  0x00007ffff7dc63a5 in msort_with_tmp (n=2, b=0x7fffffffdab8, p=0x7fffffffdb60)"
24057,    at ./stdlib/msort.c:44
24058,"#3  msort_with_tmp (p=p@entry=0x7fffffffdb60, b=0x7fffffffdab8, n=n@entry=5) at ./stdlib/msort.c:52"
24059,"#4  0x00007ffff7dc6992 in msort_with_tmp (n=5, b=<optimized out>, p=0x7fffffffdb60)"
24060,    at ./stdlib/msort.c:44
24061,"#5  __GI___qsort_r (b=<optimized out>, n=<optimized out>, s=68, cmp=<optimized out>, arg=0x0)"
24062,    at ./stdlib/msort.c:253
24063,#6  0x0000555555555417 in main () at array_struct_3.c:60
24064,"int student_t_cmp_score (const void *x, const void *y)"
24065,{
24066,    const struct student_t* ix = x; 
24067,    const struct student_t* iy = y; 
24068,    return (ix->score > iy->score) - (ix->score < iy->score);
24069,}
24070,// structure for output prediction
24071,struct filedata
24072,{
24073,  void *data;
24074,  size_t size;
24075,};
24076,
24077,
24078,// input data
24079,"float in_data[] = {x, y, z, a, b, c};  // variables previously declared as float"
24080,
24081,// load model
24082,TfLiteModel* model = TfLiteModelCreateFromFile(modelPath);
24083,
24084,// create interpreter
24085,"TfLiteInterpreter* interpreter = TfLiteInterpreterCreate(model, NULL);"
24086,
24087,// allocate tensors
24088,if(TfLiteInterpreterAllocateTensors(interpreter)!= kTfLiteOk)
24089,{
24090,  return -1;
24091,}
24092,
24093,// resize input tensor
24094,int inputTensorSize = 6;
24095,"const int* inputDims[2] = {1, inputTensorSize}"
24096,
24097,"if(TfLiteInterpreterResizeInputTensor(interpreter, 0, inputDims, 2)!= kTfLiteOk)"
24098,{
24099,  return -1;
24100,}
24101,
24102,// re-allocate tensors
24103,TfLiteInterpreterAllocateTensors(interpreter);
24104,
24105,// input buffer to input tensor
24106,"TfLiteTensor* inputTensor = TfLiteInterpreterGetInputTensor(interpreter, 0);"
24107,
24108,"if(TfLiteTensorCopyFromBuffer(inputTensor, in_data, "
24109,inputTensorSize * sizeof(float))!= kTfLiteOk) // <-- This is where it fails
24110,{
24111,  return -1;
24112,}
24113,
24114,// invoke interpreter
24115,if(TfLiteInterpreterInvoke(interpreter) != kTfLiteOk)
24116,{
24117,  return -1;
24118,}
24119,
24120,// get prediction from output tensor
24121,int num_of_output = 10; // the output is a list of 10 floats
24122,
24123,struct filedata pred;
24124,
24125,float **list_pred = malloc(sizeof(float *) * num_of_output);
24126,
24127,pred.data = (void *)list_pred;
24128,pred.size = num_of_output;
24129,
24130,// Extract the output tensor data.
24131,"const TfLiteTensor* output_tensor = TfLiteInterpreterGetOutputTensor(interpreter, 0);"
24132,
24133,"TfLiteTensorCopyToBuffer(output_tensor, pred.data, pred.size * sizeof(float));"
24134,
24135,// data from both output tensors
24136,list_pred = (float **)&pred.data;
24137,
24138,for (int i=0; i<num_of_output; i++)
24139,{
24140,"  printf(""%f "", list_pred[i]);"
24141,}
24142,"printf(""\n"");"
24143,// input data
24144,"float in_data[] = {x, y, z, a, b, c};  // variables previously declared as float"
24145,
24146,// load model
24147,TfLiteModel* model = TfLiteModelCreateFromFile(modelPath);
24148,
24149,// create interpreter
24150,"TfLiteInterpreter* interpreter = TfLiteInterpreterCreate(model, NULL);"
24151,
24152,// allocate tensors
24153,if(TfLiteInterpreterAllocateTensors(interpreter)!= kTfLiteOk)
24154,{
24155,  return -1;
24156,}
24157,
24158,// resize input tensor
24159,int inputTensorSize = 6;
24160,"int inputDims[2] = {1, inputTensorSize}"
24161,
24162,"if(TfLiteInterpreterResizeInputTensor(interpreter, 0, inputDims, 2)!= kTfLiteOk)"
24163,{
24164,  return -1;
24165,}
24166,
24167,// re-allocate tensors
24168,TfLiteInterpreterAllocateTensors(interpreter);
24169,
24170,// input buffer to input tensor
24171,"TfLiteTensor* inputTensor = TfLiteInterpreterGetInputTensor(interpreter, 0);"
24172,
24173,"if(TfLiteTensorCopyFromBuffer(inputTensor, in_data, "
24174,inputTensorSize * sizeof(float))!= kTfLiteOk)
24175,{
24176,  return -1;
24177,}
24178,
24179,// invoke interpreter
24180,if(TfLiteInterpreterInvoke(interpreter) != kTfLiteOk)
24181,{
24182,  return -1;
24183,}
24184,
24185,// get prediction from output tensor
24186,int num_of_output = 10; // the output is a list of 10 floats
24187,
24188,float list_pred[10];
24189,
24190,// Extract the output tensor data.
24191,"const TfLiteTensor* output_tensor = TfLiteInterpreterGetOutputTensor(interpreter, 0);"
24192,
24193,"TfLiteTensorCopyToBuffer(output_tensor, list_pred, num_of_output * sizeof(float));"
24194,
24195,for (int i=0; i<num_of_output; i++)
24196,{
24197,"  printf(""%f "", list_pred[i]);"
24198,}
24199,"printf(""\n"");"
24200,"const int* inputDims[2] = {1, inputTensorSize}"
24201,inputDims
24202,int
24203,list_pred = (float **)&pred.data
24204,malloc
24205,free
24206,inputDims
24207,-fno-omit-frame-pointer
24208,"push %rbp; move %rsp, %rbp"
24209,ret
24210,"push %rbp; move %rsp, %rbp"
24211,"int flextcp_fd_slookup(int fd, struct socket **ps)"
24212,{
24213,  struct socket *s;
24214,
24215,  if (fd >= MAXSOCK || fhs[fd].type != FH_SOCKET) {
24216,    errno = EBADF;
24217,    return -1;
24218,  }
24219,
24220,  uint32_t lock_val = 1;
24221,  s = fhs[fd].data.s;
24222,
24223,  asm volatile (
24224,"      ""1:\n"""
24225,"      ""xchg %[locked], %[lv]\n"""
24226,"      ""test %[lv], %[lv]\n"""
24227,"      ""jz 3f\n"""
24228,"      ""2:\n"""
24229,"      ""pause\n"""
24230,"      ""cmpl $0, %[locked]\n"""
24231,"      ""jnz 2b\n"""
24232,"      ""jmp 1b\n"""
24233,"      ""3:\n"""
24234,"      : [locked] ""=m"" (s->sp_lock), [lv] ""=q"" (lock_val)"
24235,"      : ""[lv]"" (lock_val)"
24236,"      : ""memory"");"
24237,
24238,  *ps = s;
24239,  return 0;
24240,}
24241,Debug
24242,0000000000007c73 <flextcp_fd_slookup>:
24243,    7c73:   f3 0f 1e fa             endbr64 
24244,    7c77:   55                      push   %rbp
24245,"    7c78:   48 89 e5                mov    %rsp,%rbp"
24246,"    7c7b:   48 83 ec 20             sub    $0x20,%rsp"
24247,"    7c7f:   89 7d ec                mov    %edi,-0x14(%rbp)"
24248,"    7c82:   48 89 75 e0             mov    %rsi,-0x20(%rbp)"
24249,"    7c86:   81 7d ec ff ff 0f 00    cmpl   $0xfffff,-0x14(%rbp)"
24250,    7c8d:   7f 1b                   jg     7caa <flextcp_fd_slookup+0x37>
24251,"    7c8f:   8b 45 ec                mov    -0x14(%rbp),%eax"
24252,    7c92:   48 98                   cltq   
24253,"    7c94:   48 c1 e0 04             shl    $0x4,%rax"
24254,"    7c98:   48 89 c2                mov    %rax,%rdx"
24255,"    7c9b:   48 8d 05 86 86 00 00    lea    0x8686(%rip),%rax        # 10328 <fhs+0x8>"
24256,"    7ca2:   0f b6 04 02             movzbl (%rdx,%rax,1),%eax"
24257,"    7ca6:   3c 01                   cmp    $0x1,%al"
24258,    7ca8:   74 12                   je     7cbc <flextcp_fd_slookup+0x49>
24259,    7caa:   e8 31 b9 ff ff          callq  35e0 <__errno_location@plt>
24260,"    7caf:   c7 00 09 00 00 00       movl   $0x9,(%rax)"
24261,"    7cb5:   b8 ff ff ff ff          mov    $0xffffffff,%eax"
24262,    7cba:   eb 53                   jmp    7d0f <flextcp_fd_slookup+0x9c>
24263,"    7cbc:   c7 45 f4 01 00 00 00    movl   $0x1,-0xc(%rbp)"
24264,"    7cc3:   8b 45 ec                mov    -0x14(%rbp),%eax"
24265,    7cc6:   48 98                   cltq   
24266,"    7cc8:   48 c1 e0 04             shl    $0x4,%rax"
24267,"    7ccc:   48 89 c2                mov    %rax,%rdx"
24268,"    7ccf:   48 8d 05 4a 86 00 00    lea    0x864a(%rip),%rax        # 10320 <fhs>"
24269,"    7cd6:   48 8b 04 02             mov    (%rdx,%rax,1),%rax"
24270,"    7cda:   48 89 45 f8             mov    %rax,-0x8(%rbp)"
24271,"    7cde:   48 8b 55 f8             mov    -0x8(%rbp),%rdx"
24272,"    7ce2:   8b 45 f4                mov    -0xc(%rbp),%eax"
24273,"    7ce5:   87 82 c0 00 00 00       xchg   %eax,0xc0(%rdx)"
24274,"    7ceb:   85 c0                   test   %eax,%eax"
24275,    7ced:   74 0d                   je     7cfc <flextcp_fd_slookup+0x89>
24276,    7cef:   f3 90                   pause  
24277,"    7cf1:   83 ba c0 00 00 00 00    cmpl   $0x0,0xc0(%rdx)"
24278,    7cf8:   75 f5                   jne    7cef <flextcp_fd_slookup+0x7c>
24279,    7cfa:   eb e9                   jmp    7ce5 <flextcp_fd_slookup+0x72>
24280,"    7cfc:   89 45 f4                mov    %eax,-0xc(%rbp)"
24281,"    7cff:   48 8b 45 e0             mov    -0x20(%rbp),%rax"
24282,"    7d03:   48 8b 55 f8             mov    -0x8(%rbp),%rdx"
24283,"    7d07:   48 89 10                mov    %rdx,(%rax)"
24284,"    7d0a:   b8 00 00 00 00          mov    $0x0,%eax"
24285,    7d0f:   c9                      leaveq 
24286,    7d10:   c3                      retq     
24287,Release
24288,0000000000007d80 <flextcp_fd_slookup>:
24289,    7d80:   f3 0f 1e fa             endbr64 
24290,"    7d84:   81 ff ff ff 0f 00       cmp    $0xfffff,%edi"
24291,    7d8a:   7f 44                   jg     7dd0 <flextcp_fd_slookup+0x50>
24292,"    7d8c:   48 63 ff                movslq %edi,%rdi"
24293,"    7d8f:   48 8d 05 6a 85 00 00    lea    0x856a(%rip),%rax        # 10300 <fhs>"
24294,"    7d96:   48 c1 e7 04             shl    $0x4,%rdi"
24295,"    7d9a:   48 01 c7                add    %rax,%rdi"
24296,"    7d9d:   80 7f 08 01             cmpb   $0x1,0x8(%rdi)"
24297,    7da1:   75 2d                   jne    7dd0 <flextcp_fd_slookup+0x50>
24298,"    7da3:   48 8b 17                mov    (%rdi),%rdx"
24299,"    7da6:   b8 01 00 00 00          mov    $0x1,%eax"
24300,"    7dab:   87 82 c0 00 00 00       xchg   %eax,0xc0(%rdx)"
24301,"    7db1:   85 c0                   test   %eax,%eax"
24302,    7db3:   74 0d                   je     7dc2 <flextcp_fd_slookup+0x42>
24303,    7db5:   f3 90                   pause  
24304,"    7db7:   83 ba c0 00 00 00 00    cmpl   $0x0,0xc0(%rdx)"
24305,    7dbe:   75 f5                   jne    7db5 <flextcp_fd_slookup+0x35>
24306,    7dc0:   eb e9                   jmp    7dab <flextcp_fd_slookup+0x2b>
24307,"    7dc2:   31 c0                   xor    %eax,%eax"
24308,"    7dc4:   48 89 16                mov    %rdx,(%rsi)"
24309,    7dc7:   c3                      retq   
24310,"    7dc8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)"
24311,    7dcf:   00 
24312,    7dd0:   55                      push   %rbp
24313,"    7dd1:   48 89 e5                mov    %rsp,%rbp"
24314,    7dd4:   e8 b7 b7 ff ff          callq  3590 <__errno_location@plt>
24315,"    7dd9:   c7 00 09 00 00 00       movl   $0x9,(%rax)"
24316,"    7ddf:   b8 ff ff ff ff          mov    $0xffffffff,%eax"
24317,    7de4:   5d                      pop    %rbp
24318,    7de5:   c3                      retq   
24319,"    7de6:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)"
24320,    7ded:   00 00 00 
24321,push   %rbp
24322,if
24323,-fno-shrink-wrap
24324,if
24325,-fno-shrink-wrap
24326,__errno_location
24327,ret
24328,asm()
24329,asm()
24330,asm
24331,if
24332,#include  <stdio.h>
24333,
24334,
24335,int main(void)
24336,{
24337,"    printf(""Hello, World!\n"");"
24338,    return 0;
24339,}
24340,PS C:\Users\dimit\c> gcc hello.c -Wall
24341,"hello.c:1:9: error: expected '=', ',', ';', 'asm' or '__attribute__' before '<' token"
24342,    1 | include <stdio.h>
24343,type hello.c
24344,fgets()
24345,#include <stdio.h>
24346,#include <stdlib.h>
24347,#include <string.h>
24348,
24349,"int main(int agrc, char** agrv) {"
24350,    FILE* input;
24351,"    input = fopen(agrv[1], ""r"");"
24352,
24353,    int n = *agrv[2]-'0';
24354,    int line = 0;
24355,    char text[11];
24356,    char** tab = malloc(1000000*sizeof(text));
24357,
24358,"    while(fgets(text, sizeof(text), input) != 0) {"
24359,        tab[line] = text;
24360,        line++;
24361,    }
24362,
24363,    fclose(input);
24364,
24365,    int jump = line-n;
24366,    
24367,    for(int i=jump; i<line; i++) {
24368,"        printf(""%s\n"", tab[i]);"
24369,    }
24370,}
24371,"    while(fgets(text, sizeof(text), input) != 0) {"
24372,        char text2[11];
24373,"        strcpy(text2, text);"
24374,        tab[line] = text2;
24375,        line++;
24376,    }
24377,tab[line] = text
24378,argv
24379,argc
24380,input
24381,fopen
24382,tab[line] = text;
24383,tab[line]
24384,text
24385,tab[i]
24386,text
24387,#include <stdio.h>
24388,#include <stdlib.h>
24389,#include <ctype.h> // for 'isdigit()'
24390,
24391,// Factor processing into functions for clarity
24392,"void tail( FILE *ifp, size_t n ) {"
24393,    char text[ 9 ][ 126 + 1 + 1 ]; // 9 'rows' up to 128 bytes each
24394,    size_t lnCnt = 0;
24395,
24396,"    while( fgets( text[ lnCnt % 9 ], sizeof text[0], ifp ) != NULL )"
24397,        lnCnt++;
24398,
24399,    // Do the math to workout what is wanted and what's available
24400,    if( lnCnt < n )
24401,"        n = lnCnt, lnCnt = 0;"
24402,    else
24403,        lnCnt += 9 - n;
24404,
24405,    // output
24406,    while( n-- )
24407,"        printf( ""%s"", text[ lnCnt++ % 9 ] );"
24408,
24409,}
24410,
24411,"int main( int argc, char *argv[] ) {"
24412,    // Check parameters meet requirements
24413,    if( argc != 3 || !isdigit( argv[ 2 ][ 0 ] ) ) {
24414,"        fprintf( stderr, ""Usage: %s filename #lines (1-9)\n"", argv[ 0 ] );"
24415,        exit( EXIT_FAILURE );
24416,    }
24417,
24418,    // Check functions didn't fail
24419,"    FILE *ifp = fopen( argv[ 1 ], ""r"" );"
24420,    if( ifp == NULL ) {
24421,"        fprintf( stderr, ""Cannot open '%s'\n"", argv[ 1 ] );"
24422,        exit( EXIT_FAILURE );
24423,    }
24424,
24425,    // do processing
24426,"    tail( ifp, argv[ 2 ][ 0 ] - '0' );"
24427,
24428,    // clean up
24429,    fclose( ifp );
24430,
24431,    return 0;
24432,}
24433,"void swap(void* x,void* y){"
24434,  void* temp=x;
24435,  x=y;
24436,  y=temp;
24437,}
24438,"  printf(""before %s %s\n"",(char*)array[i],(char*)array[j] );"
24439,"  swap(array[i], array[j]);"
24440,"  printf(""after %s %s\n"",(char*)array[i],(char*)array[j] );"
24441,"void swap(void* x,void* y){"
24442,"  printf(""  after IN %s %s\n"",(char*)x,(char*)y );"
24443,  void* temp=x;
24444,  x=y;
24445,  y=temp;
24446,"  printf(""  after IN %s %s\n"",(char*)x,(char*)y );"
24447,}
24448,before fannullone falafel
24449,  after IN fannullone falafel
24450,  after IN falafel fannullone
24451,after fannullone falafel
24452,int
24453,void*
24454,int
24455,void *
24456,void **
24457,"void swap( void **x, void **y )"
24458,{
24459,    void *temp = *x;
24460,    *x = *y;
24461,    *y = temp;
24462,}
24463,#include <stdio.h>
24464,
24465,"void swap( void **x, void **y )"
24466,{
24467,    void *temp = *x;
24468,    *x = *y;
24469,    *y = temp;
24470,}
24471,
24472,int main( void ) 
24473,{
24474,"    void *s1 = ""Hello"";"
24475,"    void *s2 = ""World"";"
24476,
24477,"    printf( ""s1 = %s, s2 = %s\n"", ( char * )s1, ( char * )s2 );"
24478,
24479,"    swap( &s1, &s2 );"
24480,
24481,"    printf( ""s1 = %s, s2 = %s\n"", ( char * )s1, ( char * )s2 );"
24482,}
24483,"s1 = Hello, s2 = World"
24484,"s1 = World, s2 = Hello"
24485,void**
24486,char**
24487,memcpy()
24488,"#define SWAP(a, b)     \"
24489,   do {                \
24490,     void *tmp = *(a); \
24491,     *(a) = *(b);      \
24492,     *(b) = tmp;       \
24493,   } while (0)
24494,'mips64-unknown-linux-gcc'
24495,exec
24496,//prog.c : gcc prog.c -o prog
24497,"int main(int argc, char *argv[]) {"
24498,"   execvp(""mips64-unknown-linux-gcc"",argv);"
24499,}
24500,mips64-unknown-linux-gcc
24501,argv
24502,execv
24503,getenv(”CC”)
24504,./prog mips64-unknown-linux-gcc --sysroot=<<...>> -O3 -Wl -L <<...>> -L <<...>> -I <<...>> -L <<...>> abcd.o a1.o b2.o -o prog
24505,execv
24506,main()
24507,"int main(int argc, char *argv)"
24508,"int main(int argc, char **argv)"
24509,"int main(int argc, char *argv[])"
24510,"execvp(""gcc"",argv);"
24511,argv
24512,"char *argv[] = {""proc"",""mips64-unkown-linux-gcc"", ""--sysroot=<<...>>"", ..., ""-o"", ""prog"", NULL};`"
24513,"execvp(argv[1], argv+1);"
24514,execvp
24515,list = gtk_list_box_new();
24516,int n_rows=? *listbox_height/row_height*
24517,for(int i=0;i<n_rows;i++){
24518,    row=gtk_list_box_row_new();
24519,
24520,    label = gtk_label_new (text);
24521,"    gtk_container_add (GTK_CONTAINER (row), label);"
24522,"    gtk_list_box_insert (GTK_LIST_BOX (list), row, -1);"
24523,}
24524,"void print_sort(int [], int);"
24525,
24526,int main()
24527,{
24528,    
24529,"   int size, iter;"
24530,    
24531,"    printf(""Enter the size of the array : "");"
24532,"    scanf(""%d"", &size);"
24533,    
24534,    int arr[size];
24535,    
24536,"    printf(""Enter the %d elements\n"", size);"
24537,    for (iter = 0; iter < size; iter++)
24538,    {
24539,"        scanf(""%d"", &arr[iter]);"
24540,    }
24541,    
24542,"    print_sort(arr, size);"
24543,}
24544,:-)
24545,:)
24546,#include<stdio.h>
24547,#include<limits.h>
24548,
24549,"void print_sort(int arr[], int len) {"
24550,    int current_value = INT_MIN;
24551,    int numbers_remaining = len;
24552,    while (numbers_remaining > 0) {
24553,        int next_value = INT_MAX;
24554,        for (int j = 0; j < len; j++) {
24555,            if (arr[j] == current_value) {
24556,"                printf(""%d "", arr[j]);"
24557,                numbers_remaining--;
24558,            }
24559,            else if (arr[j] > current_value && arr[j] < next_value) {
24560,                next_value = arr[j];
24561,            }
24562,        }
24563,        current_value = next_value;
24564,    }
24565,}
24566,
24567,int main()
24568,{
24569,    
24570,"   int size, iter;"
24571,    
24572,"    printf(""Enter the size of the array : "");"
24573,"    scanf(""%d"", &size);"
24574,    
24575,    int arr[size];
24576,    
24577,"    printf(""Enter the %d elements: "", size);"
24578,    for (iter = 0; iter < size; iter++)
24579,    {
24580,"        scanf(""%d"", &arr[iter]);"
24581,    }
24582,"    printf(""after sorting: "");"
24583,"    print_sort(arr, size);"
24584,"    printf(""\n"");"
24585,"    printf(""original array values: "");"
24586,    for (int i = 0; i < size; i++) {
24587,"        printf(""%d "", arr[i]);"
24588,    }
24589,"    printf(""\n"");"
24590,}
24591,print_sort
24592,current_value = INT_MIN
24593,numbers_remaining = 4
24594,"output = """""
24595,current_value = -2
24596,numbers_remaining = 4
24597,"output = """""
24598,current_value
24599,current_value = 1
24600,numbers_remaining = 3
24601,"output = ""-2 """
24602,current_value = 7
24603,numbers_remaining = 1
24604,"output = ""-2 1 1 """
24605,current_value = INT_MAX
24606,numbers_remaining = 0
24607,"output = ""-2 1 1 7 """
24608,struct temperature {
24609,    float *data;
24610,    int size;
24611,} temperatures;
24612,
24613,struct temperature get_temperature_Data() {
24614,    temperatures.size = 0;
24615,    temperatures.data = (float *)malloc(sizeof(float));
24616,    temperatures.data[temperatures.size++] = 25.9;
24617,    temperatures.data[temperatures.size++] = 55.2;
24618,    return temperatures;
24619,}
24620,
24621,"void calculate_temperatures(temperatures, testmessage) {"
24622,    //test output for correct data
24623,"    printf(""%s\n"", testmessage);"
24624,"    printf(""test %d\n"", temperatures.size);"
24625,}
24626,
24627,int main() {
24628,    int i;
24629,    temperatures = get_temperature_Data();
24630,"    calculate_temperatures(temperatures, ""Testoutput"");"
24631,}
24632,"void calculate_temperatures(temperatures, char *testmessage) {"
24633,"void calculate_temperatures(temperatures, char testmessage[]) {"
24634,gcc
24635,warning: type of ‘temperatures’ defaults to ‘int’ [-Wimplicit-int]
24636,"    void calculate_temperatures(temperatures, testmessage) {"
24637,"void calculate_temperatures(struct temperature temperatures, const char *testmessage) {"
24638,get_temperature_Data
24639,#include <stdio.h>
24640,#include <math.h>
24641,long Cardno;
24642,long Digits;
24643,long Divider;
24644,int main(void)
24645,{
24646,    Cardno = 1234567890123456;
24647,    Digits = log10(Cardno) +1;
24648,
24649,    if (Digits == 13 || Digits == 15 || Digits == 16)
24650,    {
24651,        for(int i = 0; i <= Digits; i++)
24652,    {
24653,"       printf(""%lo\n"", Cardno/10000000 % 10);"
24654,    }
24655,    }
24656,    else
24657,    {
24658,"        printf(""INVALID\n"");"
24659,    }
24660,}
24661,:)
24662,long long
24663,long
24664,Digits
24665,int
24666,log10()
24667,double
24668,double
24669,Cardno/10000000 % 10
24670,"(Cardno/ (long long )pow(10, i)) % 10"
24671,#include <stdio.h>
24672,#include <math.h>
24673,long long Cardno;
24674,int Digits;
24675,long long Divider;
24676,int main(void)
24677,{
24678,    Cardno = 1234567890123456;
24679,    Digits = (int)log10((double )Cardno) +1;
24680,
24681,    if (Digits == 13 || Digits == 15 || Digits == 16)
24682,    {
24683,        for(int i = 0; i <= Digits; i++)
24684,        {
24685,"            printf(""%ld\n"",(Cardno/ (long long )pow(10, i)) % 10);"
24686,        }
24687,    }
24688,    else
24689,    {
24690,"        printf(""INVALID\n"");"
24691,    }
24692,}
24693,log10()
24694,<math.h>
24695,do {
24696,"    printf(""\n\t***CHOOSE HOW TO SORT***\n\n\tBy firstname: 1\n\tBy lastname: 2\n\tBy age: 3\n\tExit Program: 4\n\n"");"
24697,"    scanf(""%d"", &choice);"
24698,    switch (choice) {
24699,        case 1:
24700,"        printf(""\t***SORTING BY FIRSTNAME...***\n\n"");"
24701,"        qsort(P, n, sizeof *P, Person_cmp_firstname);"
24702,"        printf(""\t***DONE***\n\n"");"
24703,        for (i = 0; i < n; i++) {
24704,"            printf(""Firstname: %s\t| Lastname: %s\t| Age: %d\n"", P[i]->firstname, P[i]->lastname, P[i]->age);"
24705,        }
24706,        break;
24707,        
24708,        case 2:
24709,"        printf(""\t***SORTING BY LASTNAME...***\n\n"");"
24710,"        qsort(P, n, sizeof *P, Person_cmp_lastname);"
24711,"        printf(""\t***DONE***\n\n"");"
24712,        for (i = 0; i < n; i++) {
24713,"            printf(""Firstname: %s\t| Lastname: %s\t| Age: %d\n"", P[i]->firstname, P[i]->lastname, P[i]->age);"
24714,        }
24715,        break;
24716,        
24717,        case 3:
24718,"        printf(""\t***SORTING BY AGE...***\n\n"");"
24719,"        qsort(P, n, sizeof *P, Person_cmp_age);"
24720,"        printf(""\t***DONE***\n\n"");"
24721,        for (i = 0; i < n; i++) {
24722,"            printf(""Firstname: %s\t| Lastname: %s\t| Age: %d\n"",P[i]->firstname, P[i]->lastname, P[i]->age);"
24723,        }
24724,        break;
24725,        
24726,        case 4:
24727,"        printf(""\t***EXITING PROGRAM***\n\n"");"
24728,        for (i = 0; i < n; i++) {
24729,            free(P[i]);
24730,        }
24731,        exit(0);
24732,        
24733,        default:
24734,"        printf(""\t***INVALID OPTION***\n\n"");"
24735,        break;
24736,    }
24737,} while (1);
24738,...
24739,default:
24740,"            printf(""\t***INVALID OPTION***\n\n"");"
24741,            count = count + 2;
24742,            break;
24743,        }
24744,    }while(count < 2);
24745,scanf()
24746,switch
24747,default
24748,"printf(""Invalid option value %d; please try again\n"", choice);"
24749,scanf()
24750,if
24751,goto
24752,goto
24753,int main() {
24754,    do {
24755,        ...
24756,        switch (choice) {
24757,        ...
24758,        default:
24759,"            printf(""\t***INVALID OPTION***\n\n"");"
24760,            goto invalid_input_found;
24761,        }
24762,    } while (1);
24763,invalid_input_found:
24764,    handle_error();
24765,}
24766,stdbool.h
24767,#include<stdbool.h>
24768,
24769,int main() {
24770,    bool run_loop = true;
24771,    do {
24772,        ...
24773,        switch (choice) {
24774,        ...
24775,        default:
24776,"            printf(""\t***INVALID OPTION***\n\n"");"
24777,            run_loop = false;
24778,            break;
24779,        }
24780,    } while (run_loop);
24781,    handle_error();
24782,}
24783,#include <stdio.h>
24784,#include <stdlib.h>
24785,
24786,int mat(int n)
24787,{
24788,"    printf(""hello"");"
24789,"    int temp = n, count = 0;"
24790,    while (temp != 0)
24791,    {
24792,        temp = n % 10;
24793,        switch (temp)
24794,        {
24795,        case 1:
24796,            count += 2;
24797,            break;
24798,        case 7:
24799,            count += 3;
24800,            break;
24801,        case 4:
24802,            count += 4;
24803,            break;
24804,        case 2:
24805,        case 3:
24806,        case 5:
24807,            count += 5;
24808,            break;
24809,        case 6:
24810,        case 0:
24811,        case 9:
24812,            count += 6;
24813,            break;
24814,        case 8:
24815,            count += 7;
24816,            break;
24817,        }
24818,    }
24819,    return count;
24820,}
24821,
24822,int main(void)
24823,{
24824,
24825,"    int t, n, h;"
24826,"    scanf(""%d"", &t);"
24827,    while (t--)
24828,    {
24829,"        scanf(""%d"", &n);"
24830,    
24831,        h = mat(n);
24832,"        printf(""%d\n"", h);"
24833,    }
24834,}
24835,temp = n % 10;
24836,n = n / 10;
24837,scanf()
24838,n /= 10;
24839,#include <stdio.h>
24840,#include <stdlib.h>
24841,
24842,int mat( int n ) {
24843,"    printf( ""hello\n"" );"
24844,
24845,    // contiguous array of 10 values (some repeated)
24846,"    int incr[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };"
24847,    int count = 0;
24848,
24849,    // sum from array values based on digits of value received
24850,    do {
24851,        count += incr[ n % 10 ];
24852,    } while( n /= 10 );
24853,
24854,    return count;
24855,}
24856,
24857,int main( void ) {
24858,    int t = 0; // ALWAYS initiaialise variables
24859,"    scanf( ""%d"", &t );"
24860,
24861,    while( t-- ) {
24862,        int n = 0; // declare variables close to use
24863,"        scanf( ""%d"", &n );"
24864,    
24865,        // No need for 'h'. print returned value directly.
24866,"        printf( ""%d  ==>  %d\n"", n, mat( n ) );"
24867,    }
24868,}
24869,:-)
24870,main()
24871,{
24872,
24873,"    int j, arr[10] , a;"
24874,    int n = 10;
24875,    while (n--)
24876,    {
24877,"        scanf(""%d"", &a);"
24878,"        printf(""%d \n"", ++arr[a]);"
24879,    }
24880,}
24881,9
24882,0 
24883,4
24884,1781349929 
24885,3
24886,0 
24887,2
24888,395049983 
24889,1
24890,0
24891,main()
24892,{
24893,
24894,"    int j, arr[10000] , a;"
24895,    int n = 10;
24896,    while (n--)
24897,    {
24898,"        scanf(""%d"", &a);"
24899,"        printf(""%d \n"", ++arr[a]);"
24900,    }
24901,}
24902,    
24903,9
24904,0 
24905,4
24906,0 
24907,3
24908,0 
24909,2
24910,0 
24911,1
24912,0
24913,int arr[10]{};
